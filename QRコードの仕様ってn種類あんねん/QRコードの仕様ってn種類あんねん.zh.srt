1
01:00:03,566 --> 01:00:07,566
QR 碼的規格有 N 種類型

2
01:00:07,566 --> 01:00:10,066
N 是多少，你知道嗎？

3
01:00:10,066 --> 01:00:14,133
請務必在 #iosdc #d 標籤發推文喔

4
01:00:14,133 --> 01:00:15,066
好的

5
01:00:15,066 --> 01:00:15,966
我是 Ryomm

6
01:00:15,966 --> 01:00:17,333
請多多指教

7
01:00:17,333 --> 01:00:19,466
我是一名 iOS 應用程式工程師

8
01:00:19,466 --> 01:00:26,766
工作上，主要開發處理電車和巴士等交通票券的 MaaS 應用程式

9
01:00:27,533 --> 01:00:31,066
好，想要生成 QR 碼

10
01:00:31,733 --> 01:00:33,500
QR 碼的生成的時候

11
01:00:33,500 --> 01:00:38,366
需要使用 CIFilter 的 CIQRCodeGenerator

12
01:00:39,033 --> 01:00:42,533
inputMessage 可以指定要包含在 QR 碼中的資料

13
01:00:42,699 --> 01:00:47,233
inputCorrectionLevel 可以指定錯誤修正等級

14
01:00:47,633 --> 01:00:49,933
所謂錯誤修正等級

15
01:00:49,933 --> 01:00:53,033
就是指即使有一定程度的髒汙或遮蔽

16
01:00:53,033 --> 01:00:55,966
仍然能夠讀取的等級

17
01:00:55,966 --> 01:00:58,266
稍微調整一下大小

18
01:00:58,266 --> 01:01:01,033
QR 碼就成功生成了

19
01:01:01,033 --> 01:01:03,099
真是可喜可賀

20
01:01:03,599 --> 01:01:05,800
如果是這樣就好了

21
01:01:06,566 --> 01:01:11,900
最近在 MaaS 領域，QR 票券正大為流行

22
01:01:11,900 --> 01:01:15,099
即使沒有像驗票閘門那樣的大型設備

23
01:01:15,099 --> 01:01:17,699
也能輕鬆導入

24
01:01:18,400 --> 01:01:20,466
不過這種 QR 票券

25
01:01:20,466 --> 01:01:23,166
根據讀取 QR 碼的終端裝置

26
01:01:23,166 --> 01:01:26,766
有時 QR 的規格會被嚴格規定

27
01:01:26,766 --> 01:01:27,966
如果不符合規格

28
01:01:27,966 --> 01:01:30,933
就可能發生無法讀取的情況

29
01:01:32,033 --> 01:01:36,633
其中之一就是被稱為版本 (Version) 的規格

30
01:01:37,733 --> 01:01:42,266
QR 碼最小的方格稱為儲存格（Cell）

31
01:01:42,266 --> 01:01:47,633
這個儲存格縱橫各有幾個的定義就用版本來表示

32
01:01:47,966 --> 01:01:52,633
根據版本不同，QR 碼能包含的資料量也會改變

33
01:01:53,800 --> 01:01:56,400
版本從 1 到 40

34
01:01:56,400 --> 01:02:00,000
版本越大，儲存格的數量也會增加

35
01:02:00,000 --> 01:02:04,900
也就是說，QR 碼能包含的資料量就會變大

36
01:02:04,900 --> 01:02:09,266
根據模式和錯誤修正等級的不同，也會有相當大的差異

37
01:02:09,266 --> 01:02:13,433
例如在錯誤修正等級 M、包含二進位資料的情況下

38
01:02:13,433 --> 01:02:16,033
版本 1 只能放 14 位元組

39
01:02:16,033 --> 01:02:19,133
版本 5 可以放 84 位元組

40
01:02:19,133 --> 01:02:22,066
版本 10 可以容納 213 位元組

41
01:02:22,066 --> 01:02:27,800
最大的版本 40 則可以容納高達 2,331 位元組的資料

42
01:02:28,400 --> 01:02:31,099
根據 QR 碼的讀取裝置不同

43
01:02:31,099 --> 01:02:35,500
有時候只能讀取指定版本的 QR 碼

44
01:02:37,000 --> 01:02:43,366
那麼，讓我們回到一開始使用 CIFilter 生成 QR 碼的部分,

45
01:02:43,366 --> 01:02:45,133
各位有注意到嗎？

46
01:02:46,466 --> 01:02:51,966
這裡只能指定要包含的資料和錯誤修正等級而已！？

47
01:02:52,733 --> 01:02:56,166
要怎麼指定特定的 QR 碼版本呢？

48
01:02:57,133 --> 01:03:01,066
無論怎麼查都找不到指定版本的方法啊！

49
01:03:01,066 --> 01:03:04,533
會擅自用各種版本生成

50
01:03:06,000 --> 01:03:09,300
會擅自用各種版本生成？！

51
01:03:10,000 --> 01:03:14,500
這不就是根據 QR 碼要包含的資料位元組量

52
01:03:14,500 --> 01:03:18,266
自動最佳化的意思嗎

53
01:03:18,266 --> 01:03:19,833
沒發現

54
01:03:19,833 --> 01:03:21,566
發現了

55
01:03:22,599 --> 01:03:24,566
也就是說這樣不就行了

56
01:03:26,099 --> 01:03:28,066
配合版本的最大值

57
01:03:28,066 --> 01:03:31,266
在開頭用零填充來調整長度

58
01:03:31,266 --> 01:03:33,566
在不改變儲存資料的情況下

59
01:03:33,566 --> 01:03:37,266
目標版本的 QR 碼圖像就能輸出了

60
01:03:38,699 --> 01:03:40,966
這樣一來，即使是相同的二進位資料

61
01:03:40,966 --> 01:03:44,266
也能生成目標版本的 QR 碼了

62
01:03:44,800 --> 01:03:46,099
拍拍手

63
01:03:48,466 --> 01:03:49,900
謝謝大家

64
01:03:50,433 --> 01:03:51,733
這樣一來只要努力的話

65
01:03:51,733 --> 01:03:55,633
感覺還能製作出各式各樣的 QR 碼呢

66
01:03:56,533 --> 01:03:59,366
各位知道 Frame QR  (フレームQR) 嗎

67
01:03:59,800 --> 01:04:05,833
這個 Frame QR  是可以把 QR 碼本身作為畫布自由使用的一個服務

68
01:04:05,866 --> 01:04:12,300
不過這個如果個人要認真製作的話其實相當困難

69
01:04:12,300 --> 01:04:17,033
但是可以利用錯誤修正來模仿重現

70
01:04:17,033 --> 01:04:22,800
在剛才的說明中，有稍微帶過錯誤修正等級這個詞

71
01:04:22,800 --> 01:04:27,233
大家可能只是聽到名，就只會覺得「應該就是修正錯誤吧」這種感覺

72
01:04:27,233 --> 01:04:29,433
所以我想好好說明一下

73
01:04:29,433 --> 01:04:33,333
QR 碼的錯誤修正等級有 4 種

74
01:04:33,333 --> 01:04:35,133
各自的復原率是

75
01:04:35,133 --> 01:04:37,533
L 是 7%

76
01:04:37,533 --> 01:04:39,099
M 是 15%

77
01:04:39,099 --> 01:04:40,800
Q 是 25%

78
01:04:40,800 --> 01:04:42,599
H 是 30%

79
01:04:44,366 --> 01:04:46,766
把 QR 碼拉長攤開來看

80
01:04:46,766 --> 01:04:50,599
扣除標頭 (Header) 和填充 (Padding) 之後，資料就放在這裡

81
01:04:50,933 --> 01:04:56,133
構成資料的最小單位稱為碼字 (Codeword)

82
01:04:56,833 --> 01:05:00,800
在 QR 碼中，1 個碼字是 8 位元

83
01:05:02,300 --> 01:05:05,033
假設有 10 個資料碼字

84
01:05:05,199 --> 01:05:09,066
我們想要能夠修正其中一半的錯誤

85
01:05:09,699 --> 01:05:14,366
要修正 1 個碼字，所需的錯誤修正碼字數量

86
01:05:14,366 --> 01:05:16,933
是它的 2 倍

87
01:05:17,333 --> 01:05:20,833
所以錯誤修正碼字數量就是 10 個

88
01:05:21,699 --> 01:05:26,199
因此全部程式碼字 20 個中有 5 個可以修正

89
01:05:26,666 --> 01:05:34,300
修正率是 5 除以 20 等於 25%，這相當於等級 Q

90
01:05:35,800 --> 01:05:40,233
另外當版本變大、資料數量增加時

91
01:05:40,233 --> 01:05:43,666
如果將整體作為一個區塊進行錯誤修正

92
01:05:44,133 --> 01:05:46,633
會發生偏差變得嚴重

93
01:05:46,633 --> 01:05:50,933
或是錯誤變得難以修正等現象

94
01:05:50,933 --> 01:05:54,033
因此 Reed Solomon 區塊就登場了

95
01:05:54,766 --> 01:06:00,733
首先將資料程式碼字分割成多個區塊

96
01:06:01,233 --> 01:06:06,666
對分割後的每個資料程式碼字進行錯誤修正

97
01:06:07,466 --> 01:06:10,066
這個分割後的資料程式碼字與

98
01:06:10,066 --> 01:06:14,733
錯誤更正碼字的集合稱為 Reed Solomon (RS) 區塊

99
01:06:15,566 --> 01:06:17,599
在這種情況下，修正率是

100
01:06:17,599 --> 01:06:21,966
針對 RS 區塊內的碼字而言

101
01:06:23,866 --> 01:06:26,699
所以版本 1 大概就是這種感覺

102
01:06:27,533 --> 01:06:31,500
不過這個更正率是理論上的最低保證值

103
01:06:31,500 --> 01:06:34,466
實際上就算再破損一點也能讀取

104
01:06:34,466 --> 01:06:39,833
而且根據破損的方式，或是讀取端相當努力的情況

105
01:06:39,833 --> 01:06:42,333
也取決於讀取端的性能

106
01:06:43,033 --> 01:06:47,699
在製作模仿 Frame QR 的情況下

107
01:06:47,699 --> 01:06:50,666
用圖像刻意破壞的數值

108
01:06:50,666 --> 01:06:53,733
盡可能依照理論值會比較好

109
01:06:55,133 --> 01:06:57,966
那麼，既然已經知道圖片的大小

110
01:06:57,966 --> 01:07:00,699
我們就來生成 QR 碼並進行合成吧

111
01:07:01,233 --> 01:07:03,866
首先，先正常地製作 QR 碼

112
01:07:04,866 --> 01:07:09,033
合成時會使用 UIGraphicsImageRenderer

113
01:07:09,500 --> 01:07:13,400
使用 CIFilter 生成的 QR 碼

114
01:07:13,766 --> 01:07:16,366
會有這種稱為靜區 (Quiet Zone) 的

115
01:07:16,500 --> 01:07:20,133
環繞周圍的留白

116
01:07:21,066 --> 01:07:23,166
在 QR 碼的定義上

117
01:07:23,166 --> 01:07:25,033
QR 碼的靜區

118
01:07:25,033 --> 01:07:27,366
4 個儲存格的留白圍繞在周圍

119
01:07:27,366 --> 01:07:29,033
是這樣定義的

120
01:07:29,266 --> 01:07:32,500
但是用 CIFilter 生成的 QR 碼

121
01:07:32,500 --> 01:07:35,199
只有 1 個儲存格的留白

122
01:07:35,199 --> 01:07:38,099
所以左右合計會變大 2 個儲存格

123
01:07:38,099 --> 01:07:40,533
以這個狀態來計算圖片大小

124
01:07:41,400 --> 01:07:43,833
調整位置並合成

125
01:07:44,599 --> 01:07:47,166
框架 QR 碼完成了

126
01:07:47,166 --> 01:07:49,066
掌聲鼓勵

127
01:07:50,699 --> 01:07:51,966
謝謝大家

128
01:07:51,966 --> 01:07:54,699
特別不考慮直接放置圖片的情況下

129
01:07:54,699 --> 01:07:58,666
錯誤修正等級盡可能設定高一點的話

130
01:07:58,666 --> 01:08:01,400
復原的可能性也會提高

131
01:08:01,400 --> 01:08:02,833
所以這樣做比較好

132
01:08:03,166 --> 01:08:06,500
本來想說話題就到這裡結束

133
01:08:06,500 --> 01:08:08,933
但才過了 10 分鐘左右

134
01:08:08,933 --> 01:08:11,033
比預期還要早結束了

135
01:08:11,033 --> 01:08:14,333
所以接下來要講的是原本想放進來的內容

136
01:08:14,333 --> 01:08:16,000
但驗證來不及完成

137
01:08:16,000 --> 01:08:18,366
來說說還在進行中的嘗試

138
01:08:19,699 --> 01:08:20,800
剛才那樣

139
01:08:20,800 --> 01:08:23,166
我想說既然能做出模擬 Frame QR

140
01:08:23,166 --> 01:08:24,866
就變得超級得意忘形

141
01:08:24,866 --> 01:08:28,333
開始覺得應該能做出更特殊的 QR 碼

142
01:08:28,333 --> 01:08:30,933
就更加得意忘形了

143
01:08:32,300 --> 01:08:37,133
於是開始想說能不能做出分割 QR 碼之類的

144
01:08:37,800 --> 01:08:43,800
QR 碼無法容納版本 40 容量以上的資料

145
01:08:44,600 --> 01:08:48,100
但是可以透過分割來突破上限

146
01:08:48,100 --> 01:08:53,466
可能有人在藥物手冊的 QR 碼等地方看過

147
01:08:54,733 --> 01:08:57,600
之前把 QR 碼拉長的時候

148
01:08:57,600 --> 01:09:00,133
有稍微提到標頭 (Header)

149
01:09:00,133 --> 01:09:01,566
一般的 QR 碼

150
01:09:01,566 --> 01:09:06,666
標頭只有 4 位元，裡面放了模式指示子而已

151
01:09:06,666 --> 01:09:08,633
其實沒有放太多資料

152
01:09:09,466 --> 01:09:12,033
分割 QR 碼的情況

153
01:09:12,566 --> 01:09:16,933
在標頭開頭的 4 位元放入 3 的話

154
01:09:16,933 --> 01:09:21,733
就會被判斷為分割 QR 碼

155
01:09:22,833 --> 01:09:29,699
然後接下來的 4 位元放入分割後的 QR 碼是第幾個的頁碼

156
01:09:29,699 --> 01:09:36,466
再接下來的 4 位元則儲存最大的頁數

157
01:09:36,866 --> 01:09:39,000
最大的頁數是 4 位元

158
01:09:39,000 --> 01:09:43,033
也就是說最多可以分割成 16 個

159
01:09:43,633 --> 01:09:46,766
接下來的 4 位元是同位元 (Parity) 的高位

160
01:09:46,766 --> 01:09:47,633
4 位元

161
01:09:47,633 --> 01:09:51,333
再接下來則是放入同位元的低 4 位元

162
01:09:51,333 --> 01:09:53,266
這個同位元

163
01:09:53,266 --> 01:09:56,666
是所有要連結的 QR 碼共通的東西

164
01:09:56,666 --> 01:10:01,433
會針對全部的資料計算同位元來使用

165
01:10:01,433 --> 01:10:05,266
所以在連結 QR 的讀取端

166
01:10:05,266 --> 01:10:08,566
會被當作連結用 ID 來處理

167
01:10:10,000 --> 01:10:14,699
其他部分幾乎都跟普通的 QR 碼一樣製作

168
01:10:16,066 --> 01:10:20,199
光聽這些，是不是覺得好像也不是做不到？

169
01:10:21,566 --> 01:10:24,866
但是用 CIQRCodeGenerator

170
01:10:24,866 --> 01:10:27,199
能不能修改標頭資訊呢？

171
01:10:27,199 --> 01:10:28,066
嗯⋯⋯

172
01:10:29,133 --> 01:10:30,399
做不到

173
01:10:30,933 --> 01:10:32,333
太得意忘形了

174
01:10:32,333 --> 01:10:33,433
真是令人難過

175
01:10:34,933 --> 01:10:36,899
所以我打算手工製作

176
01:10:37,233 --> 01:10:39,433
因為只是要修改標頭資訊

177
01:10:39,433 --> 01:10:42,066
總之只要能做出普通的 QR 碼

178
01:10:42,066 --> 01:10:43,800
應該就能做到了

179
01:10:44,233 --> 01:10:48,300
有一個叫做 Zebra Crossing 的 Java 製 QR 碼生成

180
01:10:48,300 --> 01:10:50,866
開源函式庫

181
01:10:51,166 --> 01:10:54,500
目前它已經進入維護模式

182
01:10:54,500 --> 01:10:58,600
所以有人用 C++ 重新改寫

183
01:10:58,600 --> 01:11:03,566
並進行了各種改善，叫做 Zebra Crossing C++ 的函式庫

184
01:11:03,566 --> 01:11:04,866
我會參考它

185
01:11:05,333 --> 01:11:09,366
話雖如此，我覺得我看不懂 C++

186
01:11:09,366 --> 01:11:12,566
所以目前正在嘗試用 Swift 改寫

187
01:11:12,933 --> 01:11:16,333
如果要全部解說的話，這次時間會不夠用

188
01:11:16,333 --> 01:11:18,833
所以我會說明到相當程度為止

189
01:11:19,800 --> 01:11:22,199
QR 碼有四種模式

190
01:11:22,199 --> 01:11:23,899
由模式指示子來指定

191
01:11:24,233 --> 01:11:27,500
其中如果使用這個 8 位元模式的話

192
01:11:27,500 --> 01:11:29,966
就可以儲存二進位資料

193
01:11:30,366 --> 01:11:32,433
能夠放入二進位資料的意思是

194
01:11:32,600 --> 01:11:34,800
除了日文以外，任何字串

195
01:11:34,800 --> 01:11:36,433
都可以放進去

196
01:11:37,366 --> 01:11:39,800
這次我決定一律使用二進位模式

197
01:11:39,800 --> 01:11:40,899
使用することにします

198
01:11:41,399 --> 01:11:43,399
這個二進位模式 (Binary Mode) 的話

199
01:11:43,399 --> 01:11:48,166
QR 碼生成端就不用費力進行各種轉換

200
01:11:48,166 --> 01:11:51,266
可以直接放入二進位資料

201
01:11:51,266 --> 01:11:55,033
對生成端來說是個可以偷懶的便利模式

202
01:11:55,800 --> 01:11:58,500
模式決定好了,所以作為標頭資訊

203
01:11:58,500 --> 01:12:01,566
在最初的 4 位元放入模式指示子

204
01:12:03,133 --> 01:12:05,300
接著決定版本

205
01:12:05,300 --> 01:12:07,899
可以指定特定的版本

206
01:12:07,899 --> 01:12:10,566
也可以從想包含的資料和錯誤修正等級

207
01:12:10,566 --> 01:12:13,033
剛好的版本也可以

208
01:12:13,466 --> 01:12:15,000
版本決定之後

209
01:12:15,233 --> 01:12:20,399
就根據版本的尺寸來建立 QR 碼的矩陣

210
01:12:20,600 --> 01:12:22,300
雖然沒有特別寫程式碼

211
01:12:22,300 --> 01:12:25,066
但我是用 Optional 的布林值

212
01:12:25,066 --> 01:12:27,433
二維陣列來表示的

213
01:12:28,100 --> 01:12:30,866
因為之後必須確認所有的儲存格

214
01:12:30,866 --> 01:12:32,399
是否都已經填滿

215
01:12:32,399 --> 01:12:34,866
所以一開始全部都放入 nil

216
01:12:36,266 --> 01:12:38,699
另外，為了讓資料部分的結尾

217
01:12:38,699 --> 01:12:41,133
正確地識別的話

218
01:12:41,133 --> 01:12:43,633
輸入資料的位元組數

219
01:12:44,800 --> 01:12:47,566
求出想要包含的資料位元組數

220
01:12:47,566 --> 01:12:50,899
將這個加到標頭 (header) 中

221
01:12:52,233 --> 01:12:55,033
這個要放入位元組數的位元數

222
01:12:55,033 --> 01:12:57,166
是由版本決定的

223
01:12:58,399 --> 01:13:00,433
版本 1 的二進位模式中

224
01:13:00,433 --> 01:13:05,366
這裡有 8 位元長度的區域可以放入

225
01:13:06,666 --> 01:13:09,100
從版本和錯誤修正等級

226
01:13:09,100 --> 01:13:12,800
可以取得資料部分能儲存的最大數量

227
01:13:13,899 --> 01:13:17,000
版本 1 且錯誤修正等級為 Q 時

228
01:13:17,366 --> 01:13:21,300
可儲存的容量是 13 位元組

229
01:13:21,399 --> 01:13:25,833
不過這是包含標頭資訊在內的容量

230
01:13:28,000 --> 01:13:33,066
標頭有 12 位元，資料碼字 (code word) 有 4 位元組

231
01:13:33,066 --> 01:13:35,066
總共可以放入 13 位元組

232
01:13:35,566 --> 01:13:38,366
這樣大概還剩下 60 位元左右

233
01:13:38,733 --> 01:13:40,366
我們得想辦法處理這些空間

234
01:13:40,800 --> 01:13:44,866
首先在編碼的最後加入終止模式 (terminator pattern)

235
01:13:45,433 --> 01:13:48,166
放入 4 個 0，也就是 4 位元

236
01:13:49,500 --> 01:13:51,533
這樣就能清楚知道資料到哪裡為止

237
01:13:51,533 --> 01:13:53,266
這樣就能清楚識別了

238
01:13:53,866 --> 01:13:59,800
然後用 0 調整到剛好 1 位元組 (byte) 的邊界

239
01:14:00,600 --> 01:14:04,266
這樣剛好剩下 8 個位元組的位元

240
01:14:04,266 --> 01:14:09,899
作為填充模式 (padding pattern)，交替填入十六進位的 EC 和十六進位的 11

241
01:14:09,899 --> 01:14:12,333
交替填入來填滿

242
01:14:13,666 --> 01:14:16,933
這樣資料部分就全部填滿了

243
01:14:18,466 --> 01:14:22,500
在資料部分交錯插入錯誤修正區塊 (error correction block)

244
01:14:22,500 --> 01:14:28,666
這裡直接套用在模擬 Frame QR 中說明的錯誤修正方法

245
01:14:30,566 --> 01:14:33,733
這樣訊息相關的部分就全部齊全了

246
01:14:34,733 --> 01:14:37,633
接下來要選擇遮罩模式 (Mask Pattern)

247
01:14:37,633 --> 01:14:41,633
遮罩圖樣是用來平衡黑白比例

248
01:14:41,633 --> 01:14:48,033
以及避免產生與有意義的排列相似的配置

249
01:14:48,766 --> 01:14:50,666
遮罩圖樣有 8 種

250
01:14:50,666 --> 01:14:53,399
會嘗試所有的遮罩

251
01:14:53,399 --> 01:14:57,433
然後選擇最合適的那一個

252
01:14:58,533 --> 01:15:02,766
要嘗試的話需要先建構矩陣

253
01:15:02,800 --> 01:15:05,466
所以遮罩選擇先暫停一下

254
01:15:05,466 --> 01:15:08,000
先來建構矩陣

255
01:15:09,766 --> 01:15:13,566
把一開始建立的空矩陣拿出來

256
01:15:13,566 --> 01:15:17,300
首先嵌入定位圖樣(Finder Pattern)和分隔符號(Separator)

257
01:15:18,433 --> 01:15:22,766
這是可以偵測位置和旋轉的東西

258
01:15:23,300 --> 01:15:27,000
如果有需要的話，就嵌入對齊圖案 (Alignment Pattern)

259
01:15:28,699 --> 01:15:31,500
版本 1 的話不會出現

260
01:15:31,500 --> 01:15:34,233
就是像這樣的東西

261
01:15:34,866 --> 01:15:39,033
每個版本都有規定要在哪裡放置對齊圖案

262
01:15:39,033 --> 01:15:40,266
所以

263
01:15:40,666 --> 01:15:44,000
在指定的位置嵌入 5×5 的圖案

264
01:15:44,399 --> 01:15:49,933
這是用來修正因扭曲而產生的儲存格位置偏移的東西

265
01:15:51,466 --> 01:15:54,366
接著嵌入時序圖案 (Timing Pattern)

266
01:15:55,066 --> 01:15:59,166
透過交替排列白色和黑色的儲存格

267
01:15:59,166 --> 01:16:03,433
傳達單元格的大小與整體單元格的大小

268
01:16:03,433 --> 01:16:05,133
來決定座標

269
01:16:06,733 --> 01:16:09,300
然後嵌入格式資訊

270
01:16:09,300 --> 01:16:13,866
格式資訊指的是錯誤修正等級與遮罩圖樣

271
01:16:13,866 --> 01:16:16,366
關於這個格式資訊

272
01:16:16,366 --> 01:16:20,800
使用固定的多項式十六進位 0x537

273
01:16:20,800 --> 01:16:23,833
採用稱為 BCH 碼的錯誤修正碼

274
01:16:23,833 --> 01:16:25,866
手法來處理

275
01:16:25,866 --> 01:16:28,033
雖然有很多細節

276
01:16:28,033 --> 01:16:30,933
透過這個方法可以得到 10 位元的錯誤修正碼

277
01:16:30,933 --> 01:16:32,100
得到這個結果

278
01:16:32,100 --> 01:16:34,266
所以把它們連接起來

279
01:16:35,233 --> 01:16:38,100
為了避免全部變成零

280
01:16:38,100 --> 01:16:41,133
使用特定的位元模式

281
01:16:41,133 --> 01:16:44,100
也就是十六進位的 5412

282
01:16:44,833 --> 01:16:47,199
進行互斥或 (XOR) 運算

283
01:16:47,199 --> 01:16:48,766
套用遮罩

284
01:16:50,333 --> 01:16:53,533
這樣就完成了 15 位元的格式資訊

285
01:16:53,533 --> 01:16:55,066
接著嵌入進去

286
01:16:55,766 --> 01:16:59,033
即使 QR 碼的一部分損壞

287
01:16:59,033 --> 01:17:01,566
為了能夠讀取，會放置在兩個地方

288
01:17:03,433 --> 01:17:07,133
首先一個是左上角的尋找圖案 (Finder Pattern) 處

289
01:17:07,133 --> 01:17:07,933
還有另一個

290
01:17:07,933 --> 01:17:12,233
分別放在左下和右上各一半

291
01:17:12,233 --> 01:17:14,966
這樣格式資訊就儲存完成了

292
01:17:15,699 --> 01:17:18,433
最後將加上錯誤修正碼的

293
01:17:18,433 --> 01:17:21,066
資料套用遮罩 (Mask)

294
01:17:21,066 --> 01:17:23,533
嵌入到這些空著的地方

295
01:17:23,533 --> 01:17:27,699
這樣就完成了所有儲存格都填滿的矩陣

296
01:17:27,699 --> 01:17:30,233
回到遮罩選擇的步驟

297
01:17:31,366 --> 01:17:36,533
剛才的矩陣要針對所有遮罩都製作一遍

298
01:17:37,466 --> 01:17:40,833
然後對每個矩陣進行評估

299
01:17:41,600 --> 01:17:45,033
將這四個懲罰值加總起來

300
01:17:45,300 --> 01:17:49,666
選出懲罰值最低的作為最佳遮罩

301
01:17:50,300 --> 01:17:56,166
用選定的遮罩重新建構矩陣

302
01:17:56,166 --> 01:18:01,466
就能完成 QR 碼的基礎矩陣了

303
01:18:02,833 --> 01:18:07,366
我是用布林值的二維陣列來製作這個矩陣

304
01:18:07,366 --> 01:18:11,699
但要怎麼把它轉換成圖片是我現在的煩惱

305
01:18:11,699 --> 01:18:13,466
如果有什麼想法的話

306
01:18:13,466 --> 01:18:15,933
請在 Ask the Speaker 告訴我

307
01:18:17,266 --> 01:18:19,433
最後請務必掃描看看

308
01:18:19,433 --> 01:18:21,533
這個 QR 碼

309
01:18:30,433 --> 01:18:32,899
11 月 2 日

310
01:18:32,899 --> 01:18:36,566
在鎌倉會舉辦 Swift 社群活動

311
01:18:36,566 --> 01:18:38,100
請務必來玩

312
01:18:38,100 --> 01:18:40,666
謝謝大家

313
01:18:47,266 --> 01:18:48,866
謝謝

314
01:18:49,233 --> 01:18:50,933
那麼接下來進入 Q&A 時間

315
01:18:50,933 --> 01:18:53,333
如果有任何意見或問題的話

316
01:18:53,333 --> 01:18:54,466
請舉手讓我們知道

