1
00:00:09,266 --> 00:00:13,266
QR 碼的規格有 N 種類型

2
00:00:13,266 --> 00:00:15,766
N 是多少，大家知道嗎？

3
00:00:15,766 --> 00:00:19,833
請務必在 #iosdc #d 標籤發推文喔

4
00:00:19,833 --> 00:00:20,433
好的

5
00:00:20,433 --> 00:00:21,300
我是 Ryomm

6
00:00:21,300 --> 00:00:22,766
請多多指教

7
00:00:22,766 --> 00:00:25,166
我是一名 iOS 應用程式工程師

8
00:00:25,166 --> 00:00:32,466
工作上，主要開發處理電車和巴士等交通票券的 MaaS 應用程式

9
00:00:33,233 --> 00:00:36,200
好，想要生成 QR 碼

10
00:00:37,299 --> 00:00:39,066
QR 碼的生成的時候

11
00:00:39,066 --> 00:00:43,933
需要使用 CIFilter 的 CIQRCodeGenerator

12
00:00:44,733 --> 00:00:48,233
inputMessage 可以指定要包含在 QR 碼中的資料

13
00:00:48,233 --> 00:00:52,766
inputCorrectionLevel 可以指定錯誤修正等級

14
00:00:53,133 --> 00:00:55,100
所謂錯誤修正等級

15
00:00:55,100 --> 00:00:58,200
就是指即使有一定程度的髒汙或遮蔽

16
00:00:58,200 --> 00:01:01,466
仍然能夠讀取的等級

17
00:01:01,466 --> 00:01:03,633
稍微調整一下大小

18
00:01:04,266 --> 00:01:06,533
QR 碼就成功生成了

19
00:01:06,533 --> 00:01:08,266
真是可喜可賀

20
00:01:09,233 --> 00:01:11,433
如果是這樣就好了

21
00:01:12,266 --> 00:01:17,433
最近在 MaaS 領域，QR 票券正大為流行

22
00:01:17,433 --> 00:01:20,799
即使沒有像自動閘門那樣的大型設備

23
00:01:20,799 --> 00:01:23,400
也能輕鬆導入

24
00:01:24,000 --> 00:01:26,066
不過這種 QR 票券

25
00:01:26,066 --> 00:01:28,766
根據讀取 QR 碼的終端裝置

26
00:01:28,766 --> 00:01:32,366
有時 QR 的規格會被嚴格規定

27
00:01:32,366 --> 00:01:33,566
如果不符合規格

28
00:01:33,566 --> 00:01:36,533
就可能發生無法讀取的情況

29
00:01:37,599 --> 00:01:42,200
其中之一就是被稱為版本 (Version) 的規格

30
00:01:43,333 --> 00:01:47,866
QR 碼最小的方格稱為儲存格（Cell）

31
00:01:47,866 --> 00:01:53,233
這個儲存格縱橫各有幾個的定義就用版本來表示

32
00:01:53,233 --> 00:01:58,233
根據版本不同，QR 碼能包含的資料量也會改變

33
00:01:59,366 --> 00:02:01,966
版本從 1 到 40

34
00:02:01,966 --> 00:02:05,566
版本越大，儲存格的數量也會增加

35
00:02:05,566 --> 00:02:10,266
也就是說，QR 碼能包含的資料量就會變大

36
00:02:10,633 --> 00:02:14,833
根據模式和錯誤修正等級的不同，也會有相當大的差異

37
00:02:14,833 --> 00:02:19,000
例如在錯誤修正等級 M、包含二進位資料的情況下

38
00:02:19,000 --> 00:02:21,599
版本 1 只能放 14 位元組

39
00:02:21,599 --> 00:02:24,699
版本 5 可以放 84 位元組

40
00:02:24,699 --> 00:02:27,633
版本 10 可以容納 213 位元組

41
00:02:27,633 --> 00:02:33,366
最大的版本 40 則可以容納高達 2,331 位元組的資料

42
00:02:33,966 --> 00:02:36,666
根據 QR 碼的讀取裝置不同

43
00:02:36,666 --> 00:02:41,066
有時候只能讀取指定版本的 QR 碼

44
00:02:42,666 --> 00:02:49,033
那麼，讓我們回到一開始使用 CIFilter 生成 QR 碼的部分

45
00:02:49,033 --> 00:02:50,800
各位有注意到嗎？

46
00:02:52,166 --> 00:02:57,666
這裡只能指定要包含的資料和錯誤修正等級而已！？

47
00:02:58,433 --> 00:03:01,866
要怎麼指定特定的 QR 碼版本呢？

48
00:03:02,599 --> 00:03:06,533
無論怎麼查都找不到指定版本的方法啊！

49
00:03:06,533 --> 00:03:10,000
會擅自用各種版本生成

50
00:03:11,666 --> 00:03:14,966
會擅自用各種版本生成？！

51
00:03:15,699 --> 00:03:20,199
這不就是根據 QR 碼要包含的資料位元組量

52
00:03:20,199 --> 00:03:23,766
自動最佳化的意思嗎？

53
00:03:23,766 --> 00:03:25,533
終於沒注意到這件事

54
00:03:25,533 --> 00:03:27,266
終於注意到這件事

55
00:03:28,033 --> 00:03:30,000
也就是說這樣不就行了：

56
00:03:31,800 --> 00:03:33,766
配合版本的最大值

57
00:03:33,766 --> 00:03:36,966
在開頭用零填充來調整長度

58
00:03:36,966 --> 00:03:39,266
在不改變儲存資料的情況下

59
00:03:39,266 --> 00:03:42,966
目標版本的 QR 碼圖像就能輸出了

60
00:03:44,233 --> 00:03:46,500
這樣一來，即使是相同的二進位資料

61
00:03:46,500 --> 00:03:49,800
也能生成目標版本的 QR 碼了

62
00:03:50,333 --> 00:03:53,000
拍拍手

63
00:03:54,066 --> 00:03:55,500
謝謝大家

64
00:03:56,133 --> 00:03:57,433
這樣一來只要努力的話

65
00:03:57,433 --> 00:04:01,333
感覺還能製作出各式各樣的 QR 碼呢

66
00:04:02,166 --> 00:04:05,000
各位知道 Frame QR  (フレームQR) 嗎

67
00:04:05,500 --> 00:04:11,066
這個 Frame QR  是可以把 QR 碼本身作為畫布自由使用的一個服務

68
00:04:11,566 --> 00:04:18,000
不過這個如果個人要認真製作的話其實相當困難

69
00:04:18,000 --> 00:04:22,733
但是可以利用錯誤修正來模仿重現

70
00:04:23,466 --> 00:04:28,399
在剛才的說明中，有稍微帶過錯誤修正等級這個詞

71
00:04:28,399 --> 00:04:32,833
大家可能只是聽到名，就只會覺得「應該就是修正錯誤吧」這種感覺

72
00:04:32,833 --> 00:04:34,800
所以我想好好說明一下

73
00:04:35,133 --> 00:04:38,866
QR 碼的錯誤修正等級有 4 種

74
00:04:38,866 --> 00:04:40,699
各自的復原率是

75
00:04:40,699 --> 00:04:43,100
L 是 7%

76
00:04:43,100 --> 00:04:44,666
M 是 15%

77
00:04:44,666 --> 00:04:46,366
Q 是 25%

78
00:04:46,366 --> 00:04:48,166
H 是 30%

79
00:04:49,966 --> 00:04:52,366
把 QR 碼拉長攤開來看

80
00:04:52,366 --> 00:04:56,199
扣除標頭 (Header) 和填充 (Padding) 之後，資料就放在這裡

81
00:04:56,533 --> 00:05:01,733
構成資料的最小單位稱為碼字 (Codeword)

82
00:05:02,433 --> 00:05:06,399
在 QR 碼中，1 個碼字是 8 位元

83
00:05:07,899 --> 00:05:10,633
假設有 10 個資料碼字

84
00:05:10,800 --> 00:05:14,666
我們想要能夠修正其中一半的錯誤

85
00:05:15,300 --> 00:05:19,966
要修正 1 個碼字，所需的錯誤修正碼字數量

86
00:05:19,966 --> 00:05:22,533
是它的 2 倍

87
00:05:22,933 --> 00:05:26,433
所以錯誤修正碼字數量就是 10 個

88
00:05:27,300 --> 00:05:31,800
因此全部程式碼字 20 個中有 5 個可以修正

89
00:05:32,266 --> 00:05:39,899
修正率是 5 除以 20 等於 25%，這相當於等級 Q

90
00:05:41,399 --> 00:05:45,833
另外當版本變大、資料數量增加時

91
00:05:45,833 --> 00:05:49,266
如果將整體作為一個區塊進行錯誤修正

92
00:05:49,733 --> 00:05:52,233
會發生偏差變得嚴重

93
00:05:52,233 --> 00:05:56,533
或是錯誤變得難以修正等現象

94
00:05:56,533 --> 00:05:59,633
因此 Reed Solomon 區塊就登場了

95
00:06:00,366 --> 00:06:06,333
首先將資料程式碼字分割成多個區塊

96
00:06:06,833 --> 00:06:12,266
對分割後的每個資料程式碼字進行錯誤修正

97
00:06:13,100 --> 00:06:15,699
這個分割後的資料程式碼字與

98
00:06:15,699 --> 00:06:20,366
錯誤更正碼字的集合稱為 Reed Solomon (RS) 區塊

99
00:06:21,199 --> 00:06:23,233
在這種情況下，修正率是

100
00:06:23,233 --> 00:06:27,600
針對 RS 區塊內的碼字而言

101
00:06:29,566 --> 00:06:32,399
所以版本 1 大概就是這種感覺

102
00:06:33,199 --> 00:06:37,166
不過這個更正率是理論上的最低保證值

103
00:06:37,166 --> 00:06:40,133
實際上就算再破損一點也能讀取

104
00:06:40,133 --> 00:06:45,500
而且根據破損的方式，或是讀取裝置稍微拼一點

105
00:06:45,500 --> 00:06:48,000
也取決於讀取端的性能

106
00:06:48,566 --> 00:06:53,233
在製作模仿 Frame QR 的情況下

107
00:06:53,233 --> 00:06:56,199
用圖像刻意破壞的數值

108
00:06:56,199 --> 00:06:59,366
盡可能依照理論值會比較好

109
00:07:00,699 --> 00:07:03,533
那麼，既然已經知道圖片的大小

110
00:07:03,533 --> 00:07:06,566
我們就來生成 QR 碼並進行合成吧

111
00:07:06,800 --> 00:07:09,866
首先，先正常地製作 QR 碼

112
00:07:10,533 --> 00:07:14,699
合成時會使用 UIGraphicsImageRenderer

113
00:07:15,166 --> 00:07:19,066
使用 CIFilter 生成的 QR 碼

114
00:07:19,466 --> 00:07:22,066
會有這種稱為靜區 (Quiet Zone) 的

115
00:07:22,066 --> 00:07:25,833
環繞周圍的留白

116
00:07:26,766 --> 00:07:28,733
在 QR 碼的定義上

117
00:07:28,733 --> 00:07:30,399
QR 碼的靜區

118
00:07:30,399 --> 00:07:33,066
4 個儲存格的留白圍繞在周圍

119
00:07:33,066 --> 00:07:34,733
是這樣定義的

120
00:07:34,966 --> 00:07:38,133
但是用 CIFilter 生成的 QR 碼

121
00:07:38,133 --> 00:07:40,899
只有 1 個儲存格的留白

122
00:07:40,899 --> 00:07:43,800
所以左右合計會變大 2 個儲存格

123
00:07:43,800 --> 00:07:46,233
以這個狀態來計算圖片大小

124
00:07:46,966 --> 00:07:49,399
調整位置並合成

125
00:07:50,300 --> 00:07:52,699
框架 QR 碼完成了

126
00:07:52,699 --> 00:07:54,766
掌聲鼓勵

127
00:07:56,399 --> 00:07:57,666
謝謝大家

128
00:07:57,666 --> 00:08:00,266
特別不考慮直接放置圖片的情況下

129
00:08:00,266 --> 00:08:04,233
錯誤修正等級盡可能設定高一點的話

130
00:08:04,233 --> 00:08:06,733
復原的可能性也會提高

131
00:08:06,733 --> 00:08:08,333
所以這樣做比較好

132
00:08:08,866 --> 00:08:12,100
本來想說話題就到這裡結束

133
00:08:12,100 --> 00:08:14,500
但才過了 10 分鐘左右

134
00:08:14,500 --> 00:08:16,600
比預期還要早結束了

135
00:08:16,600 --> 00:08:20,000
所以接下來要講的是原本想放進來的內容

136
00:08:20,000 --> 00:08:21,399
但來不及完成驗證

137
00:08:21,399 --> 00:08:23,933
來説説還正在進行中的嘗試

138
00:08:25,266 --> 00:08:26,366
剛才那樣

139
00:08:26,366 --> 00:08:28,566
我想說既然能做出模擬 Frame QR

140
00:08:28,566 --> 00:08:30,600
就變得超級得意忘形

141
00:08:30,600 --> 00:08:34,000
開始覺得應該能做出更特殊的 QR 碼

142
00:08:34,000 --> 00:08:36,333
就更加得意忘形了

143
00:08:37,866 --> 00:08:42,700
於是開始想說能不能做出分割 QR 碼之類的

144
00:08:43,500 --> 00:08:49,133
QR 碼無法容納版本 40 容量以上的資料

145
00:08:50,299 --> 00:08:53,600
但是可以透過分割來突破上限

146
00:08:53,600 --> 00:08:58,966
可能有人在藥物手冊的 QR 碼等地方看過

147
00:09:00,433 --> 00:09:03,399
之前把 QR 碼拉長的時候

148
00:09:03,399 --> 00:09:05,833
有稍微提到標頭 (Header)

149
00:09:05,833 --> 00:09:07,433
一般的 QR 碼

150
00:09:07,433 --> 00:09:12,299
標頭只有 4 位元，裡面放了模式指示子而已

151
00:09:12,299 --> 00:09:14,333
其實沒有放太多資料

152
00:09:15,100 --> 00:09:17,666
分割 QR 碼的情況

153
00:09:18,266 --> 00:09:22,633
在標頭開頭的 4 位元放入 3 的話

154
00:09:22,633 --> 00:09:27,433
就會被判斷為分割 QR 碼

155
00:09:28,533 --> 00:09:35,399
然後接下來的 4 位元放入分割後的 QR 碼是第幾個的頁碼

156
00:09:35,399 --> 00:09:42,166
再接下來的 4 位元則儲存最大的頁數

157
00:09:42,566 --> 00:09:44,700
最大的頁數是 4 位元

158
00:09:44,700 --> 00:09:48,733
也就是說最多可以分割成 16 個

159
00:09:49,333 --> 00:09:52,466
接下來的 4 位元是同位元 (Parity) 的高位

160
00:09:52,466 --> 00:09:53,333
4 位元

161
00:09:53,333 --> 00:09:57,033
再接下來則是放入同位元的低 4 位元

162
00:09:57,033 --> 00:09:58,966
這個同位元

163
00:09:58,966 --> 00:10:02,366
是所有要連結的 QR 碼共通的東西

164
00:10:02,366 --> 00:10:07,133
會針對全部的資料計算同位元來使用

165
00:10:07,133 --> 00:10:10,966
所以在連結 QR 的讀取端

166
00:10:10,966 --> 00:10:14,266
會被當作連結用 ID 來處理

167
00:10:15,633 --> 00:10:20,333
其他部分幾乎都跟普通的 QR 碼一樣製作

168
00:10:21,100 --> 00:10:25,700
光聽這些，是不是覺得好像也不是做不到？

169
00:10:27,266 --> 00:10:30,566
但是用 CIQRCodeGenerator

170
00:10:30,566 --> 00:10:32,899
能不能修改標頭資訊呢？

171
00:10:32,899 --> 00:10:33,766
嗯⋯⋯

172
00:10:34,833 --> 00:10:36,100
做不到

173
00:10:36,533 --> 00:10:37,933
太得意忘形了

174
00:10:37,933 --> 00:10:39,033
真是令人難過

175
00:10:40,566 --> 00:10:42,533
所以我打算手工製作

176
00:10:42,933 --> 00:10:45,033
因為只是要修改標頭資訊

177
00:10:45,033 --> 00:10:47,766
總之只要能做出普通的 QR 碼

178
00:10:47,766 --> 00:10:49,500
應該就能做到了

179
00:10:49,933 --> 00:10:56,566
有一個叫做 Zebra Crossing 的， Java 製 QR 碼生成開源函式庫

180
00:10:56,866 --> 00:11:00,200
目前它已經進入維護模式

181
00:11:00,200 --> 00:11:04,133
所以有人用 C++ 重新改寫

182
00:11:04,133 --> 00:11:09,100
並進行了各種改善，叫做 Zebra Crossing C++ 的函式庫

183
00:11:09,100 --> 00:11:10,399
我會以這個為基礎來參考

184
00:11:11,033 --> 00:11:15,066
話雖如此，我覺得我看不懂 C++

185
00:11:15,066 --> 00:11:18,266
所以目前正在嘗試用 Swift 改寫

186
00:11:18,633 --> 00:11:21,933
如果要全部解說的話，這次時間會不夠用

187
00:11:21,933 --> 00:11:24,533
所以我會說明到相當程度為止

188
00:11:25,500 --> 00:11:27,899
QR 碼有四種模式

189
00:11:27,899 --> 00:11:29,600
由模式指示子來指定

190
00:11:29,933 --> 00:11:33,100
其中如果使用這個 8 位元模式的話

191
00:11:33,100 --> 00:11:35,566
就可以儲存二進位資料

192
00:11:36,033 --> 00:11:38,100
能夠放入二進位資料的意思是

193
00:11:38,166 --> 00:11:40,366
除了日文以外，任何字串

194
00:11:40,366 --> 00:11:42,000
都可以放進去

195
00:11:43,000 --> 00:11:45,433
這次我決定一律使用二進位模式

196
00:11:45,433 --> 00:11:46,533
使用することにします

197
00:11:47,033 --> 00:11:49,033
這個二進位模式 (Binary Mode) 的話

198
00:11:49,033 --> 00:11:53,799
QR 碼生成端就不用費力進行各種轉換

199
00:11:53,799 --> 00:11:56,899
可以直接放入二進位資料

200
00:11:56,899 --> 00:12:00,666
對生成端來說是個可以偷懶的便利模式

201
00:12:01,433 --> 00:12:04,133
模式決定好了，所以作為標頭資訊

202
00:12:04,133 --> 00:12:07,700
在最初的 4 位元放入模式指示子

203
00:12:08,766 --> 00:12:10,933
接著決定版本

204
00:12:10,933 --> 00:12:13,533
可以指定特定的版本

205
00:12:13,533 --> 00:12:16,200
也可以從想包含的資料和錯誤修正等級

206
00:12:16,200 --> 00:12:18,766
剛好的版本也可以

207
00:12:19,100 --> 00:12:20,633
版本決定之後

208
00:12:20,866 --> 00:12:26,033
就根據版本的尺寸來建立 QR 碼的矩陣

209
00:12:26,233 --> 00:12:27,933
雖然沒有特別寫程式碼

210
00:12:27,933 --> 00:12:30,700
但我是用 Optional 的布林值

211
00:12:30,700 --> 00:12:33,066
二維陣列來表示的

212
00:12:33,733 --> 00:12:36,500
因為之後必須確認所有的儲存格

213
00:12:36,500 --> 00:12:38,033
是否都已經填滿

214
00:12:38,033 --> 00:12:40,500
所以一開始全部都放入 nil

215
00:12:41,899 --> 00:12:44,333
另外，為了讓資料部分的結尾

216
00:12:44,333 --> 00:12:46,766
正確地識別的話

217
00:12:46,766 --> 00:12:49,266
輸入資料的位元組數

218
00:12:50,433 --> 00:12:53,200
求出想要包含的資料位元組數

219
00:12:53,200 --> 00:12:56,533
將這個加到標頭 (header) 中

220
00:12:57,866 --> 00:13:00,666
這個要放入位元組數的位元數

221
00:13:00,666 --> 00:13:02,799
是由版本決定的

222
00:13:04,033 --> 00:13:06,066
版本 1 的二進位模式中

223
00:13:06,066 --> 00:13:11,333
這裡有 8 位元長度的區域可以放入

224
00:13:12,299 --> 00:13:14,733
從版本和錯誤修正等級

225
00:13:14,733 --> 00:13:18,833
可以取得資料部分能儲存的最大數量

226
00:13:19,533 --> 00:13:22,633
版本 1 且錯誤修正等級為 Q 時

227
00:13:23,000 --> 00:13:26,933
可儲存的容量是 13 位元組

228
00:13:27,033 --> 00:13:31,466
不過這是包含標頭資訊在內的容量

229
00:13:33,633 --> 00:13:38,700
標頭有 12 位元,資料碼字 (code word) 有 4 位元組

230
00:13:38,700 --> 00:13:40,700
總共可以放入 13 位元組

231
00:13:41,200 --> 00:13:44,000
這樣大概還剩下 60 位元左右

232
00:13:44,366 --> 00:13:46,000
我們得想辦法處理這些空間

233
00:13:46,433 --> 00:13:50,500
首先在編碼的最後加入終止模式 (terminator pattern)

234
00:13:51,066 --> 00:13:53,799
放入 4 個 0 ，也就是 4 位元

235
00:13:55,133 --> 00:13:57,166
這樣就能清楚知道資料到哪裡為止

236
00:13:57,166 --> 00:13:58,899
這樣就能清楚識別了

237
00:13:59,500 --> 00:14:05,433
然後用 0 調整到剛好 1 位元組 (byte) 的邊界

238
00:14:06,233 --> 00:14:10,066
這樣剛好剩下 8 個位元組的位元

239
00:14:10,066 --> 00:14:15,533
作為填充模式 (padding pattern)，交替填入十六進位的 EC 和十六進位的 11

240
00:14:15,533 --> 00:14:18,466
交替填入來填滿

241
00:14:19,299 --> 00:14:22,566
這樣資料部分就全部填滿了

242
00:14:24,100 --> 00:14:28,433
在資料部分交錯插入錯誤修正區塊 (error correction block)

243
00:14:28,433 --> 00:14:34,299
這裡直接套用在模擬 Frame QR 中說明的錯誤修正方法

244
00:14:36,200 --> 00:14:39,366
這樣訊息相關的部分就全部齊全了

245
00:14:40,366 --> 00:14:43,266
接下來要選擇遮罩模式 (Mask Pattern)

246
00:14:43,266 --> 00:14:47,266
遮罩圖樣是用來平衡黑白比例

247
00:14:47,266 --> 00:14:53,666
以及避免產生與有意義的排列相似的配置

248
00:14:54,399 --> 00:14:56,299
遮罩圖樣有 8 種

249
00:14:56,299 --> 00:14:59,033
會嘗試所有的遮罩

250
00:14:59,033 --> 00:15:03,066
然後選擇最合適的那一個

251
00:15:04,166 --> 00:15:08,399
要嘗試的話需要先建構矩陣

252
00:15:08,433 --> 00:15:11,100
所以遮罩選擇先暫停放一邊

253
00:15:11,100 --> 00:15:13,633
先來建構矩陣

254
00:15:15,399 --> 00:15:19,200
把一開始建立的空矩陣拿出來

255
00:15:19,200 --> 00:15:22,933
首先嵌入定位圖樣(Finder Pattern)和分隔符號(Separator)

256
00:15:24,066 --> 00:15:28,399
這是可以偵測位置和旋轉的東西

257
00:15:28,933 --> 00:15:32,633
如果有需要的話，就嵌入對齊圖案 (Alignment Pattern)

258
00:15:34,333 --> 00:15:37,133
版本 1 的話不會出現

259
00:15:37,133 --> 00:15:39,866
就是像這樣的東西

260
00:15:40,500 --> 00:15:44,666
每個版本都有規定要在哪裡放置對齊圖案

261
00:15:44,666 --> 00:15:45,899
所以

262
00:15:46,299 --> 00:15:49,633
在指定的位置嵌入 5×5 的圖案

263
00:15:50,033 --> 00:15:55,566
這是用來修正因扭曲而產生的儲存格位置偏移的東西

264
00:15:57,100 --> 00:16:00,000
接著嵌入時序圖案 (Timing Pattern)

265
00:16:00,700 --> 00:16:04,799
透過交替排列白色和黑色的儲存格

266
00:16:04,799 --> 00:16:09,066
傳達單元格的大小與整體單元格的大小

267
00:16:09,066 --> 00:16:10,766
來決定座標

268
00:16:12,366 --> 00:16:14,933
然後嵌入格式資訊

269
00:16:14,933 --> 00:16:19,500
格式資訊指的是錯誤修正等級與遮罩圖樣

270
00:16:19,500 --> 00:16:22,000
關於這個格式資訊

271
00:16:22,000 --> 00:16:25,933
使用固定的多項式十六進位 0x537

272
00:16:25,933 --> 00:16:29,466
採用稱為 BCH 碼的錯誤修正碼

273
00:16:29,466 --> 00:16:31,500
手法來處理

274
00:16:32,566 --> 00:16:33,666
雖然有很多細節

275
00:16:33,666 --> 00:16:36,566
透過這個方法可以得到 10 位元的錯誤修正碼

276
00:16:36,566 --> 00:16:37,733
得到這個結果

277
00:16:37,733 --> 00:16:39,899
所以把它們連接起來

278
00:16:40,733 --> 00:16:43,600
為了避免全部變成零

279
00:16:43,600 --> 00:16:46,633
使用特定的位元模式

280
00:16:46,633 --> 00:16:49,600
也就是十六進位的 5412

281
00:16:50,466 --> 00:16:54,399
進行互斥或 (XOR) 運算套用遮罩

282
00:16:55,533 --> 00:16:58,733
這樣就完成了 15 位元的格式資訊

283
00:16:58,733 --> 00:17:00,266
接著嵌入進去

284
00:17:00,966 --> 00:17:04,233
即使 QR 碼的一部分損壞

285
00:17:04,233 --> 00:17:06,766
為了能夠讀取，會放置在兩個地方

286
00:17:08,633 --> 00:17:12,333
首先一個是左上角的尋找圖案 (Finder Pattern) 處

287
00:17:12,333 --> 00:17:13,133
還有另一個

288
00:17:13,133 --> 00:17:17,433
分別放在左下和右上各一半

289
00:17:17,433 --> 00:17:20,166
這樣格式資訊就儲存完成了

290
00:17:21,366 --> 00:17:24,099
最後將加上錯誤修正碼的

291
00:17:24,099 --> 00:17:26,733
資料套用遮罩 (Mask)

292
00:17:26,733 --> 00:17:29,833
嵌入到這些空著的地方

293
00:17:29,833 --> 00:17:33,366
這樣就完成了所有儲存格都填滿的矩陣

294
00:17:33,366 --> 00:17:35,900
回到遮罩選擇的步驟

295
00:17:36,566 --> 00:17:42,333
剛才的矩陣要針對所有遮罩都製作一遍

296
00:17:42,666 --> 00:17:46,033
然後對每個矩陣進行評估

297
00:17:46,799 --> 00:17:50,233
將這四個懲罰值加總起來

298
00:17:50,500 --> 00:17:55,400
選出懲罰值最低的作為最佳遮罩

299
00:17:55,400 --> 00:18:02,200
用選定的遮罩重新建構矩陣

300
00:18:02,200 --> 00:18:07,233
就能完成 QR 碼的基礎矩陣了

301
00:18:08,466 --> 00:18:13,000
我是用布林值的二維陣列來製作這個矩陣

302
00:18:13,000 --> 00:18:17,333
但要怎麼把它轉換成圖片是我現在的煩惱

303
00:18:17,333 --> 00:18:19,099
如果有什麼想法的話

304
00:18:19,099 --> 00:18:21,566
請在 Ask the Speaker 告訴我

305
00:18:22,900 --> 00:18:25,066
最後請務必掃描看看

306
00:18:25,066 --> 00:18:27,166
這個 QR 碼

307
00:18:36,933 --> 00:18:38,466
11 月 2 日

308
00:18:38,466 --> 00:18:41,700
在鎌倉會舉辦 Swift 社群的活動

309
00:18:41,700 --> 00:18:43,666
請務必來玩玩

310
00:18:43,666 --> 00:18:46,500
好，謝謝大家！

311
00:18:52,466 --> 00:18:54,233
(主持) 謝謝您的發表

312
00:18:54,233 --> 00:18:56,066
那麼接下來進入 Q&A 時間

313
00:18:56,066 --> 00:18:58,333
如果有任何意見或問題的話

314
00:18:58,333 --> 00:18:59,866
請舉手讓我們知道

315
00:19:04,233 --> 00:19:06,599
沒有嗎？

316
00:19:09,266 --> 00:19:12,266
那我們來結束 Q&A 時間

317
00:19:12,266 --> 00:19:16,033
接下來是一分鐘的回饋時間

