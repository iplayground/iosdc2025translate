1
00:00:09,266 --> 00:00:13,266
QRコードの仕様ってn種類あんねん

2
00:00:13,266 --> 00:00:15,766
Nは何か分かりますか

3
00:00:15,766 --> 00:00:19,833
ぜひiOSDC #Dでツイートしてくださいね

4
00:00:19,833 --> 00:00:20,433
はい

5
00:00:20,433 --> 00:00:21,300
りょむです

6
00:00:21,300 --> 00:00:22,766
よろしくお願いします

7
00:00:22,766 --> 00:00:25,166
iOSアプリエンジニアをしていて

8
00:00:25,166 --> 00:00:30,033
仕事では電車とかバスの交通チケットを主に取り扱うような

9
00:00:30,033 --> 00:00:32,466
MaaS アプリを開発しています

10
00:00:33,233 --> 00:00:36,200
さて、QRコードを生成したい

11
00:00:37,299 --> 00:00:39,066
QRコードの生成には

12
00:00:39,066 --> 00:00:43,933
CIFilter の CIQRCodeGenerator を使います

13
00:00:44,733 --> 00:00:48,233
inputMessageにQRコードに含めるデータ

14
00:00:48,233 --> 00:00:52,766
inputCorrectionLevelに誤り訂正レベルが指定できます

15
00:00:53,133 --> 00:00:55,100
誤り訂正レベルというのは

16
00:00:55,100 --> 00:00:58,200
どの程度汚れたり隠れたりしても

17
00:00:58,200 --> 00:01:01,466
読み取れるようにするのかというレベルです

18
00:01:01,466 --> 00:01:03,633
大きさなんかをちょっと整えて

19
00:01:04,266 --> 00:01:06,533
QRコードが生成できました

20
00:01:06,533 --> 00:01:08,266
いやめでたしめでたし

21
00:01:09,233 --> 00:01:11,433
それだとよかったですね

22
00:01:12,266 --> 00:01:17,433
最近の MaaS 界隈ではQRチケットが今大流行中です

23
00:01:17,433 --> 00:01:20,799
改札機のような大掛かりな設備がなくても

24
00:01:20,799 --> 00:01:23,400
簡単に導入することができます

25
00:01:24,000 --> 00:01:26,066
ただこのQRチケット

26
00:01:26,066 --> 00:01:28,766
QRコードを読み込む端末によっては

27
00:01:28,766 --> 00:01:32,366
QRの仕様が厳密に定められているときがあって

28
00:01:32,366 --> 00:01:33,566
仕様が満たせないと

29
00:01:33,566 --> 00:01:36,533
読み込んでもらえないということが起こり得ます

30
00:01:37,599 --> 00:01:42,200
そのうちの一つにバージョンと呼ばれる仕様があります

31
00:01:43,333 --> 00:01:47,866
QRコードの最小のマス目をセルと呼ぶんですけれども

32
00:01:47,866 --> 00:01:53,233
このセルが縦横に何個あるかという定義がバージョンで表されています

33
00:01:53,233 --> 00:01:58,233
バージョンによってはQRコードに含められるデータ量が変わります

34
00:01:59,366 --> 00:02:01,966
バージョンは1から40まであり

35
00:02:01,966 --> 00:02:05,566
バージョンが大きくなるとその分セルの数も増えるので

36
00:02:05,566 --> 00:02:10,266
つまりそのままQRコードに含められるデータ量が大きくなります

37
00:02:10,633 --> 00:02:14,833
モードや誤り訂正レベルによっても結構変わるんですけれども

38
00:02:14,833 --> 00:02:19,000
例えば誤り訂正レベルMでバイナリーを含める場合

39
00:02:19,000 --> 00:02:21,599
バージョン1だと14バイトだけ

40
00:02:21,599 --> 00:02:24,699
バージョン5だと84バイト

41
00:02:24,699 --> 00:02:27,633
バージョン10では213バイト

42
00:02:27,633 --> 00:02:31,599
最大のバージョン40では2331バイトまで

43
00:02:31,599 --> 00:02:33,366
含めることができます

44
00:02:33,966 --> 00:02:36,666
QRコードの読み取り端末によっては

45
00:02:36,666 --> 00:02:41,066
指定のQRコードバージョンしか読み取れないということもあるのです

46
00:02:42,666 --> 00:02:49,033
さて冒頭のCIFilterを使ったQRコード生成に戻ってみると

47
00:02:49,033 --> 00:02:50,800
皆様お気づきでしょうか

48
00:02:52,166 --> 00:02:57,666
これ含めるデータと誤り訂正レベルしか指定できなくね

49
00:02:58,433 --> 00:03:01,866
どうやって特定のQRコードバージョンにしたらいいんだ

50
00:03:02,599 --> 00:03:06,533
どう調べてもバージョンの指定方法なんてないぞ

51
00:03:06,533 --> 00:03:10,000
勝手にいろんなバージョンで生成されるし

52
00:03:11,666 --> 00:03:14,966
勝手にいろんなバージョンで生成されている

53
00:03:15,699 --> 00:03:20,199
これってQRコードに含めるデータのバイト量に応じて

54
00:03:20,199 --> 00:03:23,766
最適化してくれてるってことじゃねって

55
00:03:23,766 --> 00:03:25,533
気づきませんでした

56
00:03:25,533 --> 00:03:27,266
気づきました

57
00:03:28,033 --> 00:03:30,000
つまりこうじゃね

58
00:03:31,800 --> 00:03:33,766
バージョンの最大値に合わせて

59
00:03:33,766 --> 00:03:36,966
頭をゼロで埋めて長さ調整することで

60
00:03:36,966 --> 00:03:39,266
格納するデータは変えずに

61
00:03:39,266 --> 00:03:42,966
狙ったバージョンのQRコード画像を出力できる

62
00:03:44,233 --> 00:03:46,500
こうすることで同じバイナリでも

63
00:03:46,500 --> 00:03:49,800
狙ったバージョンのQRコードを生成することができました

64
00:03:50,333 --> 00:03:53,000
拍手

65
00:03:54,066 --> 00:03:55,500
ありがとうございます

66
00:03:56,133 --> 00:03:57,433
こうなると頑張れば

67
00:03:57,433 --> 00:04:01,333
他にもいろんなQRコード作れそうな気がしてきましたよね

68
00:04:02,166 --> 00:04:05,000
皆様フレームQRご存知でしょうか

69
00:04:05,500 --> 00:04:06,966
このフレームQRとは

70
00:04:06,966 --> 00:04:11,066
コード内に自由に使えるキャンバス領域を持ったQRコードです

71
00:04:11,566 --> 00:04:18,000
ただこちら個人でちゃんと作ろうとすると結構大変なんですけれども

72
00:04:18,000 --> 00:04:22,733
誤り訂正を利用して擬似的に再現することができます

73
00:04:23,466 --> 00:04:28,399
これまでの話で誤り訂正レベルとかさらっと出てきたんですけれども

74
00:04:28,399 --> 00:04:32,833
名前だけ聞いて、誤り訂正するんじゃねって感じだと思うので

75
00:04:32,833 --> 00:04:34,800
ちゃんと説明しようと思います

76
00:04:35,133 --> 00:04:38,866
QRコードの誤り訂正レベルは4種類あって

77
00:04:38,866 --> 00:04:40,699
それぞれの復元率は

78
00:04:40,699 --> 00:04:43,100
Lが7%

79
00:04:43,100 --> 00:04:44,666
Mが15%

80
00:04:44,666 --> 00:04:46,366
Qが25%

81
00:04:46,366 --> 00:04:48,166
Hが30%です

82
00:04:49,966 --> 00:04:52,366
QRコードをビローンと伸ばして

83
00:04:52,366 --> 00:04:56,199
ヘッダーやパディングを除いたところにデータが入っています

84
00:04:56,533 --> 00:05:01,733
そこでデータを構成する最小の単位をコードワードと呼びます

85
00:05:02,433 --> 00:05:06,399
QRコードでは1コードワードが8ビットです

86
00:05:07,899 --> 00:05:10,633
データコードワードが10あったとして

87
00:05:10,800 --> 00:05:14,666
そのうち半分を訂正できるようにしたいと思います

88
00:05:15,300 --> 00:05:19,966
1コードワードを訂正するために誤り訂正コードワード数は

89
00:05:19,966 --> 00:05:22,533
その2倍必要となります

90
00:05:22,933 --> 00:05:26,433
なので誤り訂正コードワード数は10になります

91
00:05:27,300 --> 00:05:31,800
よって全コードワード20のうち5個が訂正可能なので

92
00:05:32,266 --> 00:05:39,899
訂正率は5割る20の25%となりこれはレベルQに相当します

93
00:05:41,399 --> 00:05:45,833
またバージョンが大きくなってデータ数が大きくなると

94
00:05:45,833 --> 00:05:49,266
全体を一つのブロックとして誤り訂正をすると

95
00:05:49,733 --> 00:05:52,233
偏りが激しくなってしまったりとか

96
00:05:52,233 --> 00:05:56,533
誤りが訂正されにくくなったりするような現象が起こるので

97
00:05:56,533 --> 00:05:59,633
Read Solomonブロックというものが登場します

98
00:06:00,366 --> 00:06:06,333
データコードワードを複数のブロックにまず分割します

99
00:06:06,833 --> 00:06:12,266
分割したデータコードワードそれぞれに対して誤り訂正を行っていきます

100
00:06:13,100 --> 00:06:15,699
この分割されたデータコードワードと

101
00:06:15,699 --> 00:06:20,366
誤り訂正コードワードのセットをリードソロモン (RS) ブロックと呼びます

102
00:06:21,199 --> 00:06:23,233
この場合訂正率は

103
00:06:23,233 --> 00:06:27,600
リードソロモンブロック内のコードワードに対するも のとなります

104
00:06:29,566 --> 00:06:32,399
というわけでバージョン1だとだいたいこんな感じです

105
00:06:33,199 --> 00:06:37,166
ただしこの訂正率は理論上の最低保証値なので

106
00:06:37,166 --> 00:06:40,133
実際にはもうちょい破損しても読み込めますし

107
00:06:40,133 --> 00:06:45,500
破損の仕方や読み込み側が結構頑張ってくれる場合もあるので

108
00:06:45,500 --> 00:06:48,000
読み込み側の性能にもよります

109
00:06:48,566 --> 00:06:53,233
擬似フレームQRの場合を作る際には

110
00:06:53,233 --> 00:06:56,199
画像で意図的に破損させる値は

111
00:06:56,199 --> 00:06:59,366
できるだけ理論値に沿っておいた方がいいでしょう

112
00:07:00,699 --> 00:07:03,533
では画像のサイズ感が分かったところで

113
00:07:03,533 --> 00:07:06,566
QRコードを生成して合成しようと思います

114
00:07:06,800 --> 00:07:09,866
まずは普通にQRコードを作ります

115
00:07:10,533 --> 00:07:14,699
合成にはUIグラフィックイメージレンダラーを使います

116
00:07:15,166 --> 00:07:19,066
CIFilterを使って生成したQRコードには

117
00:07:19,466 --> 00:07:22,066
このようなクワイエットゾーンと呼ばれる

118
00:07:22,066 --> 00:07:25,833
周りをぐるっと囲む余白があるんですけれども

119
00:07:26,766 --> 00:07:28,733
QRの定義上では

120
00:07:28,733 --> 00:07:30,399
QRのクワイヤットゾーンには

121
00:07:30,399 --> 00:07:33,066
4セル分の余白を周りにつけるように

122
00:07:33,066 --> 00:07:34,733
定義されているんですけれども

123
00:07:34,966 --> 00:07:38,133
CIFilterで生成されたQRコードには

124
00:07:38,133 --> 00:07:40,899
1セル分の余白しかつけられていないので

125
00:07:40,899 --> 00:07:43,800
左右合わせて2セル分大きくなった状態で

126
00:07:43,800 --> 00:07:46,233
画像サイズを計算するようにします

127
00:07:46,966 --> 00:07:49,399
位置を調整したり合成して

128
00:07:50,300 --> 00:07:52,699
フレームQRできました

129
00:07:52,699 --> 00:07:54,766
拍手

130
00:07:56,399 --> 00:07:57,666
ありがとうございます

131
00:07:57,666 --> 00:08:00,266
特に何も考えずに画像を置く場合

132
00:08:00,266 --> 00:08:04,233
誤り訂正レベルはできるだけ高めに設定しておけば

133
00:08:04,233 --> 00:08:06,733
その分復活する可能性も高いので

134
00:08:06,733 --> 00:08:08,333
そうしておいた方がいいと思います

135
00:08:08,866 --> 00:08:12,100
話はここまでにしようかなと思っていたんですけれど

136
00:08:12,100 --> 00:08:14,500
まだ10分も経っていないぐらいで

137
00:08:14,500 --> 00:08:16,600
思いのはか早く終わってしまったので

138
00:08:16,600 --> 00:08:20,000
ここからは本当は入れようかなと思っていたんですけど

139
00:08:20,000 --> 00:08:21,399
ちょっと検証が間に合わなかった

140
00:08:21,399 --> 00:08:23,933
今取り組み中の話をします

141
00:08:25,266 --> 00:08:26,366
さっきので

142
00:08:26,366 --> 00:08:28,566
擬似フレームQRできんじゃんって思って

143
00:08:28,566 --> 00:08:30,600
めっちゃ調子に乗った私は

144
00:08:30,600 --> 00:08:34,000
もっと特殊なQRコードを作れるんじゃないって思って

145
00:08:34,000 --> 00:08:36,333
さらに調子をこち始めました

146
00:08:37,866 --> 00:08:42,700
じゃあ分割QRコードとかって作れるのかなって思い始めました

147
00:08:43,500 --> 00:08:47,000
QRコードはバージョン40の容量以上のデータを

148
00:08:47,000 --> 00:08:49,133
持たせることはできないんですけれども

149
00:08:50,299 --> 00:08:53,600
分割して上限突破することができるんですね

150
00:08:53,600 --> 00:08:58,966
お薬手帳のQRコードなどで見たことがある人もいるかもしれません

151
00:09:00,433 --> 00:09:03,399
前にQRコードをビロンって伸ばしたときに

152
00:09:03,399 --> 00:09:05,833
ヘッダーがあるってちょっと触れました

153
00:09:05,833 --> 00:09:07,433
普通のQRだと

154
00:09:07,433 --> 00:09:12,299
ヘッダーは4ビットだけモード指示子が入っているぐらいで

155
00:09:12,299 --> 00:09:14,333
あんまりデータ入ってないんですね

156
00:09:15,100 --> 00:09:17,666
分割QRコードの場合

157
00:09:18,266 --> 00:09:22,633
ヘッダーの冒頭4ビットに3を入れると

158
00:09:22,633 --> 00:09:27,433
それは分割QRコードだということと判断されます

159
00:09:28,533 --> 00:09:35,399
そして次の4ビットに分割されたQRの何番目かというページ番号

160
00:09:35,399 --> 00:09:42,166
その次の4ビットに最大のページ数を格納します

161
00:09:42,566 --> 00:09:44,700
最大のページ数4ビットなので

162
00:09:44,700 --> 00:09:48,733
つまり最大で16分割まで可能ということです

163
00:09:49,333 --> 00:09:52,466
次の4ビットにはパリティの上位

164
00:09:52,466 --> 00:09:53,333
4ビット

165
00:09:53,333 --> 00:09:57,033
その次にはパリティの解4ビットを入れます

166
00:09:57,033 --> 00:09:58,966
このパリティっていうのは

167
00:09:58,966 --> 00:10:02,366
連結するQRコード全てに共通しているもので

168
00:10:02,366 --> 00:10:07,133
全データに対するパリティを算出して使います

169
00:10:07,133 --> 00:10:10,966
なので連結QR読み取り側では

170
00:10:10,966 --> 00:10:14,266
連結用ID的な扱いをされます

171
00:10:15,633 --> 00:10:20,333
他はほとんど普通のQRと同じように作っていきます

172
00:10:21,100 --> 00:10:25,700
それだけ聞くとできなくもないんじゃねって思ってきませんか

173
00:10:27,266 --> 00:10:30,566
でもCIQRCodeGeneratorでヘッダー情報を

174
00:10:30,566 --> 00:10:32,899
いじることってできるのかなみたいな

175
00:10:32,899 --> 00:10:33,766
はい

176
00:10:34,833 --> 00:10:36,100
できません

177
00:10:36,533 --> 00:10:37,933
調子に乗りすぎました

178
00:10:37,933 --> 00:10:39,033
悲しいですね

179
00:10:40,566 --> 00:10:42,533
なので手作りしようと思います

180
00:10:42,933 --> 00:10:45,033
ヘッダー情報をいじるだけなので

181
00:10:45,033 --> 00:10:47,766
とりあえず普通のQRコードができるようになれば

182
00:10:47,766 --> 00:10:49,500
できるはずだと思います

183
00:10:49,933 --> 00:10:53,899
Zebra CrossingというJava製のQRコードを生成するための

184
00:10:53,899 --> 00:10:56,566
オープンソースライブラリがあるんですけれども

185
00:10:56,866 --> 00:11:00,200
現在それはメンテナンスモードになっているので

186
00:11:00,200 --> 00:11:04,133
それをさらにC++で書き直されて

187
00:11:04,133 --> 00:11:09,100
いろいろ改善されたZebra Crossing C++というライブラリを

188
00:11:09,100 --> 00:11:10,399
参考にします

189
00:11:11,033 --> 00:11:15,066
とはいえC++ 私読めないなと思ったので

190
00:11:15,066 --> 00:11:18,266
現在Swiftへの翻訳を試みているところです

191
00:11:18,633 --> 00:11:21,933
これ全部解説すると今度は時間が収まりきらないので

192
00:11:21,933 --> 00:11:24,533
かなりかいつまんで説明します

193
00:11:25,500 --> 00:11:27,899
QRコードには4つのモードがあって

194
00:11:27,899 --> 00:11:29,600
モード指示子で指定します

195
00:11:29,933 --> 00:11:33,100
この中でこの8ビットモードを使うと

196
00:11:33,100 --> 00:11:35,566
バイナリーを格納することができます

197
00:11:36,033 --> 00:11:38,100
バイナリーを入れられるということは

198
00:11:38,166 --> 00:11:40,366
日本語以外でもどんな文字列でも

199
00:11:40,366 --> 00:11:42,000
入れることができるということです

200
00:11:43,000 --> 00:11:45,433
今回は一律でバイナリーモードを

201
00:11:45,433 --> 00:11:46,533
使用することにします

202
00:11:47,033 --> 00:11:49,033
これバイナリモードにすると

203
00:11:49,033 --> 00:11:53,799
QRコード生成側でいろいろ頑張って変換したりしなくてよくて

204
00:11:53,799 --> 00:11:56,899
バイナリをそのまま入れることができるので

205
00:11:56,899 --> 00:12:00,666
生成側としてはかなりサボれる便利なモードとなっています

206
00:12:01,433 --> 00:12:04,133
モードが決まったのでヘッダー情報として

207
00:12:04,133 --> 00:12:07,700
最初の4ビットにモードCCを入れておきます

208
00:12:08,766 --> 00:12:10,933
そして次にバージョン決めます

209
00:12:10,933 --> 00:12:13,533
特定のバージョンを指定してもいいですし

210
00:12:13,533 --> 00:12:16,200
含めたいデータと誤り訂正レベルから

211
00:12:16,200 --> 00:12:18,766
ちょうどいいバージョンを取得してもいいです

212
00:12:19,100 --> 00:12:20,633
バージョンが決まったら

213
00:12:20,866 --> 00:12:26,033
バージョンの寸法に合わせてQRのマトリックスを作成します

214
00:12:26,233 --> 00:12:27,933
特にコードは書いてないんですけど

215
00:12:27,933 --> 00:12:30,700
私はこれはオプショナルのブールの

216
00:12:30,700 --> 00:12:33,066
二次元配列で表現しています

217
00:12:33,733 --> 00:12:36,500
あとで全部のセルが埋まっているかを

218
00:12:36,500 --> 00:12:38,033
確認しないといけないので

219
00:12:38,033 --> 00:12:40,500
最初は全て nil を入れています

220
00:12:41,899 --> 00:12:44,333
またデータの部分の終わりを

221
00:12:44,333 --> 00:12:46,766
正確に識別できるようにするために

222
00:12:46,766 --> 00:12:49,266
入力するデータのバイト数を

223
00:12:50,433 --> 00:12:53,200
含めたいデータのバイト数を求めて

224
00:12:53,200 --> 00:12:56,533
これをヘッダーに追加します

225
00:12:57,866 --> 00:13:00,666
このバイト数を入れるこのビット数は

226
00:13:00,666 --> 00:13:02,799
バージョンによって決まってます

227
00:13:04,033 --> 00:13:06,066
バージョン1のバイナリーモードでは

228
00:13:06,066 --> 00:13:11,333
ここ8ビット分の長さを入れるエリアがあります

229
00:13:12,299 --> 00:13:14,733
バージョンと誤り訂正レベルから

230
00:13:14,733 --> 00:13:18,833
データ部分に格納できる最大数が取得することができます

231
00:13:19,533 --> 00:13:22,633
バージョン1で誤り訂正レベル Q のとき

232
00:13:23,000 --> 00:13:26,933
格納可能数は13バイトです

233
00:13:27,033 --> 00:13:31,466
ただしこれはヘッダー情報も含んだ容量です

234
00:13:33,633 --> 00:13:38,700
ヘッダーが12ビットでデータコードワードが4バイトあって

235
00:13:38,700 --> 00:13:40,700
全部で13バイト入るんで

236
00:13:41,200 --> 00:13:44,000
これで60ビットぐらい余ってますね

237
00:13:44,366 --> 00:13:46,000
これをどうにかしたいです

238
00:13:46,433 --> 00:13:50,500
とりあえずコード後の最後に終端パターンとして

239
00:13:51,066 --> 00:13:53,799
0を4つ4ビット分入れます

240
00:13:55,133 --> 00:13:57,166
これでデータがどこまで入っているか

241
00:13:57,166 --> 00:13:58,899
っていうのを分かりやすくしてます

242
00:13:59,500 --> 00:14:05,433
そしてちょうど1バイトの境界になるように0で調整します

243
00:14:06,233 --> 00:14:10,066
するとちょうど残りは8のバイスのビット分が残るので

244
00:14:10,066 --> 00:14:15,533
パディングパターンとして16進数のECと16進数の11を

245
00:14:15,533 --> 00:14:18,466
交互に入れて埋めていきます

246
00:14:19,299 --> 00:14:22,566
これでデータ部分は全て埋まることができました

247
00:14:24,100 --> 00:14:28,433
データ部分に誤り訂正ブロックをインターリーブします

248
00:14:28,433 --> 00:14:34,299
これは擬似フレーム QR で説明した誤り訂正をそのまま入れています

249
00:14:36,200 --> 00:14:39,366
これでメッセージに関する部分は全て揃いました

250
00:14:40,366 --> 00:14:43,266
次はマスクパターンを選択します

251
00:14:43,266 --> 00:14:47,266
マスクパターンとは白と黒のバランスを整えたりとか

252
00:14:47,266 --> 00:14:53,666
意味のある配列と似た配置になってしまいないようにするために使用します

253
00:14:54,399 --> 00:14:56,299
マスクパターンは8種類あって

254
00:14:56,299 --> 00:14:59,033
全てのマスクを試していて

255
00:14:59,033 --> 00:15:03,066
一番良さげなやつを選ぶという風に選んでいきます

256
00:15:04,166 --> 00:15:08,399
試すには一旦マトリックスを構築する必要があるので

257
00:15:08,433 --> 00:15:11,100
ちょっとマスク選択は一旦ステイで

258
00:15:11,100 --> 00:15:13,633
先にマトリックスをビルドしていきます

259
00:15:15,399 --> 00:15:19,200
冒頭で作った空のマトリックスを引っ張ってきて

260
00:15:19,200 --> 00:15:22,933
まずファインドパターンとセパレーターを生み込みます

261
00:15:24,066 --> 00:15:28,399
これは位置とか回転を検出できるやつですね

262
00:15:28,933 --> 00:15:32,633
必要であればアライメントパターンを生み込みます

263
00:15:34,333 --> 00:15:37,133
これバージョン1だとちょっと出ないんですけれども

264
00:15:37,133 --> 00:15:39,866
こんな感じのやつです

265
00:15:40,500 --> 00:15:44,666
バージョンごとにどこにアライメントパターンを出すかっていうのが

266
00:15:44,666 --> 00:15:45,899
決められているので

267
00:15:46,299 --> 00:15:49,633
指定の位置に5×5のパターンを埋め込んでいきます

268
00:15:50,033 --> 00:15:55,566
これは歪みによって生じるセルの位置ズレを補正してくれるものです

269
00:15:57,100 --> 00:16:00,000
続いてタイミングパターンを埋め込んでいきます

270
00:16:00,700 --> 00:16:04,799
白と黒のセルを交互に並べていくことで

271
00:16:04,799 --> 00:16:09,066
セルの大きさとセル全体の大きさを伝えて

272
00:16:09,066 --> 00:16:10,766
座標を決定していきます

273
00:16:12,366 --> 00:16:14,933
そしてフォーマット情報を埋め込みます

274
00:16:14,933 --> 00:16:19,500
フォーマット情報とは誤り訂正レベルとマスクパターンのことです

275
00:16:19,500 --> 00:16:22,000
このフォーマット情報については

276
00:16:22,000 --> 00:16:25,933
固定のポリ16進数の537を使って

277
00:16:25,933 --> 00:16:29,466
BCH符号という誤り訂正符号を

278
00:16:29,466 --> 00:16:31,500
手法を使います

279
00:16:32,566 --> 00:16:33,666
いろいろあるんですけど

280
00:16:33,666 --> 00:16:36,566
これによって10ビットの誤り訂正符号を

281
00:16:36,566 --> 00:16:37,733
得ることができるので

282
00:16:37,733 --> 00:16:39,899
これをくっつけます

283
00:16:40,733 --> 00:16:43,600
これが全部ゼロになっちゃわないように

284
00:16:43,600 --> 00:16:46,633
特定のビットパターンの

285
00:16:46,633 --> 00:16:49,600
16進数の5412というのを

286
00:16:50,466 --> 00:16:54,399
排他的論理和 (XOR) を取ってマスクをかけます

287
00:16:55,533 --> 00:16:58,733
これで15ビットのフォーマット情報ができたので

288
00:16:58,733 --> 00:17:00,266
埋め込んでいきます

289
00:17:00,966 --> 00:17:04,233
QRコードの一部が破損したとしても

290
00:17:04,233 --> 00:17:06,766
読み込めるように2箇所に置いていきます

291
00:17:08,633 --> 00:17:12,333
まず1つは左上のファインダーパターンのところと

292
00:17:12,333 --> 00:17:13,133
あともう1個

293
00:17:13,133 --> 00:17:17,433
左下と右上に半々ずつ入れていきます

294
00:17:17,433 --> 00:17:20,166
これでフォーマット情報が格納されました

295
00:17:21,366 --> 00:17:24,099
最後に誤り訂正符号を付けた

296
00:17:24,099 --> 00:17:26,733
データにマスクを適用して

297
00:17:26,733 --> 00:17:29,833
この空いてるところに埋め込んでいきます

298
00:17:29,833 --> 00:17:33,366
これで全てのセルが埋まったマトリックスができたので

299
00:17:33,366 --> 00:17:35,900
マスク選択に戻っていきます

300
00:17:36,566 --> 00:17:42,333
さっきのマトリックスを全部のマスク分作っていって

301
00:17:42,666 --> 00:17:46,033
それぞれのマトリックスに対して評価を行っていきます

302
00:17:46,799 --> 00:17:50,233
これらのこの4つのペナルティを合算して

303
00:17:50,500 --> 00:17:55,400
一番ペナルティが低かったものを最適なマスクとして選定します

304
00:17:55,400 --> 00:18:02,200
これで選定されたマスクで再度マトリックスを構築すれば

305
00:18:02,200 --> 00:18:07,233
QRコードの元になるマトリックスが完成するというところです

306
00:18:08,466 --> 00:18:13,000
このマトリックスブールの二次元配列で私作ってるんですけれども

307
00:18:13,000 --> 00:18:17,333
どうやって画像にしたらいいかなっていうのが今の悩みなので

308
00:18:17,333 --> 00:18:19,099
何かアイデアがあれば

309
00:18:19,099 --> 00:18:21,566
Ask the Speakerで教えてください

310
00:18:22,900 --> 00:18:25,066
最後にぜひ読み取ってほしい

311
00:18:25,066 --> 00:18:27,166
QRコードがこちらです

312
00:18:36,933 --> 00:18:38,466
11月2日に

313
00:18:38,466 --> 00:18:41,700
鎌倉で Swift コミュニティのイベントをやりますので

314
00:18:41,700 --> 00:18:43,666
ぜひ遊びに来てください

315
00:18:43,666 --> 00:18:46,500
はい、ありがとうございました

316
00:18:52,466 --> 00:18:54,233
(司会) 発表ありがとうございました

317
00:18:54,233 --> 00:18:56,066
それではQ& Aに入りたいと思います

318
00:18:56,066 --> 00:18:58,333
コメントやご質問のある方がいらっしゃいましたら

319
00:18:58,333 --> 00:18:59,866
手を挙げてお知らせください

320
00:19:04,233 --> 00:19:06,599
いらっしゃいませんでしょうか

321
00:19:09,266 --> 00:19:12,266
それでは Q&A 終了しますので

322
00:19:12,266 --> 00:19:16,033
続いて一分間のフィードバックのお時間です

