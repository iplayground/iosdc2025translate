1
01:00:03,566 --> 01:00:07,566
QRコードの仕様ってn種類あんねん

2
01:00:07,566 --> 01:00:10,066
Nは何か分かりますか

3
01:00:10,066 --> 01:00:14,133
ぜひiOSDC #Dでツイートしてくださいね

4
01:00:14,133 --> 01:00:15,066
はい

5
01:00:15,066 --> 01:00:15,966
Ryomm です

6
01:00:15,966 --> 01:00:17,333
よろしくお願いします

7
01:00:17,333 --> 01:00:19,466
iOSアプリエンジニアをしていて

8
01:00:19,466 --> 01:00:24,333
仕事では電車とかバスの交通チケットを主に取り扱うような

9
01:00:24,333 --> 01:00:26,766
MaaS アプリを開発しています

10
01:00:27,533 --> 01:00:31,066
さて、QRコードを生成したい

11
01:00:31,733 --> 01:00:33,500
QRコードの生成には

12
01:00:33,500 --> 01:00:38,366
CIFilter の CIQRCodeGenerator を使います

13
01:00:39,033 --> 01:00:42,533
inputMessageにQRコードに含めるデータ

14
01:00:42,699 --> 01:00:47,233
inputCorrectionLevelに誤り訂正レベルが指定できます

15
01:00:47,633 --> 01:00:49,933
誤り訂正レベルというのは

16
01:00:49,933 --> 01:00:53,033
どの程度汚れたり隠れたりしても

17
01:00:53,033 --> 01:00:55,966
読み取れるようにするのかというレベルです

18
01:00:55,966 --> 01:00:58,266
大きさなんかをちょっと整えて

19
01:00:58,266 --> 01:01:01,033
QRコードが生成できました

20
01:01:01,033 --> 01:01:03,099
いやめでたしめでたし

21
01:01:03,599 --> 01:01:05,800
それだとよかったですね

22
01:01:06,566 --> 01:01:11,900
最近の MaaS 界隈ではQRチケットが今大流行中です

23
01:01:11,900 --> 01:01:15,099
改札機のような大掛かりな設備がなくても

24
01:01:15,099 --> 01:01:17,699
簡単に導入することができます

25
01:01:18,400 --> 01:01:20,466
ただこのQRチケット

26
01:01:20,466 --> 01:01:23,166
QRコードを読み込む端末によっては

27
01:01:23,166 --> 01:01:26,766
QRの仕様が厳密に定められているときがあって

28
01:01:26,766 --> 01:01:27,966
仕様が満たせないと

29
01:01:27,966 --> 01:01:30,933
読み込んでもらえないということが起こり得ます

30
01:01:32,033 --> 01:01:36,633
そのうちの一つにバージョンと呼ばれる仕様があります

31
01:01:37,733 --> 01:01:42,266
QRコードの最小のマス目をセルと呼ぶんですけれども

32
01:01:42,266 --> 01:01:47,633
このセルが縦横に何個あるかという定義がバージョンで表されています

33
01:01:47,966 --> 01:01:52,633
バージョンによってはQRコードに含められるデータ量が変わります

34
01:01:53,800 --> 01:01:56,400
バージョンは1から40まであり

35
01:01:56,400 --> 01:02:00,000
バージョンが大きくなるとその分セルの数も増えるので

36
01:02:00,000 --> 01:02:04,900
つまりそのままQRコードに含められるデータ量が大きくなります

37
01:02:04,900 --> 01:02:09,266
モードや誤り訂正レベルによっても結構変わるんですけれども

38
01:02:09,266 --> 01:02:13,433
例えば誤り訂正レベルMでバイナリーを含める場合

39
01:02:13,433 --> 01:02:16,033
バージョン1だと14バイトだけ

40
01:02:16,033 --> 01:02:19,133
バージョン5だと84バイト

41
01:02:19,133 --> 01:02:22,066
バージョン10では213バイト

42
01:02:22,066 --> 01:02:26,033
最大のバージョン40では2331バイトまで

43
01:02:26,033 --> 01:02:27,800
含めることができます

44
01:02:28,400 --> 01:02:31,099
QRコードの読み取り端末によっては

45
01:02:31,099 --> 01:02:35,500
指定のQRコードバージョンしか読み取れないということもあるのです

46
01:02:37,000 --> 01:02:43,366
さて冒頭のCIFilterを使ったQRコード生成に戻ってみると

47
01:02:43,366 --> 01:02:45,133
皆様お気づきでしょうか

48
01:02:46,466 --> 01:02:51,966
これ含めるデータと誤り訂正レベルしか指定できなくね

49
01:02:52,733 --> 01:02:56,166
どうやって特定のQRコードバージョンにしたらいいんだ

50
01:02:57,133 --> 01:03:01,066
どう調べてもバージョンの指定方法なんてないぞ

51
01:03:01,066 --> 01:03:04,533
勝手にいろんなバージョンで生成されるし

52
01:03:06,000 --> 01:03:09,300
勝手にいろんなバージョンで生成されている

53
01:03:10,000 --> 01:03:14,500
これってQRコードに含めるデータのバイト量に応じて

54
01:03:14,500 --> 01:03:18,266
最適化してくれてるってことじゃねって

55
01:03:18,266 --> 01:03:19,833
気づきませんでした

56
01:03:19,833 --> 01:03:21,566
気づきました

57
01:03:22,599 --> 01:03:24,566
つまりこうじゃね

58
01:03:26,099 --> 01:03:28,066
バージョンの最大値に合わせて

59
01:03:28,066 --> 01:03:31,266
頭をゼロで埋めて長さ調整することで

60
01:03:31,266 --> 01:03:33,566
格納するデータは変えずに

61
01:03:33,566 --> 01:03:37,266
狙ったバージョンのQRコード画像を出力できる

62
01:03:38,699 --> 01:03:40,966
こうすることで同じバイナリでも

63
01:03:40,966 --> 01:03:44,266
狙ったバージョンのQRコードを生成することができました

64
01:03:44,800 --> 01:03:46,099
拍手

65
01:03:48,466 --> 01:03:49,900
ありがとうございます

66
01:03:50,433 --> 01:03:51,733
こうなると頑張れば

67
01:03:51,733 --> 01:03:55,633
他にもいろんなQRコード作れそうな気がしてきましたよね

68
01:03:56,533 --> 01:03:59,366
皆様フレームQRご存知でしょうか

69
01:03:59,800 --> 01:04:01,266
このフレームQRとは

70
01:04:01,266 --> 01:04:05,833
コード内に自由に使えるキャンバス領域を持ったQRコードです

71
01:04:05,866 --> 01:04:12,300
ただこちら個人でちゃんと作ろうとすると結構大変なんですけれども

72
01:04:12,300 --> 01:04:17,033
誤り訂正を利用して擬似的に再現することができます

73
01:04:17,033 --> 01:04:22,800
これまでの話で誤り訂正レベルとかさらっと出てきたんですけれども

74
01:04:22,800 --> 01:04:27,233
名前だけ聞いて、誤り訂正するんじゃねって感じだと思うので

75
01:04:27,233 --> 01:04:29,433
ちゃんと説明しようと思います

76
01:04:29,433 --> 01:04:33,333
QRコードの誤り訂正レベルは4種類あって

77
01:04:33,333 --> 01:04:35,133
それぞれの復元率は

78
01:04:35,133 --> 01:04:37,533
Lが7%

79
01:04:37,533 --> 01:04:39,099
Mが15%

80
01:04:39,099 --> 01:04:40,800
Qが25%

81
01:04:40,800 --> 01:04:42,599
Hが30%です

82
01:04:44,366 --> 01:04:46,766
QRコードをビローンと伸ばして

83
01:04:46,766 --> 01:04:50,599
ヘッダーやパディングを除いたところにデータが入っています

84
01:04:50,933 --> 01:04:56,133
そこでデータを構成する最小の単位をコードワードと呼びます

85
01:04:56,833 --> 01:05:00,800
QRコードでは1コードワードが8ビットです

86
01:05:02,300 --> 01:05:05,033
データコードワードが10あったとして

87
01:05:05,199 --> 01:05:09,066
そのうち半分を訂正できるようにしたいと思います

88
01:05:09,699 --> 01:05:14,366
1コードワードを訂正するために誤り訂正コードワード数は

89
01:05:14,366 --> 01:05:16,933
その2倍必要となります

90
01:05:17,333 --> 01:05:20,833
なので誤り訂正コードワード数は10になります

91
01:05:21,699 --> 01:05:26,199
よって全コードワード20のうち5個が訂正可能なので

92
01:05:26,666 --> 01:05:34,300
訂正率は5割る20の25%となりこれはレベル9に相当します

93
01:05:35,800 --> 01:05:40,233
またバージョンが大きくなってデータ数が大きくなると

94
01:05:40,233 --> 01:05:43,666
全体を一つのブロックとして誤り訂正をすると

95
01:05:44,133 --> 01:05:46,633
偏りが激しくなってしまったりとか

96
01:05:46,633 --> 01:05:50,933
誤りが訂正されにくくなったりするような現象が起こるので

97
01:05:50,933 --> 01:05:54,033
Read Solomonブロックというものが登場します

98
01:05:54,766 --> 01:06:00,733
データコードワードを複数のブロックにまず分割します

99
01:06:01,233 --> 01:06:06,666
分割したデータコードワードそれぞれに対して誤り訂正を行っていきます

100
01:06:07,466 --> 01:06:10,066
この分割されたデータコードワードと

101
01:06:10,066 --> 01:06:14,733
誤り訂正コードワードのセットをリードソロモン (RS) ブロックと呼びます

102
01:06:15,566 --> 01:06:17,599
この場合訂正率は

103
01:06:17,599 --> 01:06:21,966
リードソロモンブロック内のコードワードに対するも のとなります

104
01:06:23,866 --> 01:06:26,699
というわけでバージョン1だとだいたいこんな感じです

105
01:06:27,533 --> 01:06:31,500
ただしこの訂正率は理論上の最低保証値なので

106
01:06:31,500 --> 01:06:34,466
実際にはもうちょい破損しても読み込めますし

107
01:06:34,466 --> 01:06:39,833
破損の仕方や読み込み側が結構頑張ってくれる場合もあるので

108
01:06:39,833 --> 01:06:42,333
読み込み側の性能にもよります

109
01:06:43,033 --> 01:06:47,699
擬似フレームQRの場合を作る際には

110
01:06:47,699 --> 01:06:50,666
画像で意図的に破損させる値は

111
01:06:50,666 --> 01:06:53,733
できるだけ理論値に沿っておいた方がいいでしょう

112
01:06:55,133 --> 01:06:57,966
では画像のサイズ感が分かったところで

113
01:06:57,966 --> 01:07:00,699
QRコードを生成して合成しようと思います

114
01:07:01,233 --> 01:07:03,866
まずは普通にQRコードを作ります

115
01:07:04,866 --> 01:07:09,033
合成にはUIグラフィックイメージレンダラーを使います

116
01:07:09,500 --> 01:07:13,400
CIFilterを使って生成したQRコードには

117
01:07:13,766 --> 01:07:16,366
このようなクワイエットゾーンと呼ばれる

118
01:07:16,500 --> 01:07:20,133
周りをぐるっと囲む余白があるんですけれども

119
01:07:21,066 --> 01:07:23,166
QRの定義上では

120
01:07:23,166 --> 01:07:25,033
QRのクワイヤットゾーンには

121
01:07:25,033 --> 01:07:27,366
4セル分の余白を周りにつけるように

122
01:07:27,366 --> 01:07:29,033
定義されているんですけれども

123
01:07:29,266 --> 01:07:32,500
CIFilterで生成されたQRコードには

124
01:07:32,500 --> 01:07:35,199
1セル分の余白しかつけられていないので

125
01:07:35,199 --> 01:07:38,099
左右合わせて2セル分大きくなった状態で

126
01:07:38,099 --> 01:07:40,533
画像サイズを計算するようにします

127
01:07:41,400 --> 01:07:43,833
位置を調整したり合成して

128
01:07:44,599 --> 01:07:47,166
フレームQRできました

129
01:07:47,166 --> 01:07:48,166
拍手

130
01:07:50,699 --> 01:07:51,966
ありがとうございます

131
01:07:51,966 --> 01:07:54,699
特に何も考えずに画像を置く場合

132
01:07:54,699 --> 01:07:58,666
誤り訂正レベルはできるだけ高めに設定しておけば

133
01:07:58,666 --> 01:08:01,400
その分復活する可能性も高いので

134
01:08:01,400 --> 01:08:02,833
そうしておいた方がいいと思います

135
01:08:03,166 --> 01:08:06,500
話はここまでにしようかなと思っていたんですけれど

136
01:08:06,500 --> 01:08:08,933
まだ10分も経っていないぐらいで

137
01:08:08,933 --> 01:08:11,033
思いのはか早く終わってしまったので

138
01:08:11,033 --> 01:08:14,333
ここからは本当は入れようかなと思っていたんですけど

139
01:08:14,333 --> 01:08:16,000
ちょっと検証が間に合わなかった

140
01:08:16,000 --> 01:08:18,366
今取り組み中の話をします

141
01:08:19,699 --> 01:08:20,800
さっきので

142
01:08:20,800 --> 01:08:23,166
擬似フレームQRできんじゃんって思って

143
01:08:23,166 --> 01:08:24,866
めっちゃ調子に乗った私は

144
01:08:24,866 --> 01:08:28,333
もっと特殊なQRコードを作れるんじゃないって思って

145
01:08:28,333 --> 01:08:30,933
さらに調子をこち始めました

146
01:08:32,300 --> 01:08:37,133
じゃあ分割QRコードとかって作れるのかなって思い始めました

147
01:08:37,800 --> 01:08:41,300
QRコードはバージョン40の容量以上のデータを

148
01:08:41,300 --> 01:08:43,800
持たせることはできないんですけれども

149
01:08:44,600 --> 01:08:48,100
分割して上限突破することができるんですね

150
01:08:48,100 --> 01:08:53,466
お薬手帳のQRコードなどで見たことがある人もいるかもしれません

151
01:08:54,733 --> 01:08:57,600
前にQRコードをビロンって伸ばしたときに

152
01:08:57,600 --> 01:09:00,133
ヘッダーがあるってちょっと触れました

153
01:09:00,133 --> 01:09:01,566
普通のQRだと

154
01:09:01,566 --> 01:09:06,666
ヘッダーは4ビットだけモード指示子が入っているぐらいで

155
01:09:06,666 --> 01:09:08,633
あんまりデータ入ってないんですね

156
01:09:09,466 --> 01:09:12,033
分割QRコードの場合

157
01:09:12,566 --> 01:09:16,933
ヘッダーの冒頭4ビットに3を入れると

158
01:09:16,933 --> 01:09:21,733
それは分割QRコードだということと判断されます

159
01:09:22,833 --> 01:09:29,699
そして次の4ビットに分割されたQRの何番目かというページ番号

160
01:09:29,699 --> 01:09:36,466
その次の4ビットに最大のページ数を格納します

161
01:09:36,866 --> 01:09:39,000
最大のページ数4ビットなので

162
01:09:39,000 --> 01:09:43,033
つまり最大で16分割まで可能ということです

163
01:09:43,633 --> 01:09:46,766
次の4ビットにはパリティの上位

164
01:09:46,766 --> 01:09:47,633
4ビット

165
01:09:47,633 --> 01:09:51,333
その次にはパリティの解4ビットを入れます

166
01:09:51,333 --> 01:09:53,266
このパリティっていうのは

167
01:09:53,266 --> 01:09:56,666
連結するQRコード全てに共通しているもので

168
01:09:56,666 --> 01:10:01,433
全データに対するパリティを算出して使います

169
01:10:01,433 --> 01:10:05,266
なので連結QR読み取り側では

170
01:10:05,266 --> 01:10:08,566
連結用ID的な扱いをされます

171
01:10:10,000 --> 01:10:14,699
他はほとんど普通のQRと同じように作っていきます

172
01:10:16,066 --> 01:10:20,199
それだけ聞くとできなくもないんじゃねって思ってきませんか

173
01:10:21,566 --> 01:10:24,866
でもCIQRCodeGeneratorでヘッダー情報を

174
01:10:24,866 --> 01:10:27,199
いじることってできるのかなみたいな

175
01:10:27,199 --> 01:10:28,066
はい

176
01:10:29,133 --> 01:10:30,399
できません

177
01:10:30,933 --> 01:10:32,333
調子に乗りすぎました

178
01:10:32,333 --> 01:10:33,433
悲しいですね

179
01:10:34,933 --> 01:10:36,899
なので手作りしようと思います

180
01:10:37,233 --> 01:10:39,433
ヘッダー情報をいじるだけなので

181
01:10:39,433 --> 01:10:42,066
とりあえず普通のQRコードができるようになれば

182
01:10:42,066 --> 01:10:43,800
できるはずだと思います

183
01:10:44,233 --> 01:10:48,300
Zebra CrossingというJava製のQRコードを生成するための

184
01:10:48,300 --> 01:10:50,866
オープンソースライブラリがあるんですけれども

185
01:10:51,166 --> 01:10:54,500
現在それはメンテナンスモードになっているので

186
01:10:54,500 --> 01:10:58,600
それをさらにC++で書き直されて

187
01:10:58,600 --> 01:11:03,566
いろいろ改善されたZebra Crossing C++というライブラリを

188
01:11:03,566 --> 01:11:04,866
参考にします

189
01:11:05,333 --> 01:11:09,366
とはいえC++ 私読めないなと思ったので

190
01:11:09,366 --> 01:11:12,566
現在Swiftへの翻訳を試みているところです

191
01:11:12,933 --> 01:11:16,333
これ全部解説すると今度は時間が収まりきらないので

192
01:11:16,333 --> 01:11:18,833
かなりかいつまんで説明します

193
01:11:19,800 --> 01:11:22,199
QRコードには4つのモードがあって

194
01:11:22,199 --> 01:11:23,899
モード指示子で指定します

195
01:11:24,233 --> 01:11:27,500
この中でこの8ビットモードを使うと

196
01:11:27,500 --> 01:11:29,966
バイナリーを格納することができます

197
01:11:30,366 --> 01:11:32,433
バイナリーを入れられるということは

198
01:11:32,600 --> 01:11:34,800
日本語以外でもどんな文字列でも

199
01:11:34,800 --> 01:11:36,433
入れることができるということです

200
01:11:37,366 --> 01:11:39,800
今回は一律でバイナリーモードを

201
01:11:39,800 --> 01:11:40,899
使用することにします

202
01:11:41,399 --> 01:11:43,399
これバイナリモードにすると

203
01:11:43,399 --> 01:11:48,166
QRコード生成側でいろいろ頑張って変換したりしなくてよくて

204
01:11:48,166 --> 01:11:51,266
バイナリをそのまま入れることができるので

205
01:11:51,266 --> 01:11:55,033
生成側としてはかなりサボれる便利なモードとなっています

206
01:11:55,800 --> 01:11:58,500
モードが決まったのでヘッダー情報として

207
01:11:58,500 --> 01:12:01,566
最初の4ビットにモードCCを入れておきます

208
01:12:03,133 --> 01:12:05,300
そして次にバージョン決めます

209
01:12:05,300 --> 01:12:07,899
特定のバージョンを指定してもいいですし

210
01:12:07,899 --> 01:12:10,566
含めたいデータと誤り訂正レベルから

211
01:12:10,566 --> 01:12:13,033
ちょうどいいバージョンを取得してもいいです

212
01:12:13,466 --> 01:12:15,000
バージョンが決まったら

213
01:12:15,233 --> 01:12:20,399
バージョンの寸法に合わせてQRのマトリックスを作成します

214
01:12:20,600 --> 01:12:22,300
特にコードは書いてないんですけど

215
01:12:22,300 --> 01:12:25,066
私はこれはオプショナルのブールの

216
01:12:25,066 --> 01:12:27,433
二次元配列で表現しています

217
01:12:28,100 --> 01:12:30,866
あとで全部のセルが埋まっているかを

218
01:12:30,866 --> 01:12:32,399
確認しないといけないので

219
01:12:32,399 --> 01:12:34,866
最初は全て nil を入れています

220
01:12:36,266 --> 01:12:38,699
またデータの部分の終わりを

221
01:12:38,699 --> 01:12:41,133
正確に識別できるようにするために

222
01:12:41,133 --> 01:12:43,633
入力するデータのバイト数を

223
01:12:44,800 --> 01:12:47,566
含めたいデータのバイト数を求めて

224
01:12:47,566 --> 01:12:50,899
これをヘッダーに追加します

225
01:12:52,233 --> 01:12:55,033
このバイト数を入れるこのビット数は

226
01:12:55,033 --> 01:12:57,166
バージョンによって決まってます

227
01:12:58,399 --> 01:13:00,433
バージョン1のバイナリーモードでは

228
01:13:00,433 --> 01:13:05,366
ここ8ビット分の長さを入れるエリアがあります

229
01:13:06,666 --> 01:13:09,100
バージョンと誤り訂正レベルから

230
01:13:09,100 --> 01:13:12,800
データ部分に格納できる最大数が取得することができます

231
01:13:13,899 --> 01:13:17,000
バージョン1で誤り訂正レベル9のとき

232
01:13:17,366 --> 01:13:21,300
格納可能数は13バイトです

233
01:13:21,399 --> 01:13:25,833
ただしこれはヘッダー情報も含んだ容量です

234
01:13:28,000 --> 01:13:33,066
ヘッダーが12ビットでデータコードワードが4バイトあって

235
01:13:33,066 --> 01:13:35,066
全部で13バイト入るんで

236
01:13:35,566 --> 01:13:38,366
これで60ビットぐらい余ってますね

237
01:13:38,733 --> 01:13:40,366
これをどうにかしたいです

238
01:13:40,800 --> 01:13:44,866
とりあえずコード後の最後に終端パターンとして

239
01:13:45,433 --> 01:13:48,166
0を4つ4ビット分入れます

240
01:13:49,500 --> 01:13:51,533
これでデータがどこまで入っているか

241
01:13:51,533 --> 01:13:53,266
っていうのを分かりやすくしてます

242
01:13:53,866 --> 01:13:59,800
そしてちょうど1バイトの境界になるように0で調整します

243
01:14:00,600 --> 01:14:04,266
するとちょうど残りは8のバイスのビット分が残るので

244
01:14:04,266 --> 01:14:09,899
パディングパターンとして16進数のECと16進数の11を

245
01:14:09,899 --> 01:14:12,333
交互に入れて埋めていきます

246
01:14:13,666 --> 01:14:16,933
これでデータ部分は全て埋まることができました

247
01:14:18,466 --> 01:14:22,500
データ部分に誤り訂正ブロックをインターリーブします

248
01:14:22,500 --> 01:14:28,666
これは擬似フレーム QR で説明した誤り訂正をそのまま入れています

249
01:14:30,566 --> 01:14:33,733
これでメッセージに関する部分は全て揃いました

250
01:14:34,733 --> 01:14:37,633
次はマスクパターンを選択します

251
01:14:37,633 --> 01:14:41,633
マスクパターンとは白と黒のバランスを整えたりとか

252
01:14:41,633 --> 01:14:48,033
意味のある配列と似た配置になってしまいないようにするために使用します

253
01:14:48,766 --> 01:14:50,666
マスクパターンは8種類あって

254
01:14:50,666 --> 01:14:53,399
全てのマスクを試していて

255
01:14:53,399 --> 01:14:57,433
一番良さげなやつを選ぶという風に選んでいきます

256
01:14:58,533 --> 01:15:02,766
試すには一旦マトリックスを構築する必要があるので

257
01:15:02,800 --> 01:15:05,466
ちょっとマスク選択は一旦ステイで

258
01:15:05,466 --> 01:15:08,000
先にマトリックスをビルドしていきます

259
01:15:09,766 --> 01:15:13,566
冒頭で作った空のマトリックスを引っ張ってきて

260
01:15:13,566 --> 01:15:17,300
まずファインドパターンとセパレーターを生み込みます

261
01:15:18,433 --> 01:15:22,766
これは位置とか回転を検出できるやつですね

262
01:15:23,300 --> 01:15:27,000
必要であればアライメントパターンを生み込みます

263
01:15:28,699 --> 01:15:31,500
これバージョン1だとちょっと出ないんですけれども

264
01:15:31,500 --> 01:15:34,233
こんな感じのやつです

265
01:15:34,866 --> 01:15:39,033
バージョンごとにどこにアライメントパターンを出すかっていうのが

266
01:15:39,033 --> 01:15:40,266
決められているので

267
01:15:40,666 --> 01:15:44,000
指定の位置に5×5のパターンを埋め込んでいきます

268
01:15:44,399 --> 01:15:49,933
これは歪みによって生じるセルの位置ズレを補正してくれるものです

269
01:15:51,466 --> 01:15:54,366
続いてタイミングパターンを埋め込んでいきます

270
01:15:55,066 --> 01:15:59,166
白と黒のセルを交互に並べていくことで

271
01:15:59,166 --> 01:16:03,433
セルの大きさとセル全体の大きさを伝えて

272
01:16:03,433 --> 01:16:05,133
座標を決定していきます

273
01:16:06,733 --> 01:16:09,300
そしてフォーマット情報を埋め込みます

274
01:16:09,300 --> 01:16:13,866
フォーマット情報とは誤り訂正レベルとマスクパターンのことです

275
01:16:13,866 --> 01:16:16,366
このフォーマット情報については

276
01:16:16,366 --> 01:16:20,800
固定のポリ16進数の0x537を使って

277
01:16:20,800 --> 01:16:23,833
BCH符号という誤り訂正符号を

278
01:16:23,833 --> 01:16:25,866
手法を使います

279
01:16:25,866 --> 01:16:28,033
いろいろあるんですけど

280
01:16:28,033 --> 01:16:30,933
これによって10ビットの誤り訂正符号を

281
01:16:30,933 --> 01:16:32,100
得ることができるので

282
01:16:32,100 --> 01:16:34,266
これをくっつけます

283
01:16:35,233 --> 01:16:38,100
これが全部ゼロになっちゃわないように

284
01:16:38,100 --> 01:16:41,133
特定のビットパターンの

285
01:16:41,133 --> 01:16:44,100
16進数の5412というのを

286
01:16:44,833 --> 01:16:47,199
排他的論理和 (XOR) を取って

287
01:16:47,199 --> 01:16:48,766
マスクをかけます

288
01:16:50,333 --> 01:16:53,533
これで15ビットのフォーマット情報ができたので

289
01:16:53,533 --> 01:16:55,066
埋め込んでいきます

290
01:16:55,766 --> 01:16:59,033
QRコードの一部が破損したとしても

291
01:16:59,033 --> 01:17:01,566
読み込めるように2箇所に置いていきます

292
01:17:03,433 --> 01:17:07,133
まず1つは左上のファインダーパターンのところと

293
01:17:07,133 --> 01:17:07,933
あともう1個

294
01:17:07,933 --> 01:17:12,233
左下と右上に半々ずつ入れていきます

295
01:17:12,233 --> 01:17:14,966
これでフォーマット情報が格納されました

296
01:17:15,699 --> 01:17:18,433
最後に誤り訂正符号を付けた

297
01:17:18,433 --> 01:17:21,066
データにマスクを適用して

298
01:17:21,066 --> 01:17:23,533
この空いてるところに埋め込んでいきます

299
01:17:23,533 --> 01:17:27,699
これで全てのセルが埋まったマトリックスができたので

300
01:17:27,699 --> 01:17:30,233
マスク選択に戻っていきます

301
01:17:31,366 --> 01:17:36,533
さっきのマトリックスを全部のマスク分作っていって

302
01:17:37,466 --> 01:17:40,833
それぞれのマトリックスに対して評価を行っていきます

303
01:17:41,600 --> 01:17:45,033
これらのこの4つのペナルティを合算して

304
01:17:45,300 --> 01:17:49,666
一番ペナルティが低かったものを最適なマスクとして選定します

305
01:17:50,300 --> 01:17:56,166
これで選定されたマスクで再度マトリックスを構築すれば

306
01:17:56,166 --> 01:18:01,466
QRコードの元になるマトリックスが完成するというところです

307
01:18:02,833 --> 01:18:07,366
このマトリックスブールの二次元配列で私作ってるんですけれども

308
01:18:07,366 --> 01:18:11,699
どうやって画像にしたらいいかなっていうのが今の悩みなので

309
01:18:11,699 --> 01:18:13,466
何かアイデアがあれば

310
01:18:13,466 --> 01:18:15,933
Ask the Speakerで教えてください

311
01:18:17,266 --> 01:18:19,433
最後にぜひ読み取ってほしい

312
01:18:19,433 --> 01:18:21,533
QRコードがこちらです

313
01:18:30,433 --> 01:18:32,899
11月2日に

314
01:18:32,899 --> 01:18:35,399
鎌倉でスイストコミュニティの

315
01:18:35,399 --> 01:18:36,566
イベントをやりますので

316
01:18:36,566 --> 01:18:38,100
ぜひ遊びに来てください

317
01:18:38,100 --> 01:18:40,666
ありがとうございました

318
01:18:47,266 --> 01:18:48,866
ありがとうございました

319
01:18:49,233 --> 01:18:50,933
それではQ& Aに入りたいと思います

320
01:18:50,933 --> 01:18:53,333
コメントやご質問のある方がいらっしゃいましたら

321
01:18:53,333 --> 01:18:54,466
手を挙げてお知らせください

