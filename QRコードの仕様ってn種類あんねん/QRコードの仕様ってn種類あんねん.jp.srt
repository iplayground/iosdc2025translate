1
00:00:00,000 --> 00:00:05,480
QRコードの仕様って

2
00:00:05,480 --> 00:00:06,960
N種類アンネン

3
00:00:06,960 --> 00:00:09,460
Nは何か分かりますか

4
00:00:09,460 --> 00:00:10,939
ぜひiOSDC

5
00:00:10,939 --> 00:00:13,539
シャープDでツイートしてくださいね

6
00:00:13,539 --> 00:00:14,480
はい

7
00:00:14,480 --> 00:00:15,380
りょむです

8
00:00:15,380 --> 00:00:16,739
よろしくお願いします

9
00:00:16,739 --> 00:00:19,260
iOSアプリエンジニアをしていて

10
00:00:19,260 --> 00:00:22,899
仕事では電車とかバスの交通チケットを

11
00:00:22,899 --> 00:00:24,280
主に取り扱うような

12
00:00:24,280 --> 00:00:26,160
マースアプリを開発しています

13
00:00:26,160 --> 00:00:28,000
さて

14
00:00:28,000 --> 00:00:30,480
QRコードを生成したい

15
00:00:30,480 --> 00:00:33,280
QRコードの生成には

16
00:00:33,280 --> 00:00:37,780
CIフィルターのCIQRコードジェネレーターを使います

17
00:00:37,780 --> 00:00:42,380
インプットメッセージにQRコードに含めるデータ

18
00:00:42,380 --> 00:00:44,359
インプットコレクションレベルに

19
00:00:44,359 --> 00:00:46,619
誤り訂正レベルが指定できます

20
00:00:46,619 --> 00:00:49,320
誤り訂正レベルというのは

21
00:00:49,320 --> 00:00:52,420
どの程度汚れたり隠れたりしても

22
00:00:52,420 --> 00:00:55,359
読み取れるようにするのかというレベルです

23
00:00:55,359 --> 00:00:57,659
大きさなんかをちょっと整えて

24
00:00:57,659 --> 00:01:00,420
QRコードが生成できました

25
00:01:00,420 --> 00:01:02,500
いやめでたしめでたし

26
00:01:02,500 --> 00:01:05,200
それだとよかったですね

27
00:01:05,200 --> 00:01:08,620
最近のマウス界隈では

28
00:01:08,620 --> 00:01:11,719
QRチケットが今大流行中です

29
00:01:11,719 --> 00:01:15,140
改札機のような大掛かりな設備がなくても

30
00:01:15,140 --> 00:01:17,099
簡単に導入することができます

31
00:01:17,099 --> 00:01:19,859
ただこのQRチケット

32
00:01:19,859 --> 00:01:22,920
QRコードを読み込む端末によっては

33
00:01:22,920 --> 00:01:26,180
QRの仕様が厳密に定められているときがあって

34
00:01:26,180 --> 00:01:30,340
仕様が満たせないと読み込んでもらえないということが起こり得ます

35
00:01:30,340 --> 00:01:36,019
そのうちの一つにバージョンと呼ばれる仕様があります

36
00:01:36,019 --> 00:01:41,680
QRコードの最小のマス目をセルと呼ぶんですけれども

37
00:01:41,680 --> 00:01:47,040
このセルが縦横に何個あるかという定義がバージョンで表されています

38
00:01:47,040 --> 00:01:52,040
バージョンによってはQRコードに含められるデータ量が変わります

39
00:01:52,040 --> 00:01:55,959
バージョンは1から40まであり

40
00:01:55,959 --> 00:01:59,620
バージョンが大きくなるとその分セルの数も増えるので

41
00:01:59,620 --> 00:02:03,980
つまりそのままQRコードに含められるデータ量が大きくなります

42
00:02:03,980 --> 00:02:08,659
モードや誤り訂正レベルによっても結構変わるんですけれども

43
00:02:08,659 --> 00:02:13,240
例えば誤り訂正レベルMでバイナリーを含める場合

44
00:02:13,240 --> 00:02:15,439
バージョン1だと14バイトだけ

45
00:02:15,439 --> 00:02:18,520
バージョン5だと84バイト

46
00:02:18,520 --> 00:02:21,460
バージョン10では213バイト

47
00:02:21,460 --> 00:02:27,199
最大のバージョン40では2331バイトまで含めることができます

48
00:02:27,199 --> 00:02:31,080
QRコードの読み取り端末によっては

49
00:02:31,080 --> 00:02:35,319
指定のQRコードバージョンしか読み取れないということもあるのです

50
00:02:35,319 --> 00:02:43,099
さて冒頭のCIフィルターを使ったQRコード生成に戻ってみると

51
00:02:43,099 --> 00:02:45,060
皆様お気づきでしょうか

52
00:02:45,060 --> 00:02:51,360
これ含めるデータと誤り訂正レベルしか指定できなくね

53
00:02:51,360 --> 00:02:55,560
どうやって特定のQRコードバージョンにしたらいいんだ

54
00:02:55,560 --> 00:03:00,560
どう調べてもバージョンの指定方法なんてないぞ

55
00:03:00,560 --> 00:03:03,939
勝手にいろんなバージョンで生成されるし

56
00:03:03,939 --> 00:03:08,699
勝手にいろんなバージョンで生成されている

57
00:03:08,699 --> 00:03:14,360
これってQRコードに含めるデータのバイト量に応じて

58
00:03:14,360 --> 00:03:17,659
最適化してくれてるってことじゃねって

59
00:03:17,659 --> 00:03:19,240
気づきませんでした

60
00:03:19,240 --> 00:03:20,960
気づきました

61
00:03:20,960 --> 00:03:23,960
つまりこうじゃね

62
00:03:23,960 --> 00:03:27,900
バージョンの最大値に合わせて

63
00:03:27,900 --> 00:03:31,240
頭をゼロで埋めて長さ調整することで

64
00:03:31,240 --> 00:03:33,580
格納するデータは変えずに

65
00:03:33,580 --> 00:03:37,060
狙ったバージョンのQRコード画像を出力できる

66
00:03:37,060 --> 00:03:40,800
こうすることで同じバイナリでも

67
00:03:40,800 --> 00:03:44,199
狙ったバージョンのQRコードを生成することができました

68
00:03:44,199 --> 00:03:45,500
拍手

69
00:03:45,500 --> 00:03:48,939
ありがとうございます

70
00:03:48,939 --> 00:03:55,020
こうなると頑張れば他にもいろんなQRコード作れそうな気がしてきましたよね

71
00:03:55,020 --> 00:03:59,240
皆様フレームQRご存知でしょうか

72
00:03:59,240 --> 00:04:05,280
このフレームQRとはコード内に自由に使えるキャンバス領域を持ったQRコードです

73
00:04:05,280 --> 00:04:11,780
ただこちら個人でちゃんと作ろうとすると結構大変なんですけれども

74
00:04:11,780 --> 00:04:14,280
誤り訂正を利用して

75
00:04:14,280 --> 00:04:16,439
自治的に再現することができます

76
00:04:16,439 --> 00:04:19,220
これまでの話で

77
00:04:19,220 --> 00:04:22,379
誤り訂正レベルとかさらっと出てきたんですけれども

78
00:04:22,379 --> 00:04:24,180
名前だけ聞いて

79
00:04:24,180 --> 00:04:27,120
誤り訂正するんじゃねって感じだと思うので

80
00:04:27,120 --> 00:04:28,839
ちゃんと説明しようと思います

81
00:04:28,839 --> 00:04:32,939
QRコードの誤り訂正レベルは4種類あって

82
00:04:32,939 --> 00:04:35,040
それぞれの復元率は

83
00:04:35,040 --> 00:04:36,920
Lが7%

84
00:04:36,920 --> 00:04:38,879
Mが15%

85
00:04:38,879 --> 00:04:40,579
Qが25%

86
00:04:40,579 --> 00:04:42,500
Hが30%です

87
00:04:42,500 --> 00:04:46,500
QRコードをビローンと伸ばして

88
00:04:46,500 --> 00:04:48,879
ヘッダーやパディングを除いたところに

89
00:04:48,879 --> 00:04:50,120
データが入っています

90
00:04:50,120 --> 00:04:54,560
そこでデータを構成する最小の単位を

91
00:04:54,560 --> 00:04:56,279
コードワードと呼びます

92
00:04:56,279 --> 00:05:00,759
QRコードでは1コードワードが8ビットです

93
00:05:00,759 --> 00:05:04,839
データコードワードが10あったとして

94
00:05:04,839 --> 00:05:08,699
そのうち半分を訂正できるようにしたいと思います

95
00:05:08,699 --> 00:05:16,339
1コードワードを訂正するために誤り訂正コードワード数はその2倍必要となります

96
00:05:16,339 --> 00:05:21,120
なので誤り訂正コードワード数は10になります

97
00:05:21,120 --> 00:05:25,959
よって全コードワード20のうち5個が訂正可能なので

98
00:05:25,959 --> 00:05:34,180
訂正率は5割る20の25%となりこれはレベル9に相当します

99
00:05:36,079 --> 00:05:40,100
またバージョンが大きくなってデータ数が大きくなると

100
00:05:40,100 --> 00:05:43,540
全体を一つのブロックとして誤り訂正をすると

101
00:05:43,540 --> 00:05:46,040
偏りが激しくなってしまったりとか

102
00:05:46,040 --> 00:05:50,480
誤りが訂正されにくくなったりするような現象が起こるので

103
00:05:50,480 --> 00:05:53,420
Read Solomonブロックというものが登場します

104
00:05:53,420 --> 00:06:00,120
データコードワードを複数のブロックにまず分割します

105
00:06:00,939 --> 00:06:06,360
分割したデータコードワードそれぞれに対して誤り訂正を行っていきます

106
00:06:06,360 --> 00:06:12,620
この分割されたデータコードワードと誤り訂正コードワードのセットを

107
00:06:12,620 --> 00:06:14,519
リードソロモンブロックと呼びます

108
00:06:14,519 --> 00:06:22,019
この場合訂正率はリードソロモンブロック内のコードワードに対するものとなります

109
00:06:22,019 --> 00:06:26,699
というわけでバージョン1だとだいたいこんな感じです

110
00:06:27,360 --> 00:06:31,240
ただしこの訂正率は理論上の最低保証値なので

111
00:06:31,240 --> 00:06:34,199
実際にはもうちょい破損しても読み込めますし

112
00:06:34,199 --> 00:06:39,560
破損の仕方や読み込み側が結構頑張ってくれる場合もあるので

113
00:06:39,560 --> 00:06:42,079
読み込み側の性能にもよります

114
00:06:42,079 --> 00:06:47,360
GIGIFRAME QRの場合を作る際には

115
00:06:47,360 --> 00:06:50,379
画像で意図的に破損させる値は

116
00:06:50,379 --> 00:06:53,540
できるだけ理論値に沿っておいた方がいいでしょう

117
00:06:55,000 --> 00:06:57,839
では画像のサイズ感が分かったところで

118
00:06:57,839 --> 00:07:00,560
QRコードを生成して合成しようと思います

119
00:07:00,560 --> 00:07:03,720
まずは普通にQRコードを作ります

120
00:07:03,720 --> 00:07:08,899
合成にはUIグラフィックイメージレンダラーを使います

121
00:07:08,899 --> 00:07:12,800
CIフィルターを使って生成したQRコードには

122
00:07:12,800 --> 00:07:16,220
このようなクワイエットゾーンと呼ばれる

123
00:07:16,220 --> 00:07:19,879
周りをぐるっと囲む余白があるんですけれども

124
00:07:19,879 --> 00:07:22,720
QRの定義上では

125
00:07:22,720 --> 00:07:24,740
QRのクワイヤットゾーンには

126
00:07:24,740 --> 00:07:27,259
4セル分の余白を周りにつけるように

127
00:07:27,259 --> 00:07:28,779
定義されているんですけれども

128
00:07:28,779 --> 00:07:32,360
CIフィルターで生成されたQRコードには

129
00:07:32,360 --> 00:07:34,860
1セル分の余白しかつけられていないので

130
00:07:34,860 --> 00:07:38,100
左右合わせて2セル分大きくなった状態で

131
00:07:38,100 --> 00:07:40,199
画像サイズを計算するようにします

132
00:07:40,199 --> 00:07:43,560
位置を調整したり合成して

133
00:07:43,560 --> 00:07:46,560
フレームQRできました

134
00:07:46,560 --> 00:07:47,560
拍手

135
00:07:47,560 --> 00:07:51,360
ありがとうございます

136
00:07:51,360 --> 00:07:54,660
特に何も考えずに画像を置く場合

137
00:07:54,660 --> 00:07:58,579
誤り訂正レベルはできるだけ高めに設定しておけば

138
00:07:58,579 --> 00:08:00,800
その分復活する可能性も高いので

139
00:08:00,800 --> 00:08:02,560
そうしておいた方がいいと思います

140
00:08:02,560 --> 00:08:06,180
話はここまでにしようかなと思っていたんですけれど

141
00:08:06,180 --> 00:08:08,899
まだ10分も経っていないぐらいで

142
00:08:08,899 --> 00:08:10,779
思いの墓が早く終わってしまったので

143
00:08:10,779 --> 00:08:14,279
ここからは本当は入れようかなと思っていたんですけど

144
00:08:14,279 --> 00:08:15,860
ちょっと検証が間に合わなかった

145
00:08:15,860 --> 00:08:18,060
今取り組み中の話をします

146
00:08:18,060 --> 00:08:20,439
さっきので

147
00:08:20,439 --> 00:08:23,120
Gizframe QRできんじゃんって思って

148
00:08:23,120 --> 00:08:24,879
めっちゃ調子に乗った私は

149
00:08:24,879 --> 00:08:28,259
もっと特殊なQRコードを作れるんじゃないって思って

150
00:08:28,259 --> 00:08:30,519
さらに調子をこち始めました

151
00:08:30,519 --> 00:08:36,539
じゃあ分割QRコードとかって作れるのかなって思い始めました

152
00:08:36,539 --> 00:08:41,320
QRコードはバージョン40の容量以上のデータを

153
00:08:41,320 --> 00:08:43,200
持たせることはできないんですけれども

154
00:08:43,200 --> 00:08:47,500
分割して上限突破することができるんですね

155
00:08:47,500 --> 00:08:52,860
お薬手帳のQRコードなどで見たことがある人もいるかもしれません

156
00:08:52,860 --> 00:08:57,580
前にQRコードをビロンって伸ばしたときに

157
00:08:57,580 --> 00:08:59,519
ヘッダーがあるってちょっと触れました

158
00:08:59,519 --> 00:09:06,679
普通のQRだとヘッダーは4ビットだけモード支持子が入っているぐらいで

159
00:09:06,679 --> 00:09:08,240
あんまりデータ入ってないんですね

160
00:09:08,240 --> 00:09:11,419
分割QRコードの場合

161
00:09:11,419 --> 00:09:16,580
ヘッダーの冒頭4ビットに3を入れると

162
00:09:16,580 --> 00:09:21,480
それは分割QRコードだということと判断されます

163
00:09:21,480 --> 00:09:29,379
そして次の4ビットに分割されたQRの何番目かというページ番号

164
00:09:29,379 --> 00:09:35,860
その次の4ビットに最大のページ数を格納します

165
00:09:35,860 --> 00:09:38,799
最大のページ数4ビットなので

166
00:09:38,799 --> 00:09:42,419
つまり最大で16分割まで可能ということです

167
00:09:42,419 --> 00:09:46,360
次の4ビットにはパリティの上位

168
00:09:46,360 --> 00:09:47,360
4ビット

169
00:09:47,360 --> 00:09:50,960
その次にはパリティの解4ビットを入れます

170
00:09:50,960 --> 00:09:52,659
このパリティっていうのは

171
00:09:52,659 --> 00:09:56,360
連結するQRコード全てに共通しているもので

172
00:09:56,360 --> 00:10:01,000
全データに対するパリティを算出して使います

173
00:10:01,000 --> 00:10:04,659
なので連結QR読み取り側では

174
00:10:04,659 --> 00:10:08,840
連結用ID的な扱いをされます

175
00:10:08,840 --> 00:10:14,100
他はほとんど普通のQRと同じように作っていきます

176
00:10:14,100 --> 00:10:16,539
それだけ聞くと

177
00:10:16,539 --> 00:10:20,100
できなくもないんじゃねって思ってきませんか

178
00:10:20,100 --> 00:10:24,039
でもCiQRコードチェネレーターで

179
00:10:24,039 --> 00:10:27,220
ヘッダー情報をいじることってできるのかなみたいな

180
00:10:27,220 --> 00:10:27,460
はい

181
00:10:27,460 --> 00:10:29,799
できません

182
00:10:29,799 --> 00:10:32,059
調子に乗りすぎました

183
00:10:32,059 --> 00:10:33,179
悲しいですね

184
00:10:33,179 --> 00:10:36,639
なので手作りしようと思います

185
00:10:36,639 --> 00:10:39,100
ヘッダー情報をいじるだけなので

186
00:10:39,100 --> 00:10:42,039
とりあえず普通のQRコードができるようになれば

187
00:10:42,039 --> 00:10:43,200
できるはずだと思います

188
00:10:43,200 --> 00:10:48,299
Zebra CrossingというJava製のQRコードを生成するための

189
00:10:48,299 --> 00:10:50,559
オープンソースライブラリがあるんですけれども

190
00:10:50,559 --> 00:10:54,179
現在それはメンテナンスモードになっているので

191
00:10:54,179 --> 00:10:58,340
それをさらにC++で書き直されて

192
00:10:58,340 --> 00:11:04,480
いろいろ改善されたZebra Crossing C++というライブラリを参考にします

193
00:11:04,480 --> 00:11:06,799
とはいえC++

194
00:11:06,799 --> 00:11:09,279
私読めないなと思ったので

195
00:11:09,279 --> 00:11:12,299
現在Swiftへの翻訳を試みているところです

196
00:11:12,299 --> 00:11:16,240
これ全部解説すると今度は時間が収まりきらないので

197
00:11:16,240 --> 00:11:18,220
かなり回数まで説明します

198
00:11:18,220 --> 00:11:22,139
QRコードには4つのモードがあって

199
00:11:22,139 --> 00:11:23,820
モード指示子で指定します

200
00:11:23,820 --> 00:11:27,460
この中でこの8ビットモードを使うと

201
00:11:27,460 --> 00:11:29,460
バイナリーを格納することができます

202
00:11:29,460 --> 00:11:32,419
バイナリーを入れられるということは

203
00:11:32,419 --> 00:11:34,639
日本語以外でもどんな文字列でも

204
00:11:34,639 --> 00:11:36,279
入れることができるということです

205
00:11:36,279 --> 00:11:39,779
今回は一律でバイナリーモードを

206
00:11:39,779 --> 00:11:40,879
使用することにします

207
00:11:40,879 --> 00:11:43,159
これバイナリモードにすると

208
00:11:43,159 --> 00:11:47,759
QRコード生成側でいろいろ頑張って変換したりしなくてよくて

209
00:11:47,759 --> 00:11:50,659
バイナリをそのまま入れることができるので

210
00:11:50,659 --> 00:11:54,419
生成側としてはかなりサボれる便利なモードとなっています

211
00:11:54,419 --> 00:11:58,500
モードが決まったのでヘッダー上として

212
00:11:58,500 --> 00:12:01,559
最初の4ビットにモードCCを入れておきます

213
00:12:01,559 --> 00:12:05,039
そして次にバージョン決めます

214
00:12:05,039 --> 00:12:07,620
特定のバージョンを指定してもいいですし

215
00:12:07,620 --> 00:12:10,440
含めたいデータと誤り訂正レベルから

216
00:12:10,440 --> 00:12:12,899
ちょうどいいバージョンを取得してもいいです

217
00:12:12,899 --> 00:12:14,879
バージョンが決まったら

218
00:12:14,879 --> 00:12:16,960
バージョンの寸法に合わせて

219
00:12:16,960 --> 00:12:20,039
QRのマトリックスを作成します

220
00:12:20,039 --> 00:12:22,220
特にコードは書いてないんですけど

221
00:12:22,220 --> 00:12:25,240
私はこれはオプショナルのブールの

222
00:12:25,240 --> 00:12:27,279
二次元配列で表現しています

223
00:12:27,279 --> 00:12:30,820
あとで全部のセルが埋まっているかを

224
00:12:30,820 --> 00:12:32,220
確認しないといけないので

225
00:12:32,220 --> 00:12:34,700
最初は全てNILを入れています

226
00:12:34,700 --> 00:12:38,620
またデータの部分の終わりを

227
00:12:38,620 --> 00:12:41,159
正確に識別できるようにするために

228
00:12:41,159 --> 00:12:43,659
入力するデータのバイト数を

229
00:12:43,659 --> 00:12:47,320
含めたいデータのバイト数を求めて

230
00:12:47,320 --> 00:12:50,659
これをヘッダーに追加します

231
00:12:50,659 --> 00:12:54,980
このバイト数を入れるこのビット数は

232
00:12:54,980 --> 00:12:57,100
バージョンによって決まってます

233
00:12:57,100 --> 00:13:00,360
バージョン1のバイナリーモードでは

234
00:13:00,360 --> 00:13:05,059
ここ8ビット分の長さを入れるエリアがあります

235
00:13:05,059 --> 00:13:12,860
バージョンと誤り訂正レベルからデータ部分に格納できる最大数が取得することができます

236
00:13:12,860 --> 00:13:16,860
バージョン1で誤り訂正レベル9のとき

237
00:13:16,860 --> 00:13:20,799
格納可能数は13バイトです

238
00:13:20,799 --> 00:13:25,240
ただしこれはヘッダー情報も含んだ容量です

239
00:13:25,240 --> 00:13:32,480
ヘッダーが12ビットでデータコードワードが4バイトあって

240
00:13:32,480 --> 00:13:34,740
全部で13バイト入るんで

241
00:13:34,740 --> 00:13:38,340
これで60ビットぐらい余ってますね

242
00:13:38,340 --> 00:13:39,980
これをどうにかしたいです

243
00:13:39,980 --> 00:13:42,820
とりあえずコード後の最後に

244
00:13:42,820 --> 00:13:44,840
終端パターンとして

245
00:13:44,840 --> 00:13:48,059
0を4つ4ビット分入れます

246
00:13:48,059 --> 00:13:51,539
これでデータがどこまで入っているか

247
00:13:51,539 --> 00:13:52,960
っていうのを分かりやすくしてます

248
00:13:52,960 --> 00:13:57,460
そしてちょうど1バイトの境界になるように

249
00:13:57,460 --> 00:13:59,440
0で調整します

250
00:13:59,440 --> 00:14:04,360
するとちょうど残りは8のバイスのビット分が残るので

251
00:14:04,360 --> 00:14:10,000
パディングパターンとして16進数のECと16進数の11を

252
00:14:10,000 --> 00:14:12,440
交互に入れて埋めていきます

253
00:14:12,440 --> 00:14:16,759
これでデータ部分は全て埋まることができました

254
00:14:16,759 --> 00:14:22,440
データ部分に誤り訂正ブロックをインターリーブします

255
00:14:22,440 --> 00:14:28,279
これはDigiFrame QRで説明した誤り訂正をそのまま入れています

256
00:14:28,279 --> 00:14:33,519
これでメッセージに関する部分は全て揃いました

257
00:14:33,519 --> 00:14:37,039
次はマスクパターンを選択します

258
00:14:37,039 --> 00:14:41,039
マスクパターンとは白と黒のバランスを整えたりとか

259
00:14:41,039 --> 00:14:47,519
意味のある配列と似た配置になってしまいないようにするために使用します

260
00:14:47,519 --> 00:14:50,460
マスクパターンは8種類あって

261
00:14:50,460 --> 00:14:53,200
全てのマスクを試していて

262
00:14:53,200 --> 00:14:57,240
一番良さげなやつを選ぶという風に選んでいきます

263
00:14:57,240 --> 00:15:02,759
試すには一旦マトリックスを構築する必要があるので

264
00:15:02,759 --> 00:15:05,440
ちょっとマスク選択は一旦ステイで

265
00:15:05,440 --> 00:15:07,980
先にマトリックスをビルドしていきます

266
00:15:07,980 --> 00:15:13,659
冒頭で作った空のマトリックスを引っ張ってきて

267
00:15:13,659 --> 00:15:17,399
まずファインドパターンとセパレーターを生み込みます

268
00:15:17,399 --> 00:15:22,679
これは位置とか回転を検出できるやつですね

269
00:15:22,679 --> 00:15:27,019
必要であればアライメントパターンを生み込みます

270
00:15:27,019 --> 00:15:31,139
これバージョン1だとちょっと出ないんですけれども

271
00:15:31,139 --> 00:15:33,860
こんな感じのやつです

272
00:15:33,860 --> 00:15:40,279
バージョンごとにどこにアライメントパターンを出すかっていうのが決められているので

273
00:15:40,279 --> 00:15:43,600
指定の位置に5×5のパターンを埋め込んでいきます

274
00:15:43,600 --> 00:15:49,700
これは歪みによって生じるセルの位置ズレを補正してくれるものです

275
00:15:49,700 --> 00:15:54,340
続いてタイミングパターンを埋め込んでいきます

276
00:15:54,340 --> 00:15:59,080
白と黒のセルを交互に並べていくことで

277
00:15:59,080 --> 00:16:03,340
セルの大きさとセル全体の大きさを伝えて

278
00:16:03,340 --> 00:16:05,019
座標を決定していきます

279
00:16:05,019 --> 00:16:09,120
そしてフォーマット情報を埋め込みます

280
00:16:09,120 --> 00:16:13,279
フォーマット情報とは誤り訂正レベルとマスクパターンのことです

281
00:16:13,279 --> 00:16:16,440
このフォーマット情報については

282
00:16:16,440 --> 00:16:20,200
固定のポリ16芯数の537を使って

283
00:16:20,200 --> 00:16:23,240
BCH符号という誤り訂正符号を

284
00:16:23,240 --> 00:16:25,259
手法を使います

285
00:16:25,259 --> 00:16:27,919
いろいろあるんですけど

286
00:16:27,919 --> 00:16:31,019
これによって10ビットの誤り訂正符号を

287
00:16:31,019 --> 00:16:32,019
得ることができるので

288
00:16:32,019 --> 00:16:33,659
これをくっつけます

289
00:16:33,659 --> 00:16:37,779
これが全部ゼロになっちゃわないように

290
00:16:37,779 --> 00:16:40,799
特定のビットパターンの

291
00:16:40,799 --> 00:16:43,779
16進数の5412というのを

292
00:16:43,779 --> 00:16:46,860
履いたてき論理はを取って

293
00:16:46,860 --> 00:16:48,419
マスクをかけます

294
00:16:48,419 --> 00:16:52,919
これで15ビットのフォーマット情報ができたので

295
00:16:52,919 --> 00:16:54,480
埋め込んでいきます

296
00:16:54,480 --> 00:16:58,419
QRコードの一部が破損したとしても

297
00:16:58,419 --> 00:17:00,980
読み込めるように2箇所に置いていきます

298
00:17:00,980 --> 00:17:06,519
まず1つは左上のファインダーパターンのところと

299
00:17:06,519 --> 00:17:07,319
あともう1個

300
00:17:07,319 --> 00:17:11,640
左下と右上に半々ずつ入れていきます

301
00:17:11,640 --> 00:17:14,359
これでフォーマット情報が格納されました

302
00:17:14,359 --> 00:17:18,059
最後に誤り訂正符号を付けた

303
00:17:18,059 --> 00:17:20,579
データにマスクを適用して

304
00:17:20,579 --> 00:17:23,519
この空いてるところに埋め込んでいきます

305
00:17:23,519 --> 00:17:27,380
これで全てのセルが埋まったマトリックスができたので

306
00:17:27,380 --> 00:17:29,859
マスク選択に戻っていきます

307
00:17:29,859 --> 00:17:36,400
さっきのマトリックスを全部のマスク分作っていって

308
00:17:36,400 --> 00:17:40,720
それぞれのマトリックスに対して評価を行っていきます

309
00:17:40,720 --> 00:17:44,960
これらのこの4つのペナルティを合算して

310
00:17:44,960 --> 00:17:49,319
一番ペナルティが低かったものを最適なマスクとして選定します

311
00:17:49,319 --> 00:17:56,400
これで選定されたマスクで再度マトリックスを構築すれば

312
00:17:56,400 --> 00:18:01,279
QRコードの元になるマトリックスが完成するというところです

313
00:18:01,279 --> 00:18:07,099
このマトリックスブールの二次元配列で私作ってるんですけれども

314
00:18:07,099 --> 00:18:11,319
どうやって画像にしたらいいかなっていうのが今の悩みなので

315
00:18:11,319 --> 00:18:13,480
何かアイデアがあれば

316
00:18:13,480 --> 00:18:15,339
Ask the Speakerで教えてください

317
00:18:15,339 --> 00:18:19,359
最後にぜひ読み取ってほしい

318
00:18:19,359 --> 00:18:20,940
QRコードがこちらです

319
00:18:20,940 --> 00:18:32,619
11月2日に

320
00:18:32,619 --> 00:18:34,799
鎌倉でスイストコミュニティの

321
00:18:34,799 --> 00:18:35,980
イベントをやりますので

322
00:18:35,980 --> 00:18:37,619
ぜひ遊びに来てください

323
00:18:37,619 --> 00:18:39,240
ありがとうございました

324
00:18:41,319 --> 00:18:47,799
ありがとうございました

325
00:18:47,799 --> 00:18:50,339
それではQ&Aに入りたいと思います

326
00:18:50,339 --> 00:18:52,740
コメントやご質問のある方がいらっしゃいましたら

327
00:18:52,740 --> 00:18:53,880
手を挙げてお知らせください

