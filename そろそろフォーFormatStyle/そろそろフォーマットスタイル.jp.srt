1
00:00:00,000 --> 00:00:03,360
そろそろフォーマットスタイル

2
00:00:03,360 --> 00:00:08,960
タナカリョーガ

3
00:00:16,200 --> 00:00:23,520
はい それではそろそろフォーマットスタイルというタイトルで発表しますよろしくお願い致します

4
00:00:23,520 --> 00:00:26,720
発表は私 タナカリョーガが務めさせていただきます

5
00:00:26,720 --> 00:00:30,720
普段はこちらのオレンジ色のアイコンで活動しております

6
00:00:30,720 --> 00:00:34,020
新しいiPhoneの色と同じオレンジ色ですね

7
00:00:34,020 --> 00:00:37,120
個人開発でSWIFTを使ったアプリケーションを開発したり

8
00:00:37,120 --> 00:00:43,520
あとは株式会社DNAでもiOSアプリケーションのデベロッパーを普段しております

9
00:00:43,520 --> 00:00:49,120
過去 このiOSDC Japanでは3回 いずれも40分のレギュラートークをしておりまして

10
00:00:49,120 --> 00:00:53,320
今回は4回目になります

11
00:00:53,520 --> 00:00:58,520
私の初めての登壇となったのが2021年のトークなんですけれども

12
00:00:58,520 --> 00:01:00,120
こちらのタイトルが

13
00:01:00,120 --> 00:01:06,320
あらゆる情報を楽に正しくストリングにフォーマットするというものでした

14
00:01:06,320 --> 00:01:08,520
当時のアーカイブを見てみますと

15
00:01:08,520 --> 00:01:15,720
様々なデータをフォーマッターを使ってストリングに変換していくという内容でした

16
00:01:15,720 --> 00:01:21,520
その年に日本で開催された国際的なスポーツの開会式のひと幕みたいなデザインで

17
00:01:21,520 --> 00:01:24,720
当時発表してました

18
00:01:24,720 --> 00:01:29,720
その中で2021年で最新のiOSのバージョンであった

19
00:01:29,720 --> 00:01:35,120
iOS15の新機能について少しだけ触れていました

20
00:01:35,120 --> 00:01:36,720
当時のスクリーンショットがこちらです

21
00:01:36,720 --> 00:01:39,720
もしかしたら後ろの方 見えないかもしれないんですけども

22
00:01:39,720 --> 00:01:42,720
Appleの新しい機能に関するドキュメントでは

23
00:01:42,720 --> 00:01:44,720
よくノーオーバービューアベイラブルと

24
00:01:44,720 --> 00:01:47,720
何も書いてないみたいなドキュメントが出てくるんですが

25
00:01:47,720 --> 00:01:54,720
当時そうなっていたのが本日のテーマであるフォーマットスタイルです

26
00:01:54,720 --> 00:01:58,720
フォーマットスタイルはiOS15以降で使用できる仕組みです

27
00:01:58,720 --> 00:02:01,720
リリースされた2021年の当時は

28
00:02:01,720 --> 00:02:05,720
例えばミニマムデプロイメントターゲットなどの関係で

29
00:02:05,720 --> 00:02:09,720
実プロダクトへの投入というのは難しかったかもしれないんですけれども

30
00:02:09,720 --> 00:02:11,720
あれから4年が経ちまして

31
00:02:11,720 --> 00:02:16,720
あとは先日iOS26がリリースされた今

32
00:02:16,720 --> 00:02:19,720
Appleの資料によれば多くのユーザーのデバイスが

33
00:02:19,720 --> 00:02:22,720
すでにフォーマットスタイルをサポートしているという

34
00:02:22,720 --> 00:02:25,720
環境になっていることが分かります

35
00:02:25,720 --> 00:02:27,720
まさにフォーマットスタイルについて触れる

36
00:02:27,720 --> 00:02:32,720
ぴったりなタイミングかなと思って今回発表させていただきます

37
00:02:32,720 --> 00:02:36,720
本トークはSwiftやiOSアプリケーション開発における

38
00:02:36,720 --> 00:02:42,720
データのフォーマットについてこれから学ぼうとしている方

39
00:02:42,720 --> 00:02:45,720
従来のフォーマッターは使ったことがあるけれど

40
00:02:45,720 --> 00:02:50,720
この新しいフォーマットスタイルにはちょっと慣れていないという方

41
00:02:50,720 --> 00:02:52,720
あとは標準には用意されていない

42
00:02:52,720 --> 00:02:55,720
独自のフォーマットスタイルの作り方のサンプルを

43
00:02:55,720 --> 00:03:00,720
知りたい方に向けて発表します

44
00:03:00,720 --> 00:03:06,720
それでは改めましてデータのフォーマットとは何でしょうか

45
00:03:06,720 --> 00:03:09,720
ここに一つスクリーンショットがあります

46
00:03:09,720 --> 00:03:12,720
画面中央に本トークのタイトルと

47
00:03:12,720 --> 00:03:17,720
あとは開始日時が表示されています

48
00:03:17,720 --> 00:03:21,720
Swift UIのコードで示すとこのようになっています

49
00:03:21,720 --> 00:03:29,720
今はトークの開始日時の部分がテキストに直接文字列で書かれていますね

50
00:03:29,720 --> 00:03:34,720
このタイトルや開始日時がビューの外から与えられるようにします

51
00:03:34,720 --> 00:03:38,720
さらにSwiftには日時を取り扱うことのできる

52
00:03:38,720 --> 00:03:40,720
デイトという型がありますから

53
00:03:40,720 --> 00:03:45,720
このデイトのプロパティの型を今のストーリング型から

54
00:03:45,720 --> 00:03:48,720
デイト型で渡されてくるようにします

55
00:03:48,720 --> 00:03:51,720
しかしこのままのコードですと

56
00:03:51,720 --> 00:03:53,720
Swift UIのテキストのイニシャライザに

57
00:03:53,720 --> 00:03:57,720
このデイト型を渡すことはできないというエラーが発生して

58
00:03:57,720 --> 00:04:02,720
ビルドが通らなくなってしまいます

59
00:04:02,720 --> 00:04:04,720
このビルドエラーを解消するためには

60
00:04:04,720 --> 00:04:09,720
型でいうとこのデイト型から何らかの手段を使って

61
00:04:09,720 --> 00:04:12,720
ストーリング型へと変換し

62
00:04:12,720 --> 00:04:16,720
すいません、Swift UIのテキストへ渡すようにすると良さそうです

63
00:04:16,720 --> 00:04:18,720
こうですね

64
00:04:18,720 --> 00:04:25,720
それではこの変換を行う方法について考えてみようと思います

65
00:04:25,720 --> 00:04:27,720
Swiftのデイト型には

66
00:04:27,720 --> 00:04:32,720
TimeIntervalSynthReferenceDateというプロパティがあります

67
00:04:32,720 --> 00:04:37,720
これは世界標準時の2001年1月1日0時0分から

68
00:04:37,720 --> 00:04:43,720
何秒の差分があるかを示す値が入っています

69
00:04:43,720 --> 00:04:46,720
日本時間の今日の13時の場合

70
00:04:46,720 --> 00:04:54,720
7億8千3万3千6百秒という数字が入っています

71
00:04:54,720 --> 00:04:59,720
それからさらに年、月、日、時、分の

72
00:05:00,000 --> 00:05:04,800
数字を、指則演算を駆使して割り出すというのが良いでしょうか。

73
00:05:06,800 --> 00:05:10,000
ただ、西暦の年を計算できたとしても、

74
00:05:10,000 --> 00:05:14,200
iOSではユーザーがこれを和暦に設定することもできます。

75
00:05:14,600 --> 00:05:17,200
この場合はどのように対応すると良いでしょうか。

76
00:05:19,400 --> 00:05:26,600
さらに英語の環境では、そもそも月に当たるのが数字ではなく決まった英単語になりますし、

77
00:05:26,800 --> 00:05:30,800
あとは24時間表記ではなくて12時間表記が好まれるかもしれません。

78
00:05:33,000 --> 00:05:37,800
何かしらのデータがあって、それを文字列に変換しようとするときに、

79
00:05:38,200 --> 00:05:42,400
ユーザーの言語や地域、文化などを考慮して、

80
00:05:42,400 --> 00:05:47,800
その人にとって最も馴染みのある形式で伝えることができるのがベストかなと思います。

81
00:05:48,600 --> 00:05:51,600
このことをデータのフォーマットと言っています。

82
00:05:52,600 --> 00:06:01,600
iOSのアプリケーションの開発のような、世界中の多様なユーザーに情報を届けるためのインターフェースを作っている私たちにとって、

83
00:06:01,600 --> 00:06:07,600
データを適切な形にフォーマットするというのは、避けては通れない非常に重要なものです。

84
00:06:08,200 --> 00:06:14,200
一つのアプリの中でも、いろいろな場所で繰り返しデータをフォーマットすることがあるでしょう。

85
00:06:15,200 --> 00:06:21,200
一方で、このデータのフォーマットについては無数の考慮すべき事柄があるため、

86
00:06:21,200 --> 00:06:27,200
いついかなるときも期待通りに動作させるというのは非常に難しいものです。

87
00:06:28,200 --> 00:06:34,200
そこで、よく使われるデータについては、自分でフォーマット処理を書かなくても良いように、

88
00:06:34,200 --> 00:06:41,200
SwiftやOSのフレームワークにはあらかじめデータフォーマッティングのAPIが用意されています。

89
00:06:41,200 --> 00:06:47,200
それでは、データのフォーマットを試してみましょう。

90
00:06:47,200 --> 00:06:55,200
せっかくIOSアプリケーションの開発の現場でも、徐々にコーディングインテリジェンスの活用例が見られてきた頃かなと思いますので、

91
00:06:55,200 --> 00:07:00,200
ここは一つ、とある大規模言語モデル、LLMに聞いてみましょう。

92
00:07:00,200 --> 00:07:08,200
Xコードでエラーになっているところを選びまして、このGenerate Fix for Issueのボタンを押してみます。

93
00:07:09,200 --> 00:07:13,200
すると、何らかLLMから返事がありました。

94
00:07:13,200 --> 00:07:18,200
このようにコードを変更してくれたみたいですね。

95
00:07:18,200 --> 00:07:23,200
ここでは、DateFormatterというのが使われています。

96
00:07:23,200 --> 00:07:30,200
このDateFormatterの親クラスであるNSFormatterは、Swiftが登場するよりも前、

97
00:07:30,200 --> 00:07:36,200
Objective-Cの時代から存在するデータフォーマッティングのAPIです。

98
00:07:36,200 --> 00:07:42,200
ファンデーションにはNSFormatterを継承する13種類のフォーマッターが存在しており、

99
00:07:42,200 --> 00:07:49,200
日時の他にも数値や人の名前、重さや長さのような計測値など、

100
00:07:49,200 --> 00:07:53,200
様々な種類のデータのフォーマットに対応しています。

101
00:07:53,200 --> 00:08:02,200
2016年9月にリリースされたSwift3からは、呼び出し時にNSのセット字が不要となり、このような見た目になりました。

102
00:08:02,200 --> 00:08:08,200
LLMが書いたのは、このDateFormatterを使ったコードでした。

103
00:08:08,200 --> 00:08:12,200
このフォーマッターは非常に強力で柔軟なAPIですが、

104
00:08:12,200 --> 00:08:18,200
特にSwiftの現代的な開発パラダイムですとか、安全性を重視する観点から見ますと、

105
00:08:18,200 --> 00:08:23,200
いくつか注意しなければならない点がありました。

106
00:08:23,200 --> 00:08:28,200
それでは、DateFormatterを引き続き例にしてお話しします。

107
00:08:28,200 --> 00:08:34,200
ここでは昨年末ですね、とくしこしの直前の時刻をDateプロパティとして用意し、

108
00:08:34,200 --> 00:08:38,200
このデータをフォーマットしてみることにしましょう。

109
00:08:38,200 --> 00:08:47,200
クラスであるDateFormatterのインスタンスを作り、日付時刻のフォーマットの形式を指定します。

110
00:08:47,200 --> 00:08:52,200
それらが済んだら、インスタンスメソッドであるstringFromを使って、

111
00:08:52,200 --> 00:08:55,200
ストリング型にフォーマットされた結果を得ます。

112
00:08:55,200 --> 00:09:01,200
命令的なプログラミングに馴染みがあれば、非常に読みやすいコードかなと思います。

113
00:09:01,200 --> 00:09:07,200
もしフォーマットした結果において、この時刻の部分が不要だという場合は、

114
00:09:07,200 --> 00:09:13,200
このTimeStyleの部分にNoneを指定するといった具合にカスタマイズできます。

115
00:09:13,200 --> 00:09:22,200
では、年と月の部分だけ欲しくて、この日はいらないという場合にはどのようにすればよいでしょうか。

116
00:09:22,200 --> 00:09:29,200
DateFormatterには、より柔軟にフォーマットの形式を指定できるDateFormatというプロパティがあります。

117
00:09:29,200 --> 00:09:37,200
今回は年と月だけ欲しいので、この大文字のYと大文字のMを使って、

118
00:09:37,200 --> 00:09:43,200
あとはその後ろに年と月という漢字も出して欲しいので、加えておきます。

119
00:09:43,200 --> 00:09:47,200
それではインスタンスメソッドのstringFromでこれをフォーマットしますと、

120
00:09:47,200 --> 00:09:53,200
年の数字が2024ではなく2025となってしまいました。

121
00:09:53,200 --> 00:09:59,200
これはどこに誤りがあるのでしょうか。

122
00:10:00,000 --> 00:10:03,400
デイトフォーマットプロパティに与える文字列というのは、

123
00:10:03,400 --> 00:10:07,600
ユニコードの技術標準の使用を用いるということになっています。

124
00:10:07,600 --> 00:10:12,400
そのユニコードの使用にある表に従って、

125
00:10:12,400 --> 00:10:15,400
デイトフォーマットの文字列を組み立てていく必要があります。

126
00:10:15,400 --> 00:10:18,600
すっごい大きな表で、

127
00:10:18,600 --> 00:10:21,600
スクリーンには何書いているかもはや分からないんですけれども、

128
00:10:21,600 --> 00:10:24,800
先ほどのデイトフォーマットのこの誤りは、

129
00:10:24,800 --> 00:10:27,800
この念を示すYという文字、

130
00:10:27,800 --> 00:10:32,800
これが大文字ではなく小文字にするべきだったというものでした。

131
00:10:32,800 --> 00:10:35,800
これでめでたしといきたいところですけれども、

132
00:10:35,800 --> 00:10:38,800
この後、例えば英語の環境で、

133
00:10:38,800 --> 00:10:43,800
ディッセンバー2024のような表記もサポートするとなった場合には、

134
00:10:43,800 --> 00:10:46,800
今度はどうしましょうか。

135
00:10:46,800 --> 00:10:52,800
現状出すとデイトフォーマットに直接年とか月みたいな漢字も入ってしまっていますし、

136
00:10:52,800 --> 00:10:56,800
あとは日本語は年の月に月がきますが、

137
00:10:56,800 --> 00:11:01,800
この英語の場合は月が来て年が来るっていう違いもあります。

138
00:11:01,800 --> 00:11:05,800
このようにたとえ日時のフォーマットだけをとっても、

139
00:11:05,800 --> 00:11:08,800
考慮すべきパターンが無数にあり、

140
00:11:08,800 --> 00:11:12,800
あとはフォーマットの形式の文字列指定にミスがあったとしても、

141
00:11:12,800 --> 00:11:15,800
プログラムを実行するまで結果が分かりません。

142
00:11:15,800 --> 00:11:20,800
ですからこのデイトフォーマットに直接文字列を指定してはいけません。

143
00:11:20,800 --> 00:11:24,800
これはAppleのWWDCのセッションでも、

144
00:11:25,800 --> 00:11:29,800
ほぼ必ず意図しない結果になってしまうとして、

145
00:11:29,800 --> 00:11:35,800
デイトフォーマットに文字列を直接指定するなとはっきり説明されています。

146
00:11:35,800 --> 00:11:38,800
大事なことなのでもう一回言うんですけれども、

147
00:11:38,800 --> 00:11:41,800
非常に古い資料ではこれしか方法がないということで、

148
00:11:41,800 --> 00:11:45,800
デイトフォーマットに直接指定する方法が紹介されていたり、

149
00:11:45,800 --> 00:11:49,800
あとはコーディングインテリジェンスのLLMがこの方法を提案してくるかもしれませんが、

150
00:11:49,800 --> 00:11:51,800
これは使わないでください。

151
00:11:51,800 --> 00:11:57,800
これはAgent2 Markdownとかに書いておくといいと思います。

152
00:11:57,800 --> 00:11:59,800
ちょっと話が逸れてしまいましたが、

153
00:11:59,800 --> 00:12:02,800
はじめのコードに戻ります。

154
00:12:02,800 --> 00:12:04,800
改めてこのコードを読みますと、

155
00:12:04,800 --> 00:12:08,800
SwiftUIのView Protocolによるボディの中で、

156
00:12:08,800 --> 00:12:12,800
FormattedDateというのを読んでまして、

157
00:12:12,800 --> 00:12:17,800
このFormattedDateはComputed Propertyで呼び出されるたびに、

158
00:12:17,800 --> 00:12:20,800
デイトフォーマッターのインスタンスを生成し、

159
00:12:20,800 --> 00:12:26,800
デイトスタイル、タイムスタイルの指定も行ってフォーマットしています。

160
00:12:26,800 --> 00:12:33,800
SwiftUIのViewのボディはフレームワーク側から何度も呼ばれる可能性があります。

161
00:12:33,800 --> 00:12:39,800
呼ばれるたびにこのフォーマッターのインスタンスを都度生成しています。

162
00:12:39,800 --> 00:12:46,800
このフォーマッターのインスタンスの生成というのは非常にコストが高いということが知られています。

163
00:12:46,800 --> 00:12:52,800
このコストが高いということについての言及というのは様々な方がされているんですけれども、

164
00:12:52,800 --> 00:12:57,800
例えばこちらのAppleの今年のWWDCのセッションも見てみます。

165
00:12:57,800 --> 00:13:03,800
ヒッチやハングといったパフォーマンスが悪いSwiftUIのアプリケーションを

166
00:13:03,800 --> 00:13:06,800
インスルメンツによって計測したところ、

167
00:13:06,800 --> 00:13:10,800
先ほど示したコードのようにこのViewのボディから何度も

168
00:13:10,800 --> 00:13:15,800
フォーマッターのインスタンスを生成している箇所が見つかったというお話でした。

169
00:13:16,800 --> 00:13:22,800
それへの対応策としてフォーマッターを使ったこのフォーマット5の文字列の生成、

170
00:13:22,800 --> 00:13:28,800
このストリングフロムの呼び出しを別な場所で事前にまとめて実行するようにしたり、

171
00:13:28,800 --> 00:13:33,800
あとはそもそもこのフォーマッターのインスタンスの生成回数が最小限に済むように

172
00:13:33,800 --> 00:13:37,800
キャッシュしておくという方法が紹介されていました。

173
00:13:40,800 --> 00:13:43,800
ではここまでの内容を1回まとめたいと思います。

174
00:13:44,800 --> 00:13:50,800
これまでのフォーマッターというのは非常に高機能でカスタマイズ性の高いものでした。

175
00:13:50,800 --> 00:13:55,800
ただしいくつかのパターンでは仮にそのカスタマイズに誤りがあっても

176
00:13:55,800 --> 00:14:00,800
コンパイル時に気づくことはできず、実際に動かして確認するといった必要がありました。

177
00:14:01,800 --> 00:14:05,800
またフォーマッターのインスタンスを生成するコストや、

178
00:14:05,800 --> 00:14:11,800
あとは説明は省略したんですけれどもプロパティの変更のコストも高いということが知られています。

179
00:14:12,800 --> 00:14:20,800
そのためそれらの回数を減らすために自分でキャッシュ機構を実装するなどして対応を行うというのがベストプラクティスでした。

180
00:14:21,800 --> 00:14:27,800
あとはスイフトは値型がよく使われますが、このフォーマッターは参照型です。

181
00:14:27,800 --> 00:14:32,800
そのキャッシュの共有を行う際もそれを意識する必要があります。

182
00:14:33,800 --> 00:14:40,800
あとはスレッドセーフであるかどうかというのも今のスイフトコンカレンシーの時代には強く意識する必要があるでしょう。

183
00:14:41,800 --> 00:14:47,800
そしてスイフトUIなどで流行っている宣言型ではなく、命令型のAPIデザインとなっています。

184
00:14:50,800 --> 00:14:57,800
これまでですね、フォーマッターについてどれが良いとか悪いとかを深掘るつもりはないんですけれども、

185
00:14:57,800 --> 00:14:59,800
ただそれらの姿勢が

186
00:15:00,000 --> 00:15:09,840
考え方を活かしながら、今のSwiftの時代にふさわしい新たなインターフェースとして登場したのがフォーマットスタイルです。

187
00:15:10,840 --> 00:15:21,080
このフォーマットスタイルというのは正確にはプロトコルの名前になっています。 iOS 15以降で利用可能で、特定のデータ型を別な型、

188
00:15:21,080 --> 00:15:28,960
例えば文字列、ストリング型ですね、に変換するためのインターフェースを定義するものになっています。

189
00:15:28,960 --> 00:15:40,920
さまざまな用途に応じたフォーマットのスタイルがデフォルトで用意されていまして、 iOS 26までには46のフォーマットスタイルが存在しています。

190
00:15:41,400 --> 00:15:51,080
こちらが従来のフォーマッターで書かれたコードですが、これをフォーマットスタイルを用いるように変更しますと、このようになります。

191
00:15:51,080 --> 00:15:55,320
コードが非常に少なくなりましたね。

192
00:15:55,440 --> 00:16:03,440
利用者のコードを見比べてみましょう。これまで存在していたデイトフォーマッターの記述がそもそも消えました。

193
00:16:03,440 --> 00:16:14,120
またこれまではフォーマッター側に存在するメソッドの引数にデータを渡していましたが、

194
00:16:14,120 --> 00:16:22,600
フォーマットスタイルを使う方法ではデータに対してformattedというメソッドをつけるというように変わりました。

195
00:16:23,480 --> 00:16:35,040
データに応じたフォーマッターのインスタンスを自分で作ることなく、ただシンプルにデータに対してformattedをつけることだけで簡単にフォーマットできます。

196
00:16:35,480 --> 00:16:46,120
このformattedメソッドの中で詳細なスタイルの指定をすることもできます。 指定しない場合はデフォルトの実装が使用されます。

197
00:16:46,520 --> 00:16:57,920
柔軟なスタイル指定というのも、先ほどのローマ字の小文字のYがどうで、大文字のMがどうで、みたいな複雑な文字列のスタイルのルールっていうのを覚えることなく、

198
00:16:57,920 --> 00:17:06,880
年が欲しいからイヤーをつけて、月が欲しいからマウスをつけてと、このコード補完を効かせながら安全に書くことができます。

199
00:17:06,880 --> 00:17:12,440
あとは後から読んだ時の可読性も非常に高いかなと思います。

200
00:17:13,360 --> 00:17:22,240
フォーマットスタイルはこのSwiftのために設計されていて、この外側のインターフェースの部分は100%Swiftで書かれています。

201
00:17:22,240 --> 00:17:31,760
またフォーマッターがクラス、参照型であったのに対し、フォーマットスタイルは構造体、値型で作るのが基本ということになり、

202
00:17:31,760 --> 00:17:39,520
スタック上での割り当てとかコピーオンライトとか、コンパイラーによる最適化の恩恵を受けやすいだろうという利点があります。

203
00:17:39,640 --> 00:17:43,400
スタイルの指定はカターン安全に行うことができて、

204
00:17:43,400 --> 00:17:50,520
フォーマットスタイルの内部で使用されているフォーマッターのインスタンスはフレームワーク側で自動的にキャッシュされます。

205
00:17:50,520 --> 00:18:01,320
先ほどの手動でキャッシュするみたいなことを考えなきゃいけないというところから解放されて、パフォーマンス上のメリットも一定程度享受できそうです。

206
00:18:01,320 --> 00:18:10,600
あとは、流行りの宣言型のインターフェースとともに、現代の人々から使いやすくなったというのが、このフォーマットスタイルです。

207
00:18:11,680 --> 00:18:18,440
従来のこのフォーマッターと、このフォーマットスタイルのインターフェースなどの違いが分かったところで、

208
00:18:18,440 --> 00:18:24,920
プロトコルで定義されているフォーマットスタイルのルールについて紹介します。

209
00:18:25,200 --> 00:18:41,640
フォーマットスタイルプロトコルに適合する方は、プライマリーアソシエイティットタイプとして、フォーマットの入力側の方と出力側の方がそれぞれ何であるかというのを指定する必要があります。

210
00:18:41,640 --> 00:18:50,120
そして実際に入力された値を使ってフォーマットを行い、結果を出力するメソッドの実装が必要です。

211
00:18:50,640 --> 00:18:57,680
本日の最初に示した、このデイト型からストリング型へのフォーマットを行う場合、

212
00:18:57,680 --> 00:19:07,520
そのフォーマットインプットというのがデイト型になって、フォーマットアウトプットというのがストリング型ということになります。

213
00:19:08,320 --> 00:19:18,400
ここからは、iOS26までに含まれているすぐに使えるフォーマットスタイルの全種類について列挙してみようと思います。

214
00:19:18,400 --> 00:19:25,360
ただ、これまでは日時のフォーマットについてお話ししてきましたが、

215
00:19:25,360 --> 00:19:30,360
今のiOSには他のデータに対応したフォーマットスタイルというのも存在しています。

216
00:19:30,360 --> 00:19:38,480
ただ、これをすべて一度に覚えることは難しいですし、ここからどんどん列挙するとおそらく眠くなってしまうので、

217
00:19:38,480 --> 00:19:44,800
もしよろしければ、この後公開される資料ですとかアーカイブなどで振り返りに来ていただければと思います。

218
00:19:45,800 --> 00:19:49,800
ではまず、日時や時間について見ていきましょう。

219
00:19:49,800 --> 00:19:57,800
デートフォーマットスタイルというのは日付と時刻のフォーマットを行う最も基本的なスタイルです。

220
00:19:57,800 --> 00:19:59,800
デート型のプロパティ。

221
00:20:00,000 --> 00:20:13,000
フォーマッティングをつけるとこのフォーマットスタイルが使われます。 デイト引数とタイム引数でスタイルを細かく指定でき、様々な表現をすることができます。

222
00:20:13,000 --> 00:20:22,200
また、メソッドチェーンを使って年、月、日、時、分、秒、あとはタイムゾーンなども詳細にしていきます。

223
00:20:22,200 --> 00:20:31,040
フィールドの順序というのが最終的な出力に影響しません。 OS がロケルに応じて適切に配置してくれます。

224
00:20:31,040 --> 00:20:45,080
例えばこの上の例はアメリカ英語のように月、日、年というふうな順番で指定しているんですけれども、 これを日本の日本語環境で動かすと、ちゃんと年、月、日と表示されます。

225
00:20:45,080 --> 00:20:55,600
その他にも月とか曜日の省略形表示であるとか、 あとは数字が一桁の場合にゼロでパリングを埋めるみたいな処理もしてできます。

226
00:20:56,400 --> 00:21:09,160
続いて、デイト ISO 8601 フォーマットスタイルというのがあります。 フォーマッティングのところで ISO 8601 と書くことで、これはサーバーとのデータ通信など

227
00:21:09,160 --> 00:21:17,240
ISO 8601 という仕様がありますが、 その日時が必要な場合に非常に便利に使えます。

228
00:21:18,360 --> 00:21:29,920
これにタイムゾーンの情報をつけたり、先ほどのデイトフォーマットのように、 欲しい要素をメソッドチェーンで書いて出力する要素を細かく指定できます。

229
00:21:30,280 --> 00:21:38,240
ISO 26 では、このデイトコンポーネンツの方にも ISO 8601 形式のスタイルが用意されました。

230
00:21:40,960 --> 00:21:50,240
こちらも新しく導入されたものになりますが、 HTTP の RFC 9110 に準拠したフォーマットスタイルというのもあります。

231
00:21:50,720 --> 00:21:58,360
こちらはウェブの通信において、日時のヘッダーとかを取り扱う際に 格段に容易になるかなと思います。

232
00:22:00,320 --> 00:22:03,440
これも同様にデイトコンポーネンツ版が存在します。

233
00:22:05,960 --> 00:22:12,400
出力形式をもっとカスタマイズしたい場合は、 デイトバーベリタムフォーマットスタイルを使います。

234
00:22:13,920 --> 00:22:18,280
先に述べた従来のデイトフォーマッターの デイトフォーマットプロパティのように、

235
00:22:18,720 --> 00:22:22,320
カスタムのフォーマットを文字列で直接指定できるスタイルです。

236
00:22:23,120 --> 00:22:28,320
ただ、このデイトフォーマットストリングによって提供される ストリングインターポレーションですね。

237
00:22:28,320 --> 00:22:33,640
文字列補完項群によって、 タイプセーフにフォーマットをしてできるようになっています。

238
00:22:34,640 --> 00:22:45,040
例えば、ここのように年号と年、月、日、往、 ピリオードでつなぐことが求められる時数のフォーマットというのがあるんですけれども、

239
00:22:45,520 --> 00:22:50,120
これをフォーマティでロケルとかタイムゾーンと一緒に指定すれば、

240
00:22:50,120 --> 00:23:02,920
iOSデバイスのカレンダーが正歴でも悪歴でも、 確実にこの例はR07.09.20のように時数の規格にあった出力が得られます。

241
00:23:06,320 --> 00:23:13,720
続きまして、このデイトインターワルフォーマットスタイルは、 二つのデイトの間の期間をフォーマットするためのスタイルです。

242
00:23:14,720 --> 00:23:22,720
デイトの範囲型を入力として受け取りまして、 ユーザーのロケルに合わせた自然な形で期間をフォーマットします。

243
00:23:23,720 --> 00:23:36,720
例えば、時刻は省略して日付の期間だけを出力するときに、 日本の日本語環境であれば19日から21日とナミセン、ナミダッシュで出力されて、

244
00:23:37,720 --> 00:23:44,720
アメリカ英語の環境であればセプテンバー19でダッシュ21という感じで出力されます。

245
00:23:46,720 --> 00:23:53,720
そしてデイトコンポーネンツフォーマットスタイルというのもありまして、 これは日付のコンポーネント間の差をフォーマットします。

246
00:23:54,720 --> 00:24:01,720
二つの日付の間を二日であるとか二日と二時間のように、 人間が読みやすい形式で表示します。

247
00:24:02,720 --> 00:24:06,720
こちらもスタイル、引数で出力スタイルをカスタマイズすることもできます。

248
00:24:10,720 --> 00:24:14,720
似たようなものでデイトリラティブフォーアットスタイルというのもあります。

249
00:24:15,720 --> 00:24:21,720
こちらは現在の時刻を基準とした相対的な日時をフォーマットするためのスタイルです。

250
00:24:23,720 --> 00:24:29,720
ネイムドスタイルを使用すると、 先月、今月、来月といった自然言語の表現が得られます。

251
00:24:31,720 --> 00:24:36,720
ヌメリックスタイルにすると、 1ヶ月後のように数値での相対表現ができます。

252
00:24:38,720 --> 00:24:45,720
非単位の相対表現もできるようになってまして、 おととい、きのう、きょう、あす、あさってというような表現が、

253
00:24:45,720 --> 00:24:48,720
ロケールに応じて自動的に適用されます。

254
00:24:49,720 --> 00:24:56,720
このフォーマットスタイルは現在時刻を基準として 相対的なものを出力するんですけれども、

255
00:24:56,720 --> 00:25:00,720
その基準を現在の時刻を基準として使っています。

256
00:25:00,000 --> 00:25:07,120
ではなくて任意の時刻にしたい場合はこのDateAnchoredRelativeFormatStyleの方を使います。

257
00:25:07,120 --> 00:25:18,440
特定の日時をアンカーとして指定して入力された日時を、 その基準として相対的なフォーマットを行います。

258
00:25:18,440 --> 00:25:30,600
ここまで日時のフォーマットについてしゃべりまくったんですけれども、 数値のフォーマットというのもよく同じぐらい使われるかなと思います。

259
00:25:30,600 --> 00:25:43,760
整数ですとか不動書数点数ですとかデシマル型のそれぞれにフォーマットスタイルが用意されていて、 デフォルトでは3桁区切りなどのロケールに応じた表示が行われます。

260
00:25:43,760 --> 00:25:49,800
日本の日本語環境だと3桁おきにカンマが出るというような感じですね。

261
00:25:49,800 --> 00:26:00,040
さらにラウンデッド修飾詞を使うと、 死者誤入ですとか切り捨てとか切り上げといった数字の丸めのルールがありますけれども、 それも指定できます。

262
00:26:00,040 --> 00:26:09,280
他にも有効桁数を指定できたり、指数表記にしたり、 たくさんの修飾詞があってそれらを使うとカスタマイズできます。

263
00:26:10,200 --> 00:26:17,680
それぞれの数値の方には百分率、パーセントとしてフォーマットするスタイルも用意されています。

264
00:26:17,680 --> 00:26:35,720
数値が自動的に100倍されてロケールに応じたパーセントの記号が付与されます。 パーセント記号をどこにつけるかですとか、そもそもパーセント記号が何かというのもロケールに応じて違うので、 それらを自動調整してくれます。

265
00:26:36,360 --> 00:26:48,960
同様に通貨としてフォーマットするスタイルも用意されています。 通貨コードを指定することでロケールに応じた通貨記号や、 少数点以下の桁数というのもここでサポートされます。

266
00:26:48,960 --> 00:26:58,800
同じ国や地域の中でも言語が違えば通貨の記号を表示する場所が変わったりもするので、 それもサポートしています。

267
00:26:59,760 --> 00:27:09,160
続いて、iOS16で導入されたデュレーション型を使うフォーマットスタイルも紹介します。

268
00:27:09,160 --> 00:27:19,680
デュレーションタイムフォーマットスタイルというのがありまして、 これはデュレーションの値を時、分、秒の形式でフォーマットします。

269
00:27:19,760 --> 00:27:31,480
パターンという引数があって、ここにHourMinutesとかHourMinutesSecondなどを指定することで、 時間と分と秒の表示形式を細かく制御できます。

270
00:27:31,480 --> 00:27:39,400
パッドアワートゥレンスなどを使うと桁数を揃えるということもできます。

271
00:27:39,520 --> 00:27:48,200
これにはユニッツフォーマットスタイルというのもありまして、 これはデュレーションの値を自動的に最適な単位を使う形でフォーマットしてくれます。

272
00:27:48,200 --> 00:27:56,440
この使うべき単位をこちらから指定することもできますし、 あとはそのゼロで桁を埋めるということもできます。

273
00:27:57,120 --> 00:28:05,640
続いて計測値に関するフォーマットスタイルです。 Swiftにおける計測値について皆さんご存知でしょうか。

274
00:28:05,640 --> 00:28:12,960
Swiftのファンデーションには様々な値を示すことができる メジャーメントという単位があります。

275
00:28:13,360 --> 00:28:23,760
例えば面積を示すデータがあるときに、 シンプルにイント型とかダブル型を使うことが真っ先に思い浮かぶかもしれませんが、

276
00:28:23,760 --> 00:28:33,320
ユニットエリアのメジャーメント型にしておくことで、 型システムによってこのデータが面積であることを明確に示すことができます。

277
00:28:33,320 --> 00:28:44,600
またそのデータの単位も同時に持つことができます。 ここでは東北の3つの県の面積を平方キロメートルで表しています。

278
00:28:44,600 --> 00:28:49,560
なので後ろにスクエアキロメートルって書いてますね。

279
00:28:49,880 --> 00:29:00,960
これらにフォーマットをつけることでデータの数値とその単位を一緒に出力してくれます。 単位の出力のスタイルをこのキロメートル二乗というところから、

280
00:29:00,960 --> 00:29:13,680
漢字とカタカナのように変換することもできますし、 これをアメリカ英語向けにフォーマットすると平方キロメートルが平方マイルへと変換されて出力されます。

281
00:29:14,840 --> 00:29:23,000
またメモリやファイルなどのサイズを表すに適したフォーマットスタイルも用意されています。

282
00:29:23,000 --> 00:29:36,520
キロバイトとかメガバイトとかギガバイトなど最適な単位に自動的に変換して出力します。 こちらもスタイル引数やユニット引数で表示形式や単位を制御できます。

283
00:29:37,800 --> 00:29:49,440
続いて人の名前をフォーマットするためのフォーマットスタイルというのも存在します。 人の名前に関する型であるパーソンネームコンポーネンスという型がありますが、

284
00:29:49,440 --> 00:29:59,680
ここから人の名前というのをフォーマットできます。 スタイル引数でショート、ミディアム、ロングなどといった表示形式を選択できて、

285
00:30:00,000 --> 00:30:04,000
ロケールに応じた姓名の順序を 自動で適用してくれます。

286
00:30:06,500 --> 00:30:12,500
このようにローマ字表記で仮に 姓名、ニックネームというのを指定しますと

287
00:30:12,500 --> 00:30:20,300
短縮形の方ではイニシャルが生成されたりですとか 日本のロケールでは姓名の順番になりますが

288
00:30:20,300 --> 00:30:25,300
英語のロケールでは名、姓の順番に イニシャルが出るというような違いがあります。

289
00:30:25,300 --> 00:30:31,300
もうすぐ全部の紹介が終わりますよ。

290
00:30:31,300 --> 00:30:36,300
URLに関するフォーマットスタイルというのも デフォルトで存在しています。

291
00:30:36,300 --> 00:30:43,300
URLをホスト、パス、クエリなどを 特定のコンポーネントに絞ってフォーマットすることができます。

292
00:30:43,300 --> 00:30:48,300
例えばこのようにクエリの部分だけ取り出したりですとか

293
00:30:48,300 --> 00:30:54,300
あとはブラウザーアプリのようにURLのドメイン部分だけを ユーザーに表示したりしたいという場合に

294
00:30:55,300 --> 00:31:00,300
役に立ちそうです。

295
00:31:00,300 --> 00:31:06,300
その他少し特殊なフォーマットスタイルというのを 最後に紹介します。

296
00:31:06,300 --> 00:31:12,300
配列などのシーケンスの要素を連結して 一つの文字列としてフォーマットするスタイルが用意されています。

297
00:31:12,300 --> 00:31:18,300
このスタイルはロケールに応じて カンマとかあとはトーテンといった

298
00:31:18,300 --> 00:31:26,300
適切な区切り文字ですとか あとは接続詞を自動で適用してくれます。

299
00:31:26,300 --> 00:31:33,300
例えば日本語ではリンゴ、テン、バナナ、 テン、ミカンという風になったりですとか

300
00:31:33,300 --> 00:31:38,300
英語ではアップル、カンマ、バナナ、 カンマ、アンド、オレンジのように

301
00:31:38,300 --> 00:31:43,300
人間が読むときにとても自然なスタイルになってくれます。

302
00:31:43,300 --> 00:31:47,300
このリストフォーマットスタイルの メンバースタイルという引数に

303
00:31:47,300 --> 00:31:50,300
別のフォーマットスタイルを 渡すということもできまして

304
00:31:50,300 --> 00:31:57,300
リストの各要素に個別にフォーマットをしつつ 最終的に連結された文字列というのを

305
00:31:57,300 --> 00:32:01,300
このリストフォーマットスタイルで やることもできます。

306
00:32:01,300 --> 00:32:05,300
数字は数字でフォーマットしておいて 最後それを一つの文字列に

307
00:32:05,300 --> 00:32:10,300
もう一回フォーマットするというようなのが こちらのサンプルですね。

308
00:32:10,300 --> 00:32:13,300
これは私たちが直接使うことは ほぼないんですけれども

309
00:32:13,300 --> 00:32:17,300
ストリングをストリングに フォーマットするという方も存在します。

310
00:32:17,300 --> 00:32:20,300
入力と出力が変わらないという スタイルなんですけれども

311
00:32:20,300 --> 00:32:24,300
例えばジェネリックなコンテキストにおいて フォーマットスタイルがどうしても必要

312
00:32:24,300 --> 00:32:30,300
みたいなときにデフォルトのプレソーダとして 使われるのがこちらのストリングスタイルでした。

313
00:32:31,300 --> 00:32:35,300
こうですね。

314
00:32:35,300 --> 00:32:41,300
これはストアキットのフレームワークにも フォーマットスタイルが存在していました。

315
00:32:41,300 --> 00:32:51,300
こちらはサブスクの期間を日とか月とか年の単位で フォーマットするためのスタイルが用意されています。

316
00:32:51,300 --> 00:32:55,300
これで例えばApp Store Connectとかで指定したサブスクの期間を

317
00:32:55,300 --> 00:33:02,300
アプリ内で適切にローカライズする ということが可能です。

318
00:33:02,300 --> 00:33:03,300
大変お疲れ様でした。

319
00:33:03,300 --> 00:33:09,300
以上がiOS26までに搭載されている 基本のフォーマットスタイルのすべてでした。

320
00:33:09,300 --> 00:33:13,300
いつか皆さんの普段の開発で あのフォーマットスタイルがあったかもしれないなと

321
00:33:13,300 --> 00:33:18,300
思い出すきっかけになれば嬉しいです。

322
00:33:18,300 --> 00:33:25,300
それではこのフォーマットスタイルの外側 インターフェースの話に少し戻りたいと思います。

323
00:33:25,300 --> 00:33:32,300
先ほど挙げたフォーマットスタイルの中には 出力される文字列に簡単に装飾ができるタイプの

324
00:33:32,300 --> 00:33:35,300
フォーマットスタイルというのがあります。

325
00:33:35,300 --> 00:33:44,300
このフォーマットの出力の型が就職できる文字列である アトリビューテッドストリングになっています。

326
00:33:44,300 --> 00:33:49,300
それではそれがどのように動作するかというのを イメージ見てみましょう。

327
00:33:49,300 --> 00:33:55,300
フォーマットスタイルで書き直した最初のスクリーンショットが こちらになりますが、

328
00:33:55,300 --> 00:34:00,300
ここの日時をフォーマットしている部分を取り出しました。

329
00:34:00,300 --> 00:34:04,300
そしてアトリビュートに対応している フォーマットスタイルの場合は、

330
00:34:04,300 --> 00:34:10,300
このようにフォーマットスタイルの末尾に アトリビューテッド、もしくはアトリビューテッドスタイルの

331
00:34:10,300 --> 00:34:13,300
どちらかをつけることができまして、

332
00:34:13,300 --> 00:34:19,300
例えばこのように年の部分に対してのみ フォーグラウンドカラーをレッドにするという指定をすれば、

333
00:34:19,300 --> 00:34:23,300
それがビューに反映されます。

334
00:34:23,300 --> 00:34:25,300
その他よく見る例ですと、

335
00:34:25,300 --> 00:34:33,300
例えば通貨をフォーマットしたときに通貨の記号の部分だけ 数字よりもフォントサイズを小さくしたいみたいな

336
00:34:33,300 --> 00:34:35,300
要望が出ることがありますが、

337
00:34:35,300 --> 00:34:39,300
これもアトリビューテッドなフォーマットスタイルで 実現することができます。

338
00:34:39,300 --> 00:34:48,300
これは円マークの部分が数字よりも ちょっと小さいという感じですね。

339
00:34:48,300 --> 00:34:51,300
残り時間の関係で説明は省略しますけれども、

340
00:34:51,300 --> 00:34:54,300
IS 18からのSuite UIのストップウォッチですとか、

341
00:34:54,300 --> 00:34:59,300
タイマーのような表示に特化したアトリビューテッドな フォーマットスタイルというのも存在します。

342
00:35:00,000 --> 00:35:09,000
では、そのSwiftUIの話が出てきましたので、このSwiftUIからフォーマットスタイルを使うという方法も少し見ていきましょう。

343
00:35:09,000 --> 00:35:19,000
このトークの序盤にですね、SwiftUIのテキストのイニシャライザーはデート型を渡すことはできないと説明しました。

344
00:35:19,000 --> 00:35:26,000
なので、Formattedを使うことでString型に変えて解決しましょうというお話をしたんですけれども、

345
00:35:26,000 --> 00:35:33,000
実はですね、テキストにはデート型を受け取れるイニシャライザーが別に存在しています。

346
00:35:33,000 --> 00:35:35,000
それがこの形です。

347
00:35:35,000 --> 00:35:43,000
テキストの第一引数には何かしらのデータを置いて、第二引数であるフォーマットの部分にフォーマットスタイルを渡すことで、

348
00:35:43,000 --> 00:35:47,000
SwiftUIのテキストとして取り扱うことができます。

349
00:35:47,000 --> 00:35:50,000
これが最もベストな方法かなと思います。

350
00:35:50,000 --> 00:35:55,000
特にですね、動作の制約が厳しいウィジェットですとか、ライブアクティビティですとか、

351
00:35:55,000 --> 00:36:01,000
コンプリケーションみたいなのを構築する場合には、特にこれを使うべきでしょう。

352
00:36:01,000 --> 00:36:10,000
こちらのサンプルコードでは正直微妙なんですけれども、データの型によってはパフォーマンスの良いディスクリエイトフォーマットスタイルというのは別に存在していて、

353
00:36:10,000 --> 00:36:13,000
そちらの恩恵を受けられる可能性もあります。

354
00:36:13,000 --> 00:36:18,000
もしよろしければスクーズスピーカーなどでおしゃべりできたら嬉しいです。

355
00:36:18,000 --> 00:36:22,000
またさらにですね、ここでVStackを使っていますけれども、

356
00:36:22,000 --> 00:36:27,000
これを一つのテキストとして取り扱いたい場合は、

357
00:36:27,000 --> 00:36:37,000
StringInterpolationの方でこのフォーマットという引数を使う書き方も存在します。

358
00:36:37,000 --> 00:36:42,000
これまではこちらからユーザーに何か見せるためのフォーマットを使う例で、

359
00:36:42,000 --> 00:36:44,000
SwiftUIのテキストを使ってきましたが、

360
00:36:45,000 --> 00:36:50,000
このフォーマットはテキストフィールドにも使うことができます。

361
00:36:50,000 --> 00:36:55,000
何かしらのデータをストリングにフォーマットするというのはずっと見てきたんですけれども、

362
00:36:55,000 --> 00:36:58,000
これを逆にユーザーからストリングを受け取って、

363
00:36:58,000 --> 00:37:03,000
それを何かしらの手段で解析してこちらのデータ型に変換する。

364
00:37:03,000 --> 00:37:05,000
つまりこれはParseの処理ですね。

365
00:37:05,000 --> 00:37:12,000
これが必要な場合があります。

366
00:37:12,000 --> 00:37:18,000
ここでParseableFormatStyleというのが存在します。

367
00:37:18,000 --> 00:37:23,000
このParseableFormatStyleにおけるParseの処理というのは、

368
00:37:23,000 --> 00:37:27,000
ParseStrategyのこちらで定義されています。

369
00:37:27,000 --> 00:37:34,000
こちらにParseInputとParseOutputという型がありますが、これに注目してください。

370
00:37:34,000 --> 00:37:37,000
このParseInputとParseOutputというのは、

371
00:37:37,000 --> 00:37:44,000
元のフォーマットスタイルのInputとOutputとそれぞれ対の関係になるように定められていまして、

372
00:37:44,000 --> 00:37:48,000
これによってデータのフォーマットとパースというのが

373
00:37:48,000 --> 00:37:52,000
それぞれ逆向きの関係になっていることが表現されています。

374
00:37:52,000 --> 00:37:56,000
僕はこの表現方法めちゃめちゃ好きです。

375
00:37:56,000 --> 00:38:03,000
この日時や数値ですとかURLみたいな規則が明確なフォーマットスタイルを中心に、

376
00:38:03,000 --> 00:38:07,000
それらはParseableFormatStyleにも適合しています。

377
00:38:07,000 --> 00:38:12,000
この人の名前もParse可能というのが驚きですね。

378
00:38:12,000 --> 00:38:15,000
それではこのParseableFormatStyleについては、

379
00:38:15,000 --> 00:38:20,000
これを自作する方法を見ながら理解を進めてみることにしましょう。

380
00:38:20,000 --> 00:38:23,000
OSに含まれていないスタイルでフォーマットしたい場合、

381
00:38:23,000 --> 00:38:28,000
フォーマットスタイルを自作するという選択肢があります。

382
00:38:28,000 --> 00:38:34,000
こちらは私がOSSで開発しているXcodeのコーディングインテリジェンス機能を

383
00:38:34,000 --> 00:38:39,000
ChatGPTとかCloud以外のモデルでも使えるようにするというツールがありまして、

384
00:38:39,000 --> 00:38:44,000
その中にはユーザーが任意のポート番号を設定できるように

385
00:38:44,000 --> 00:38:49,000
SuiteUIのテキストフィールドを使った画面が存在します。

386
00:38:49,000 --> 00:38:55,000
このポート番号というのはNWEndpointPortという型なんですけれども、

387
00:38:56,000 --> 00:39:00,000
これとストリングのフォーマットを行うフォーマットスタイルというのは

388
00:39:00,000 --> 00:39:03,000
今、標準には存在しません。

389
00:39:03,000 --> 00:39:07,000
そのためこれを自分で作ります。

390
00:39:07,000 --> 00:39:12,000
ではまずフォーマットスタイルに適合するところから始めましょう。

391
00:39:12,000 --> 00:39:15,000
NWEndpointPort型というのを受け取って、

392
00:39:15,000 --> 00:39:21,000
それをストリングで返すフォーマットメソッドを実装します。

393
00:39:21,000 --> 00:39:27,000
この型はローバリューを取るとUint16が得られるので、

394
00:39:27,000 --> 00:39:33,000
これをさらに数値としてフォーマットして文字列にします。

395
00:39:33,000 --> 00:39:36,000
そして標準のフォーマットスタイルと同様に

396
00:39:36,000 --> 00:39:41,000
ショートカットを提供して無事に完成ということになります。

397
00:39:41,000 --> 00:39:45,000
NWEndpointPortの後ろにフォーマッティングを付ければ

398
00:39:45,000 --> 00:39:49,000
フォーマットできるというものですね。

399
00:39:49,000 --> 00:39:53,000
そしてその先のパーサブルフォーマットスタイルにも

400
00:39:53,000 --> 00:39:56,000
適合させてみることにします。

401
00:39:56,000 --> 00:40:00,000
これに適合するためには対応するパースストラテジーを定義する必要があります。

402
00:40:00,000 --> 00:40:11,000
パースストラタリジーのこのパースメソッドにおいて、 入力文字列を目的のNWEndpointPort型に変換するロジックを記述します。

403
00:40:13,000 --> 00:40:17,000
こちらもアクセスするためのショートカットを書いて完成ということになります。

404
00:40:18,000 --> 00:40:24,000
これでフォーマットの位置方向だけではなくて、 逆方向のパースも簡単に行えるようになりました。

405
00:40:24,000 --> 00:40:35,000
本日はですね、データのフォーマットというのは、 普段の開発でも常日頃行われているということを確認して、

406
00:40:35,000 --> 00:40:39,000
フォーマットを行う手段、APIの移り変わりというのを眺めてみました。

407
00:40:40,000 --> 00:40:45,000
標準で搭載されているフォーマットスタイルというのは非常に多くの種類があって、

408
00:40:45,000 --> 00:40:52,000
ただそのどれもがスイートらしい安全さや、 流行りの機構によってモダンに使えるということが分かりました。

409
00:40:53,000 --> 00:41:01,000
また、自分自身でフォーマットスタイルを作って、 拡張できるという柔軟さも備えていることが分かりました。

410
00:41:02,000 --> 00:41:08,000
もし今あなたが携わっているプロジェクトで、 従来の方法でデータフォーマッティングをされているところがあれば、

411
00:41:08,000 --> 00:41:12,000
このフォーマットスタイルへの移行もぜひ検討してみてください。

412
00:41:15,000 --> 00:41:21,000
本トークの作成にあたっては、多くのAppleの公式のドキュメントですとか、 WWDCのセッションも参考にしております。

413
00:41:21,000 --> 00:41:26,000
これらはフォーマットスタイルを深く理解する上で、 非常に役に立ちますのでお勧めです。

414
00:41:28,000 --> 00:41:33,000
それではぜひ今日から、 そろそろフォーマットスタイルというのを始めてみてください。

415
00:41:34,000 --> 00:41:36,000
以上となります。 ご静聴ありがとうございました。

416
00:41:46,000 --> 00:41:48,000
発表ありがとうございました。

417
00:41:49,000 --> 00:41:51,000
それではQ&Aに入りたいと思います。

418
00:41:52,000 --> 00:41:55,000
コメントやご質問のある方は、 手を挙げてお知らせください。

419
00:41:58,000 --> 00:42:00,000
マイクをお持ちします。 お持ちください。

420
00:42:08,000 --> 00:42:09,000
お話ありがとうございます。

421
00:42:10,000 --> 00:42:15,000
今まで経験的に、 データフォーマットをずっと使ってきて、

422
00:42:16,000 --> 00:42:18,000
ユニットテストとかの観点で、

423
00:42:20,000 --> 00:42:25,000
ロケールとかタイムゾーンっていうのを、 現在設定じゃなくて外から指定して、

424
00:42:27,000 --> 00:42:29,000
フォーマットを使うっていうことが 結構多かったんですけれども、

425
00:42:30,000 --> 00:42:33,000
フォーマットスタイルを使った場合も、 そういったことは可能なんでしょうか。

426
00:42:34,000 --> 00:42:36,000
はい。ご質問いただきありがとうございます。

427
00:42:38,000 --> 00:42:42,000
デートに関するフォーマットスタイルの就職誌で、 いろんなものを紹介しましたけれども、

428
00:42:42,000 --> 00:42:45,000
その中にロケールを指定するという 就職誌も存在しています。

429
00:42:46,000 --> 00:42:51,000
なので、それを使うことで、 ロケールを注入するということが可能かなと思いますし、

430
00:42:52,000 --> 00:42:54,000
もしテスト用途みたいなところであれば、

431
00:42:55,000 --> 00:42:59,000
そうですね、ロケールを注入できる 自作のフォーマットスタイルみたいなので、

432
00:43:00,000 --> 00:43:06,000
一個ラップして、そのラップした方に対して、 テストコード側からインジェクションするみたいな設計をすると、

433
00:43:07,000 --> 00:43:09,000
結構外側から見たときにきれいかなと思いつつ、

434
00:43:09,000 --> 00:43:13,000
それをやってますよというのを チームの中に周知しないと、

435
00:43:14,000 --> 00:43:16,000
これは何の方なんだみたいな問題も 起きるかなと思うので、

436
00:43:17,000 --> 00:43:19,000
そこはちょっといい案外を狙うのが 必要かなとも思います。

437
00:43:20,000 --> 00:43:21,000
ありがとうございます。

438
00:43:24,000 --> 00:43:25,000
ありがとうございました。

439
00:43:26,000 --> 00:43:29,000
他にコメントやご質問のある方は、 挙手をお願いします。

440
00:43:39,000 --> 00:43:40,000
ありがとうございます。

441
00:43:41,000 --> 00:43:44,000
すごい興味本位なことなんですけれども、

442
00:43:45,000 --> 00:43:50,000
ダブル型とかフローティングポイントの数値の フォーマットスタイルというのがあったと思うんですけれども、

443
00:43:51,000 --> 00:43:54,000
そういうフローティングポイントナンバー というのがよくあることとして、

444
00:43:55,000 --> 00:43:59,000
丸目精度というのが結構考慮することが あったりするじゃないですか。

445
00:44:00,000 --> 00:44:03,000
例えばよくある話として、 0.1たす2は0.3じゃなくて0.3…

446
00:44:04,000 --> 00:44:05,000
みたいなことがあるんですけれども、

447
00:44:05,000 --> 00:44:16,000
例えばその0.1たす0.2の結果をフォーマット… 単純に例えばフォーマットにとって出力するとどうなるのかなというのがちょっと気になりました。

448
00:44:17,000 --> 00:44:18,000
ありがとうございます。

449
00:44:19,000 --> 00:44:22,000
ダブル同士の足し算をした結果を フォーマットする場合は、

450
00:44:23,000 --> 00:44:27,000
0.33333の方でストリングとして 出力されてしまいます。

451
00:44:28,000 --> 00:44:31,000
なので誤差を含んだ状態で フォーマットしてしまうので、

452
00:44:31,000 --> 00:44:36,000
誤差がない計算というのは無理なわけですけれども、

453
00:44:37,000 --> 00:44:46,000
そこの問題はフォーマットする前に解決するという考え方が 一応フォーマットスタイル側の見た目かなと自分は理解してます。

454
00:44:51,000 --> 00:44:52,000
ありがとうございました。

455
00:44:53,000 --> 00:44:56,000
他にコメントやご質問がある方は挙手をお願いします。

456
00:45:00,000 --> 00:45:09,360
発表ありがとうございます

457
00:45:09,360 --> 00:45:13,600
ローカライズの部分の話がいくつか出てきてたと思うんですけど

458
00:45:13,600 --> 00:45:18,600
一般に業務でやる場合はローカライズストリングとかストリングカタログを使って

459
00:45:18,600 --> 00:45:23,240
行う部分と結構被る部分も役割としてはあったかなと思うんですけど

460
00:45:23,240 --> 00:45:26,040
どのように使い分けたりとか

461
00:45:26,040 --> 00:45:29,960
もしくはローカライズある程度フォーマットスタイルに寄せるべきなのかとか

462
00:45:29,960 --> 00:45:33,720
そういったところのお考えがあれば聞きたいです

463
00:45:33,720 --> 00:45:36,280
はい ありがとうございます

464
00:45:36,280 --> 00:45:42,040
途中でVStackのテキスト2個じゃなくてテキスト1個にする形式みたいなのを紹介しましたけども

465
00:45:42,040 --> 00:45:48,520
あれがローカライズドキーとかを使いたいときに

466
00:45:48,520 --> 00:45:52,280
あっちの方 書き方を使うっていうのが

467
00:45:52,280 --> 00:45:56,000
このフォーマットスタイルの使い方かなというふうに思ってます

468
00:45:56,000 --> 00:46:02,880
私はフォーマットスタイルで40分話すって結構僕えぐいかなと思ってるんですけども

469
00:46:02,880 --> 00:46:05,640
それが一応フォーマットスタイル好きなので

470
00:46:05,640 --> 00:46:09,520
自分の個人の見解としてはローカライズアブルのほうに

471
00:46:09,520 --> 00:46:13,120
このフォーマット側のほうは含めずに

472
00:46:13,120 --> 00:46:17,920
例えば単位の取り扱いですとか地域に合わせた記号の表示みたいのは

473
00:46:17,920 --> 00:46:20,840
このフォーマットスタイル側に任せて

474
00:46:20,840 --> 00:46:24,120
ローカライズアブルエクシストリングスのほうには書かないっていうのは

475
00:46:24,640 --> 00:46:25,760
お勧めしているというか

476
00:46:25,760 --> 00:46:28,920
普段の個人開発ではそのようにしてます

477
00:46:28,920 --> 00:46:32,200
ありがとうございます

478
00:46:32,200 --> 00:46:33,760
ありがとうございます

479
00:46:33,760 --> 00:46:36,480
お時間的に次が最後になりそうです

480
00:46:36,480 --> 00:46:46,240
コメントやご質問のある方は挙手をお願いします

481
00:46:46,240 --> 00:46:48,640
それではお時間になりましたので

482
00:46:48,640 --> 00:46:53,160
これにてQAセッションは終了させていただきます

483
00:46:53,160 --> 00:46:57,240
これで1分間フィードバックのお時間です

484
00:46:57,240 --> 00:47:00,200
1分間フィードバックのお時間です

485
00:47:00,200 --> 00:47:02,720
スクリーンのQRコードを読み取って

486
00:47:02,720 --> 00:47:04,720
フィードバックを送ってください

487
00:47:23,160 --> 00:47:34,080
お昼ごはん後のすごく眠くなる時間に皆さんお聞きいただいてありがとうございました

488
00:47:34,080 --> 00:47:38,560
たくさん部屋の席が埋まっていてすごい感動しました
