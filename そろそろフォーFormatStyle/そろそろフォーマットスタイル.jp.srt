1
00:00:00,000 --> 00:00:06,964
そろそろ FormatStyle

2
00:00:08,032 --> 00:00:12,364
はい それではそろそろ FormatStyle というタイトルで

3
00:00:12,364 --> 00:00:15,364
発表しますよろしくお願い致します

4
00:00:15,365 --> 00:00:18,565
発表は私 Tanaka Ryoga が務めさせていただきます

5
00:00:18,565 --> 00:00:22,565
普段はこちらのオレンジ色のアイコンで活動しております

6
00:00:22,565 --> 00:00:25,865
新しいiPhoneの色と同じオレンジ色ですね

7
00:00:25,865 --> 00:00:28,966
個人開発で Swift を使ったアプリケーションを開発したり

8
00:00:28,966 --> 00:00:32,832
あとは株式会社 DeNA でも iOS アプリケーションのデベロッパーを

9
00:00:32,832 --> 00:00:35,365
普段しております

10
00:00:35,365 --> 00:00:38,598
過去、この iOSDC Japan では 3 回

11
00:00:38,598 --> 00:00:40,966
いずれも40分のレギュラートークをしておりまして

12
00:00:40,966 --> 00:00:45,165
今回は 4 回目になります

13
00:00:45,365 --> 00:00:50,365
私の初めての登壇となったのが2021年のトークなんですけれども

14
00:00:50,365 --> 00:00:51,966
こちらのタイトルが

15
00:00:51,966 --> 00:00:55,399
あらゆる情報を楽に正しくストリングにフォーマットする

16
00:00:55,399 --> 00:00:58,165
というものでした

17
00:00:58,165 --> 00:01:00,365
当時のアーカイブを見てみますと

18
00:01:00,365 --> 00:01:03,066
様々なデータをフォーマッターを使って

19
00:01:03,066 --> 00:01:07,566
ストリングに変換していくという内容でした

20
00:01:07,566 --> 00:01:09,632
その年に日本で開催された

21
00:01:09,632 --> 00:01:13,365
国際的なスポーツの開会式のひと幕みたいなデザインで

22
00:01:13,365 --> 00:01:16,566
当時発表してました

23
00:01:16,566 --> 00:01:21,566
その中で 2021 年で最新の iOS のバージョンであった

24
00:01:21,566 --> 00:01:26,965
iOS 15 の新機能について少しだけ触れていました

25
00:01:26,965 --> 00:01:28,566
当時のスクリーンショットがこちらです

26
00:01:28,566 --> 00:01:31,566
もしかしたら後ろの方見えないかもしれないんですけども

27
00:01:31,566 --> 00:01:34,566
Apple の新しい機能に関するドキュメントでは

28
00:01:34,566 --> 00:01:36,566
よくノーオーバービューアベイラブルと

29
00:01:36,566 --> 00:01:39,566
何も書いてないみたいなドキュメントが出てくるんですが

30
00:01:39,566 --> 00:01:41,332
当時そうなっていたのが

31
00:01:41,332 --> 00:01:46,566
本日のテーマである FormatStyle です

32
00:01:46,566 --> 00:01:50,566
FormatStyle は iOS 15 以降で使用できる仕組みです

33
00:01:50,566 --> 00:01:53,566
リリースされた 2021 年の当時は

34
00:01:53,566 --> 00:01:57,566
例えばミニマムデプロイメントターゲットなどの関係で

35
00:01:57,566 --> 00:02:01,566
実プロダクトへの投入というのは難しかったかもしれないんですけれども

36
00:02:01,566 --> 00:02:03,566
あれから 4 年が経ちまして

37
00:02:03,566 --> 00:02:08,566
あとは先日 iOS 26 がリリースされた今

38
00:02:08,566 --> 00:02:11,566
Appleの資料によれば多くのユーザーのデバイスが

39
00:02:11,566 --> 00:02:14,566
すでに FormatStyle をサポートしているという

40
00:02:14,566 --> 00:02:17,566
環境になっていることが分かります

41
00:02:17,566 --> 00:02:19,566
まさに FormatStyle について触れる

42
00:02:19,566 --> 00:02:24,566
ぴったりなタイミングかなと思って今回発表させていただきます

43
00:02:24,566 --> 00:02:28,566
本トークは Swift や iOS アプリケーション開発における

44
00:02:28,566 --> 00:02:34,566
データのフォーマットについてこれから学ぼうとしている方

45
00:02:34,566 --> 00:02:37,566
従来のフォーマッターは使ったことがあるけれど

46
00:02:37,566 --> 00:02:42,566
この新しい FormatStyle にはちょっと慣れていないという方

47
00:02:42,566 --> 00:02:44,566
あとは標準には用意されていない

48
00:02:44,566 --> 00:02:47,566
独自の FormatStyle の作り方のサンプルを

49
00:02:47,566 --> 00:02:52,566
知りたい方に向けて発表します

50
00:02:52,566 --> 00:02:58,566
それでは改めましてデータのフォーマットとは何でしょうか

51
00:02:58,566 --> 00:03:01,566
ここに一つスクリーンショットがあります

52
00:03:01,566 --> 00:03:04,566
画面中央に本トークのタイトルと

53
00:03:04,566 --> 00:03:09,566
あとは開始日時が表示されています

54
00:03:09,566 --> 00:03:13,566
 SwiftUI のコードで示すとこのようになっています

55
00:03:13,566 --> 00:03:21,566
今はトークの開始日時の部分がテキストに直接文字列で書かれていますね

56
00:03:21,566 --> 00:03:26,566
このタイトルや開始日時がビューの外から与えられるようにします

57
00:03:26,566 --> 00:03:30,566
さらにSwiftには日時を取り扱うことのできる

58
00:03:30,566 --> 00:03:32,566
Date という型がありますから

59
00:03:32,566 --> 00:03:37,566
この Date のプロパティの型を今の String 型から

60
00:03:37,566 --> 00:03:40,566
Date 型で渡されてくるようにします

61
00:03:40,566 --> 00:03:43,566
しかしこのままのコードですと

62
00:03:43,566 --> 00:03:45,566
 SwiftUI のテキストのイニシャライザに

63
00:03:45,566 --> 00:03:49,566
この Date 型を渡すことはできないというエラーが発生して

64
00:03:49,566 --> 00:03:54,566
ビルドが通らなくなってしまいます

65
00:03:54,566 --> 00:03:56,566
このビルドエラーを解消するためには

66
00:03:56,566 --> 00:04:01,566
型でいうとこの Date 型から何らかの手段を使って

67
00:04:01,566 --> 00:04:04,566
String 型へと変換し

68
00:04:04,566 --> 00:04:08,566
すいません、 SwiftUI  のテキストへ渡すようにすると良さそうです

69
00:04:08,566 --> 00:04:10,566
こうですね

70
00:04:11,133 --> 00:04:15,500
それではこの変換を行う方法について考えてみようと思います

71
00:04:17,365 --> 00:04:19,033
Swiftの Date 型には

72
00:04:19,033 --> 00:04:23,865
timeIntervalSinceReferenceDate というプロパティがあります

73
00:04:23,865 --> 00:04:29,565
これは世界標準時の2001年1月1日0時0分から

74
00:04:29,565 --> 00:04:35,565
何秒の差分があるかを示す値が入っています

75
00:04:35,565 --> 00:04:38,565
日本時間の今日の13時の場合

76
00:04:38,565 --> 00:04:43,833
7億8千3万3千6百秒という数字が入っています

77
00:04:45,899 --> 00:04:51,565
この数字からからさらに年、月、日、時、分の

78
00:04:51,833 --> 00:04:56,865
数字を、四則演算を駆使して割り出すというのが良いでしょうか

79
00:04:58,632 --> 00:05:01,833
ただ、西暦の年を計算できたとしても

80
00:05:01,833 --> 00:05:06,033
iOSではユーザーがこれを和暦に設定することもできます

81
00:05:06,432 --> 00:05:09,033
この場合はどのように対応すると良いでしょうか

82
00:05:11,233 --> 00:05:13,333
さらに英語の環境では

83
00:05:13,333 --> 00:05:18,432
そもそも月に当たるのが数字ではなく決まった英単語になりますし

84
00:05:18,632 --> 00:05:22,632
あとは24時間表記ではなくて12時間表記が好まれるかもしれません

85
00:05:24,833 --> 00:05:29,632
何かしらのデータがあって、それを文字列に変換しようとするときに

86
00:05:30,033 --> 00:05:34,233
ユーザーの言語や地域、文化などを考慮して

87
00:05:34,233 --> 00:05:37,300
その人にとって最も馴染みのある形式で

88
00:05:37,300 --> 00:05:39,632
伝えることができるのがベストかなと思います

89
00:05:40,432 --> 00:05:43,432
このことをデータのフォーマットと言っています

90
00:05:45,800 --> 00:05:47,865
iOSのアプリケーションの開発のような

91
00:05:47,865 --> 00:05:51,733
 世界中の多様なユーザーに情報を届けるための

92
00:05:51,733 --> 00:05:54,632
インターフェースを作っている私たちにとって

93
00:05:54,632 --> 00:05:57,598
データを適切な形にフォーマットするというのは

94
00:05:57,598 --> 00:06:01,266
避けては通れない非常に重要なものです

95
00:06:01,266 --> 00:06:02,733
一つのアプリの中でも

96
00:06:02,733 --> 00:06:05,000
いろいろな場所で繰り返し

97
00:06:05,000 --> 00:06:07,132
データをフォーマットすることがあるでしょう

98
00:06:08,865 --> 00:06:11,598
一方で、このデータのフォーマットについては

99
00:06:11,598 --> 00:06:14,333
無数の考慮すべき事柄があるため

100
00:06:14,333 --> 00:06:17,365
いついかなるときも期待通りに動作させる

101
00:06:17,365 --> 00:06:19,800
というのは非常に難しいものです

102
00:06:21,533 --> 00:06:24,165
そこで、よく使われるデータについては

103
00:06:24,165 --> 00:06:27,365
自分でフォーマット処理を書かなくても良いように

104
00:06:27,365 --> 00:06:29,800
SwiftやOSのフレームワークには

105
00:06:29,800 --> 00:06:34,665
あらかじめデータフォーマッティングのAPIが用意されています

106
00:06:35,733 --> 00:06:39,500
それでは、データのフォーマットを試してみましょう

107
00:06:40,333 --> 00:06:43,165
せっかく iOS アプリケーションの開発の現場でも

108
00:06:43,165 --> 00:06:45,733
徐々にコーディングインテリジェンスの活用例が

109
00:06:45,733 --> 00:06:47,766
見られてきた頃かなと思いますので

110
00:06:47,766 --> 00:06:52,466
ここは一つ、とある大規模言語モデル、LLMに聞いてみましょう

111
00:06:53,365 --> 00:06:57,000
Xcode でエラーになっているところを選びまして

112
00:06:57,000 --> 00:07:00,033
このGenerate Fix for Issueのボタンを押してみます

113
00:07:01,033 --> 00:07:05,033
すると、何らかLLMから返事がありました

114
00:07:05,300 --> 00:07:10,033
このようにコードを変更してくれたみたいですね

115
00:07:10,565 --> 00:07:15,033
ここでは、DateFormatterというのが使われています

116
00:07:15,033 --> 00:07:19,665
このDateFormatterの親クラスであるNSFormatterは

117
00:07:19,665 --> 00:07:22,033
Swiftが登場するよりも前

118
00:07:22,033 --> 00:07:26,766
Objective-Cの時代から存在するデータフォーマッティングのAPIです

119
00:07:28,932 --> 00:07:31,833
ファンデーションにはNSFormatterを継承する

120
00:07:31,833 --> 00:07:34,500
13種類のフォーマッターが存在しており

121
00:07:34,500 --> 00:07:41,033
日時の他にも数値や人の名前、重さや長さのような計測値など

122
00:07:41,033 --> 00:07:44,533
様々な種類のデータのフォーマットに対応しています

123
00:07:45,766 --> 00:07:49,132
2016年9月にリリースされたSwift3からは

124
00:07:49,132 --> 00:07:51,966
呼び出し時にNSのセット字が不要となり

125
00:07:51,966 --> 00:07:54,399
このような見た目になりました

126
00:07:54,399 --> 00:07:58,932
LLMが書いたのは、このDateFormatterを使ったコードでした

127
00:08:00,466 --> 00:08:04,565
このフォーマッターは非常に強力で柔軟なAPIですが

128
00:08:04,565 --> 00:08:08,233
特にSwiftの現代的な開発パラダイムですとか

129
00:08:08,233 --> 00:08:10,932
安全性を重視する観点から見ますと

130
00:08:10,932 --> 00:08:14,000
いくつか注意しなければならない点がありました

131
00:08:15,899 --> 00:08:20,033
それでは、DateFormatterを引き続き例にしてお話しします

132
00:08:20,033 --> 00:08:22,065
ここでは昨年末ですね

133
00:08:22,065 --> 00:08:26,033
とくしこしの直前の時刻をDateプロパティとして用意し

134
00:08:26,033 --> 00:08:30,033
このデータをフォーマットしてみることにしましょう

135
00:08:30,033 --> 00:08:34,133
クラスであるDateFormatterのインスタンスを作り

136
00:08:34,133 --> 00:08:38,133
日付時刻のフォーマットの形式を指定します

137
00:08:39,865 --> 00:08:44,033
それらが済んだら、インスタンスメソッドであるstringFromを使って

138
00:08:44,033 --> 00:08:47,500
ストリング型にフォーマットされた結果を得ます

139
00:08:47,500 --> 00:08:50,299
命令的なプログラミングに馴染みがあれば

140
00:08:50,299 --> 00:08:53,033
非常に読みやすいコードかなと思います

141
00:08:53,432 --> 00:08:55,332
もしフォーマットした結果において

142
00:08:55,332 --> 00:08:59,033
時刻の部分が不要だという場合は

143
00:08:59,033 --> 00:09:01,299
この timeStyle の部分に

144
00:09:01,299 --> 00:09:05,033
.none を指定するといった具合にカスタマイズできます

145
00:09:05,033 --> 00:09:09,100
では、年と月の部分だけ欲しくて

146
00:09:09,100 --> 00:09:14,033
この日はいらないという場合にはどのようにすればよいでしょうか

147
00:09:14,033 --> 00:09:18,500
DateFormatterには、より柔軟にフォーマットの形式を指定できる

148
00:09:18,500 --> 00:09:21,033
dateFormat というプロパティがあります

149
00:09:21,832 --> 00:09:29,332
今回は年と月だけ欲しいので、この大文字のYと大文字のMを使って

150
00:09:29,332 --> 00:09:35,033
あとはその後ろに年と月という漢字も出して欲しいので、加えておきます

151
00:09:35,033 --> 00:09:37,832
それではインスタンスメソッドのstringFromで

152
00:09:37,832 --> 00:09:39,533
これをフォーマットしますと

153
00:09:39,533 --> 00:09:45,666
年の数字が2024ではなく2025となってしまいました

154
00:09:45,666 --> 00:09:49,100
これはどこに誤りがあるのでしょうか

155
00:09:51,365 --> 00:09:55,232
この dateFormat プロパティに与える文字列というのは

156
00:09:55,232 --> 00:09:59,432
ユニコード (Unicode) の技術標準の仕様を用いるということになっています

157
00:10:01,332 --> 00:10:04,232
そのユニコードの仕様にある表に従って

158
00:10:04,232 --> 00:10:07,799
デイトフォーマットの文字列を組み立てていく必要があります

159
00:10:07,799 --> 00:10:10,432
すっごい大きな表で

160
00:10:10,432 --> 00:10:14,100
スクリーンには何書いているかもはや分からないんですけれども

161
00:10:14,100 --> 00:10:16,633
先ほどのデイトフォーマットのこの誤りは

162
00:10:16,633 --> 00:10:19,633
この年を示すYという文字

163
00:10:19,633 --> 00:10:24,633
これが大文字ではなく小文字にするべきだったというものでした

164
00:10:24,633 --> 00:10:28,332
これでめでたしといきたいところですけれども

165
00:10:28,332 --> 00:10:31,033
この後、例えば英語の環境で

166
00:10:31,033 --> 00:10:36,432
ディッセンバー2024のような表記もサポートするとなった場合には

167
00:10:36,432 --> 00:10:38,633
今度はどうしましょうか

168
00:10:38,633 --> 00:10:41,232
現状出すとデイトフォーマットに

169
00:10:41,232 --> 00:10:45,133
直接年とか月みたいな漢字も入ってしまっていますし

170
00:10:45,133 --> 00:10:49,100
あとは日本語は年の月に月がきますが

171
00:10:49,100 --> 00:10:53,633
この英語の場合は月が来て年が来るっていう違いもあります

172
00:10:54,966 --> 00:10:58,500
このようにたとえ日時のフォーマットだけをとっても

173
00:10:58,500 --> 00:11:00,865
考慮すべきパターンが無数にあり

174
00:11:00,865 --> 00:11:04,633
あとはフォーマットの形式の文字列指定にミスがあったとしても

175
00:11:04,633 --> 00:11:08,166
プログラムを実行するまで結果が分かりません

176
00:11:08,166 --> 00:11:13,000
ですからこのデイトフォーマットに直接文字列を指定してはいけません

177
00:11:15,133 --> 00:11:17,633
これはAppleのWWDCのセッションでも

178
00:11:17,633 --> 00:11:20,865
ほぼ必ず意図しない結果になってしまうとして

179
00:11:20,865 --> 00:11:25,932
dateFormat に文字列を直接指定するなとはっきり説明されています

180
00:11:27,198 --> 00:11:29,666
大事なことなのでもう一回言うんですけれども

181
00:11:29,666 --> 00:11:33,198
非常に古い資料ではこれしか方法がないということで

182
00:11:33,198 --> 00:11:36,600
dateFormat に直接指定する方法が紹介されていたり

183
00:11:36,600 --> 00:11:39,166
あとはコーディングインテリジェンスのLLMが

184
00:11:39,166 --> 00:11:41,399
この方法を提案してくるかもしれませんが

185
00:11:41,399 --> 00:11:43,232
これは使わないでください

186
00:11:43,232 --> 00:11:46,600
これは Agents.md とかに書いておくといいと思います

187
00:11:49,100 --> 00:11:51,198
ちょっと話が逸れてしまいましたが

188
00:11:51,198 --> 00:11:52,865
はじめのコードに戻ります

189
00:11:53,899 --> 00:11:56,066
改めてこのコードを読みますと

190
00:11:56,066 --> 00:12:00,000
 SwiftUI のView Protocolによるボディの中で

191
00:12:00,000 --> 00:12:04,633
formattedDate というのを読んでまして

192
00:12:04,633 --> 00:12:09,633
この formattedDate はComputed Propertyで呼び出されるたびに

193
00:12:09,633 --> 00:12:12,633
デイトフォーマッターのインスタンスを生成し

194
00:12:12,633 --> 00:12:17,865
デイトスタイル、タイムスタイルの指定も行ってフォーマットしています

195
00:12:19,365 --> 00:12:21,732
 SwiftUI のViewのボディは

196
00:12:21,732 --> 00:12:25,332
フレームワーク側から何度も呼ばれる可能性があります

197
00:12:26,000 --> 00:12:31,232
呼ばれるたびにこのフォーマッターのインスタンスを都度生成しています

198
00:12:32,232 --> 00:12:34,666
このフォーマッターのインスタンスの生成というのは

199
00:12:34,666 --> 00:12:37,265
非常にコストが高いということが知られています

200
00:12:38,633 --> 00:12:42,332
このコストが高いということについての言及というのは

201
00:12:42,332 --> 00:12:44,633
様々な方がされているんですけれども

202
00:12:44,633 --> 00:12:48,865
例えばこちらのAppleの今年のWWDCのセッションも見てみます

203
00:12:50,166 --> 00:12:55,633
ヒッチやハングといったパフォーマンスが悪い SwiftUI のアプリケーションを

204
00:12:55,633 --> 00:12:58,633
インスルメンツによって計測したところ

205
00:12:58,633 --> 00:13:02,633
先ほど示したコードのようにこのViewのボディから何度も

206
00:13:02,633 --> 00:13:05,533
フォーマッターのインスタンスを生成している箇所が見つかった

207
00:13:05,533 --> 00:13:07,633
というお話でした

208
00:13:08,633 --> 00:13:11,865
それへの対応策としてフォーマッターを使った

209
00:13:11,865 --> 00:13:14,633
このフォーマット5の文字列の生成

210
00:13:14,633 --> 00:13:18,765
このストリングフロムの呼び出しを別な場所で

211
00:13:18,765 --> 00:13:21,166
事前にまとめて実行するようにしたり

212
00:13:21,166 --> 00:13:25,066
あとはそもそもこのフォーマッターのインスタンスの生成回数が

213
00:13:25,066 --> 00:13:26,466
最小限に済むように

214
00:13:26,466 --> 00:13:30,399
キャッシュしておくという方法が紹介されていました

215
00:13:32,633 --> 00:13:35,966
ではここまでの内容を1回まとめたいと思います

216
00:13:37,299 --> 00:13:38,966
これまでのフォーマッターというのは

217
00:13:38,966 --> 00:13:42,633
非常に高機能でカスタマイズ性の高いものでした

218
00:13:42,633 --> 00:13:47,633
ただしいくつかのパターンでは仮にそのカスタマイズに誤りがあっても

219
00:13:47,633 --> 00:13:49,932
コンパイル時に気づくことはできず

220
00:13:49,932 --> 00:13:52,633
実際に動かして確認するといった必要がありました

221
00:13:54,365 --> 00:13:57,633
またフォーマッターのインスタンスを生成するコストや

222
00:13:57,633 --> 00:13:59,799
あとは説明は省略したんですけれども

223
00:13:59,799 --> 00:14:03,633
プロパティの変更のコストも高いということが知られています

224
00:14:05,100 --> 00:14:07,765
そのためそれらの回数を減らすために

225
00:14:07,765 --> 00:14:10,365
自分でキャッシュ機構を実装するなどして

226
00:14:10,365 --> 00:14:12,899
対応を行うというのがベストプラクティスでした

227
00:14:14,332 --> 00:14:17,600
あとは Swift は値型がよく使われますが

228
00:14:17,600 --> 00:14:19,966
このフォーマッターは参照型です

229
00:14:20,500 --> 00:14:24,633
そのキャッシュの共有を行う際もそれを意識する必要があります

230
00:14:25,633 --> 00:14:28,799
あとはスレッドセーフであるかどうかというのも

231
00:14:28,799 --> 00:14:32,633
今のスイフトコンカレンシーの時代には強く意識する必要があるでしょう

232
00:14:34,000 --> 00:14:37,166
そして SwiftUI などで流行っている宣言型ではなく

233
00:14:37,166 --> 00:14:40,299
命令型のAPIデザインとなっています

234
00:14:42,332 --> 00:14:45,732
これまでですね、フォーマッターについて

235
00:14:45,732 --> 00:14:49,633
どれが良いとか悪いとかを深掘るつもりはないんですけれども

236
00:14:49,633 --> 00:14:54,566
ただそれらの姿勢が考え方を活かしながら

237
00:14:54,566 --> 00:14:58,033
今のSwiftの時代にふさわしい新たなインターフェースとして

238
00:14:58,033 --> 00:15:00,533
登場したのが FormatStyle です

239
00:15:02,666 --> 00:15:05,299
この FormatStyle というのは

240
00:15:05,299 --> 00:15:07,799
正確にはプロトコルの名前になっています

241
00:15:07,799 --> 00:15:12,899
iOS 15以降で利用可能で、特定のデータ型を別な型

242
00:15:12,899 --> 00:15:15,299
例えば文字列、ストリング型ですね

243
00:15:15,299 --> 00:15:19,832
に変換するためのインターフェースを定義するものになっています

244
00:15:20,799 --> 00:15:22,666
さまざまな用途に応じた

245
00:15:22,666 --> 00:15:26,033
フォーマットのスタイルがデフォルトで用意されていまして

246
00:15:26,033 --> 00:15:31,265
iOS 26までには46の FormatStyle が存在しています

247
00:15:33,232 --> 00:15:37,166
こちらが従来のフォーマッターで書かれたコードですが

248
00:15:37,166 --> 00:15:42,399
これを FormatStyle を用いるように変更しますと、このようになります

249
00:15:42,966 --> 00:15:46,265
コードが非常に少なくなりましたね

250
00:15:46,966 --> 00:15:49,698
両者のコードを見比べてみましょう

251
00:15:49,698 --> 00:15:55,265
これまで存在していたデイトフォーマッターの記述がそもそも消えました

252
00:15:55,265 --> 00:15:59,832
またこれまではフォーマッター側に存在するメソッドに

253
00:15:59,832 --> 00:16:01,466
引数

254
00:16:01,466 --> 00:16:05,966
フォーマッター側に存在するメソッドの引数にデータを渡していましたが

255
00:16:05,966 --> 00:16:07,865
 FormatStyle を使う方法では

256
00:16:07,865 --> 00:16:13,198
データに対してformattedというメソッドをつけるというように変わりました

257
00:16:15,100 --> 00:16:19,365
データに応じたフォーマッターのインスタンスを自分で作ることなく

258
00:16:19,365 --> 00:16:23,566
ただシンプルにデータに対してformattedをつけることだけで

259
00:16:23,566 --> 00:16:26,000
簡単にフォーマットできます

260
00:16:27,299 --> 00:16:32,466
このformattedメソッドの中で詳細なスタイルの指定をすることもできます

261
00:16:32,466 --> 00:16:36,832
指定しない場合はデフォルトの実装が使用されます

262
00:16:38,166 --> 00:16:40,566
柔軟なスタイル指定というのも

263
00:16:40,566 --> 00:16:43,732
先ほどのローマ字の小文字のYがどうで

264
00:16:43,732 --> 00:16:45,966
大文字のMがどうで、みたいな

265
00:16:45,966 --> 00:16:49,765
複雑な文字列のスタイルのルールっていうのを覚えることなく

266
00:16:49,765 --> 00:16:54,033
年が欲しいから year をつけて、月が欲しいから month をつけて

267
00:16:54,033 --> 00:16:58,698
と、このコード補完を効かせながら安全に書くことができます

268
00:16:58,698 --> 00:17:02,865
あとは後から読んだ時の可読性も非常に高いかなと思います

269
00:17:04,965 --> 00:17:08,732
FormatStyle はこのSwiftのために設計されていて

270
00:17:08,732 --> 00:17:12,799
この外側のインターフェースの部分は100%Swiftで書かれています

271
00:17:14,066 --> 00:17:18,266
またフォーマッターがクラス、参照型であったのに対し

272
00:17:18,266 --> 00:17:23,599
 FormatStyle は構造体、値型で作るのが基本ということになり

273
00:17:23,599 --> 00:17:26,099
スタック上での割り当てとかコピーオンライトとか

274
00:17:26,099 --> 00:17:30,299
コンパイラーによる最適化の恩恵を受けやすいだろうという利点があります

275
00:17:31,465 --> 00:17:35,232
スタイルの指定はカターン安全に行うことができて

276
00:17:35,232 --> 00:17:39,333
 FormatStyle の内部で使用されているフォーマッターのインスタンスは

277
00:17:39,333 --> 00:17:42,365
フレームワーク側で自動的にキャッシュされます

278
00:17:42,365 --> 00:17:46,032
先ほどの手動でキャッシュするみたいなことを

279
00:17:46,032 --> 00:17:48,465
考えなきゃいけないというところから解放されて

280
00:17:48,465 --> 00:17:53,165
パフォーマンス上のメリットも一定程度享受できそうです

281
00:17:53,165 --> 00:17:56,833
あとは、流行りの宣言型のインターフェースとともに

282
00:17:56,833 --> 00:17:59,365
現代の人々から使いやすくなったというのが

283
00:17:59,365 --> 00:18:02,432
この FormatStyle です

284
00:18:03,500 --> 00:18:06,000
従来のこのフォーマッターと

285
00:18:06,000 --> 00:18:10,266
この FormatStyle のインターフェースなどの違いが分かったところで

286
00:18:10,266 --> 00:18:15,665
プロトコルで定義されている FormatStyle のルールについて紹介します

287
00:18:17,032 --> 00:18:20,766
 FormatStyle プロトコルに適合する方は

288
00:18:20,766 --> 00:18:26,833
プライマリーアソシエイティットタイプとして、フォーマットの入力側の方と

289
00:18:26,833 --> 00:18:32,633
出力側の方がそれぞれ何であるかというのを指定する必要があります

290
00:18:33,465 --> 00:18:37,465
そして実際に入力された値を使ってフォーマットを行い

291
00:18:37,465 --> 00:18:41,000
結果を出力するメソッドの実装が必要です

292
00:18:42,465 --> 00:18:49,500
本日の最初に示した、このデイト型からストリング型へのフォーマットを行う場合

293
00:18:49,500 --> 00:18:58,232
その FormatInput というのが Date 型になって、FormatOutput というのが String 型ということになります

294
00:19:00,165 --> 00:19:04,432
ここからは、iOS 26 までに含まれている

295
00:19:04,432 --> 00:19:10,232
すぐに使える FormatStyle の全種類について列挙してみようと思います

296
00:19:10,232 --> 00:19:17,199
ただ、これまでは日時のフォーマットについてお話ししてきましたが

297
00:19:17,199 --> 00:19:22,199
今の iOS には他のデータに対応した FormatStyle というのも存在しています

298
00:19:22,199 --> 00:19:26,665
ただ、これをすべて一度に覚えることは難しいですし

299
00:19:26,665 --> 00:19:30,299
ここからどんどん列挙するとおそらく眠くなってしまうので

300
00:19:30,299 --> 00:19:36,633
もしよろしければ、この後公開される資料ですとかアーカイブなどで振り返りに来ていただければと思います

301
00:19:38,398 --> 00:19:42,599
ではまず、日時や時間について見ていきましょう

302
00:19:42,599 --> 00:19:48,599
Date.FormatStyle というのは日付と時刻のフォーマットを行う

303
00:19:48,599 --> 00:19:50,532
最も基本的なスタイルです

304
00:19:50,532 --> 00:19:56,133
デート型のプロパティに formatted をつけるとこの FormatStyle が使われます

305
00:19:56,133 --> 00:20:01,365
date 引数と time 引数でスタイルを細かく指定でき

306
00:20:01,365 --> 00:20:04,833
様々な表現をすることができます

307
00:20:04,833 --> 00:20:06,865
また、メソッドチェーンを使って

308
00:20:06,865 --> 00:20:14,032
年、月、日、時、分、秒、あとはタイムゾーンなども詳細にしていきます

309
00:20:14,032 --> 00:20:18,266
フィールドの順序というのが最終的な出力に影響しません

310
00:20:18,266 --> 00:20:22,865
OS がロケルに応じて適切に配置してくれます

311
00:20:22,865 --> 00:20:31,066
例えばこの上の例はアメリカ英語のように月、日、年というふうな順番で指定しているんですけれども

312
00:20:31,066 --> 00:20:36,898
これを日本の日本語環境で動かすと、ちゃんと年、月、日と表示されます

313
00:20:36,898 --> 00:20:40,799
その他にも月とか曜日の省略形表示であるとか

314
00:20:40,799 --> 00:20:46,432
あとは数字が一桁の場合にゼロでパリングを埋めるみたいな処理もしてできます

315
00:20:48,232 --> 00:20:54,032
続いて、Date.ISO8601FormatStyle というのがあります

316
00:20:54,032 --> 00:20:58,633
formatted のところで .iso8601 と書くことで

317
00:20:58,633 --> 00:21:01,000
これはサーバーとのデータ通信など

318
00:21:01,000 --> 00:21:03,965
ISO 8601 という仕様がありますが

319
00:21:03,965 --> 00:21:07,699
その日時が必要な場合に非常に便利に使えます

320
00:21:10,199 --> 00:21:12,766
これにタイムゾーンの情報をつけたり

321
00:21:12,766 --> 00:21:14,833
先ほどのデイトフォーマットのように

322
00:21:14,833 --> 00:21:21,000
 欲しい要素をメソッドチェーンで書いて出力する要素を細かく指定できます

323
00:21:22,099 --> 00:21:26,432
ISO 26 では、この DateComponents の方にも

324
00:21:26,432 --> 00:21:30,833
ISO 8601 形式のスタイルが用意されました

325
00:21:32,799 --> 00:21:36,365
こちらも新しく導入されたものになりますが

326
00:21:36,365 --> 00:21:42,066
 HTTP の RFC 9110 に準拠した FormatStyle というのもあります

327
00:21:42,566 --> 00:21:44,865
こちらはウェブの通信において

328
00:21:44,865 --> 00:21:50,898
日時のヘッダーとかを取り扱う際に 格段に容易になるかなと思います

329
00:21:52,165 --> 00:21:56,232
これも同様に DateComponents 版が存在します

330
00:21:57,799 --> 00:22:01,133
出力形式をもっとカスタマイズしたい場合は

331
00:22:01,133 --> 00:22:04,965
Date.VerbatimFormatStyle を使います

332
00:22:05,766 --> 00:22:10,566
先に述べた従来の DateFormatter の dateFormat プロパティのように

333
00:22:10,566 --> 00:22:14,965
カスタムのフォーマットを文字列で直接指定できるスタイルです

334
00:22:14,965 --> 00:22:20,865
ただ、このデイトフォーマットストリングによって提供される ストリングインターポレーションですね

335
00:22:20,865 --> 00:22:26,799
文字列補完項群によって、 タイプセーフにフォーマットをしてできるようになっています

336
00:22:26,799 --> 00:22:29,099
例えば、ここのように

337
00:22:29,099 --> 00:22:35,099
年号と年、月、日をピリオードでつなぐことが求められる

338
00:22:35,099 --> 00:22:37,699
時数のフォーマットというのがあるんですけれども

339
00:22:37,699 --> 00:22:42,898
これをフォーマティでロケルとかタイムゾーンと一緒に指定すれば

340
00:22:42,898 --> 00:22:47,032
iOSデバイスのカレンダーが西暦でも和暦でも

341
00:22:47,032 --> 00:22:56,633
確実にこの例はR07.09.20のように時数の規格にあった出力が得られます

342
00:22:58,898 --> 00:23:02,766
続きまして、この Date.IntervalFormatStyle は

343
00:23:02,766 --> 00:23:07,066
二つのデイトの間の期間をフォーマットするためのスタイルです

344
00:23:07,066 --> 00:23:11,365
デイトの範囲型を入力として受け取りまして

345
00:23:11,365 --> 00:23:15,566
ユーザーのロケルに合わせた自然な形で期間をフォーマットします

346
00:23:15,898 --> 00:23:21,633
例えば、時刻は省略して日付の期間だけを出力するときに

347
00:23:21,633 --> 00:23:29,299
日本の日本語環境であれば19日から21日とナミセン、ナミダッシュで出力されて

348
00:23:29,299 --> 00:23:37,532
アメリカ英語の環境であれば September 19 – 21 という感じで出力されます

349
00:23:38,566 --> 00:23:46,365
そして Date.ComponentsFormatStyle というのもありまして、 これは日付のコンポーネント間の差をフォーマットします

350
00:23:46,566 --> 00:23:48,766
二つの日付の間を

351
00:23:48,766 --> 00:23:52,266
二日であるとか二日と二時間のように

352
00:23:52,266 --> 00:23:54,932
人間が読みやすい形式で表示します

353
00:23:55,432 --> 00:24:00,165
こちらもスタイル、引数で出力スタイルをカスタマイズすることもできます

354
00:24:02,566 --> 00:24:08,032
似たようなもので Date.RelativeFormatStyle というのもあります

355
00:24:08,032 --> 00:24:10,965
こちらは現在の時刻を基準とした

356
00:24:10,965 --> 00:24:16,000
相対的な日時をフォーマットするためのスタイルです

357
00:24:16,000 --> 00:24:18,232
named を使用すると

358
00:24:18,232 --> 00:24:23,566
 先月、今月、来月といった自然言語の表現が得られます

359
00:24:23,566 --> 00:24:29,898
numeric スタイルにすると、 1ヶ月後のように数値での相対表現ができます

360
00:24:31,000 --> 00:24:34,099
非単位の相対表現もできるようになってまして

361
00:24:34,099 --> 00:24:38,299
一昨日、昨日、今日、明日、明後日というような表現が

362
00:24:38,299 --> 00:24:42,165
ロケールに応じて自動的に適用されます

363
00:24:42,165 --> 00:24:46,965
この FormatStyle は現在時刻を基準として

364
00:24:46,965 --> 00:24:49,799
相対的なものを出力するんですけれども

365
00:24:50,398 --> 00:24:52,665
その基準を現在の時刻ではなくて

366
00:24:52,665 --> 00:24:54,566
任意の時刻にしたい場合は

367
00:24:54,566 --> 00:24:58,965
この Date.AnchoredRelativeFormatStyleの 方を使います

368
00:24:58,965 --> 00:25:02,299
特定の日時をアンカーとして指定して

369
00:25:02,299 --> 00:25:09,398
入力された日時を、 その基準として相対的なフォーマットを行います

370
00:25:13,398 --> 00:25:16,599
ここまで日時のフォーマットについてしゃべりまくったんですけれども

371
00:25:16,599 --> 00:25:22,432
数値のフォーマットというのもよく同じぐらい使われるかなと思います

372
00:25:22,432 --> 00:25:26,898
整数ですとか浮動小数点数ですとかデシマル型の

373
00:25:26,898 --> 00:25:29,665
それぞれに FormatStyle が用意されていて

374
00:25:29,665 --> 00:25:35,599
デフォルトでは3桁区切りなどのロケールに応じた表示が行われます

375
00:25:35,599 --> 00:25:41,633
日本の日本語環境だと3桁おきにカンマが出るというような感じですね

376
00:25:41,633 --> 00:25:44,333
さらに rounded 修飾詞を使うと

377
00:25:44,333 --> 00:25:47,532
四捨五入ですとか切り捨てとか切り上げといった

378
00:25:47,532 --> 00:25:51,865
数字の丸めのルールがありますけれども、 それも指定できます

379
00:25:51,865 --> 00:25:56,000
他にも有効桁数を指定できたり、指数表記にしたり

380
00:25:56,000 --> 00:26:00,133
 たくさんの修飾詞があってそれらを使うとカスタマイズできます

381
00:26:02,032 --> 00:26:05,532
それぞれの数値の型には百分率

382
00:26:05,532 --> 00:26:09,500
パーセントとしてフォーマットするスタイルも用意されています

383
00:26:09,500 --> 00:26:15,699
数値が自動的に100倍されてロケールに応じたパーセントの記号が付与されます

384
00:26:15,699 --> 00:26:19,066
パーセント記号をどこにつけるかですとか

385
00:26:19,066 --> 00:26:23,665
そもそもパーセント記号が何かというのもロケールに応じて違うので

386
00:26:23,665 --> 00:26:26,000
それらを自動調整してくれます

387
00:26:28,000 --> 00:26:32,266
同様に通貨としてフォーマットするスタイルも用意されています

388
00:26:32,266 --> 00:26:34,532
 通貨コードを指定することでロケールに応じた

389
00:26:34,532 --> 00:26:40,199
通貨記号や、 少数点以下の桁数というのもここでサポートされます

390
00:26:40,799 --> 00:26:44,365
同じ国や地域の中でも言語が違えば

391
00:26:44,365 --> 00:26:47,633
通貨の記号を表示する場所が変わったりもするので

392
00:26:47,633 --> 00:26:49,199
それもサポートしています

393
00:26:52,133 --> 00:26:56,299
続いて、iOS 16 で導入された

394
00:26:56,299 --> 00:26:59,365
デュレーション型を使う FormatStyle も紹介します

395
00:27:01,000 --> 00:27:03,932
Duration.TimeFormatStyle というのがありまして

396
00:27:03,932 --> 00:27:10,532
これはデュレーションの値を時、分、秒の形式でフォーマットします

397
00:27:11,599 --> 00:27:13,465
パターンという引数があって

398
00:27:13,465 --> 00:27:17,699
ここに hourMinute とか hourMinuteSecond などを指定することで

399
00:27:17,699 --> 00:27:22,566
時間と分と秒の表示形式を細かく制御できます

400
00:27:23,299 --> 00:27:29,665
padHourToLength などを使うと桁数を揃えるということもできます

401
00:27:31,365 --> 00:27:34,633
これには UnitsFormatStyle というのもありまして

402
00:27:34,633 --> 00:27:40,032
これはデュレーションの値を自動的に最適な単位を使う形でフォーマットしてくれます

403
00:27:40,032 --> 00:27:43,633
この使うべき単位をこちらから指定することもできますし

404
00:27:43,633 --> 00:27:46,665
あとはそのゼロで桁を埋めるということもできます

405
00:27:48,965 --> 00:27:53,000
続いて計測値に関する FormatStyle です

406
00:27:54,133 --> 00:27:57,465
Swiftにおける計測値について皆さんご存知でしょうか

407
00:27:57,465 --> 00:28:01,032
Swiftのファンデーションには様々な値を示すことができる

408
00:28:01,032 --> 00:28:03,500
Measurement という単位があります

409
00:28:05,199 --> 00:28:08,865
例えば面積を示すデータがあるときに

410
00:28:08,865 --> 00:28:12,732
シンプルにイント型とかダブル型を使うことが

411
00:28:12,732 --> 00:28:15,266
真っ先に思い浮かぶかもしれませんが

412
00:28:15,599 --> 00:28:19,032
ユニットエリアのメジャーメント型にしておくことで

413
00:28:19,032 --> 00:28:22,833
型システムによってこのデータが面積であることを

414
00:28:22,833 --> 00:28:24,500
明確に示すことができます

415
00:28:25,398 --> 00:28:29,766
またそのデータの単位も同時に持つことができます

416
00:28:29,766 --> 00:28:36,432
ここでは東北の3つの県の面積を平方キロメートルで表しています

417
00:28:36,432 --> 00:28:41,398
なので後ろに squareKilometers って書いてますね

418
00:28:41,699 --> 00:28:44,266
これらに formatted をつけることで

419
00:28:44,266 --> 00:28:47,732
データの数値とその単位を一緒に出力してくれます

420
00:28:47,732 --> 00:28:52,799
 単位の出力のスタイルをこのキロメートル二乗というところから

421
00:28:52,799 --> 00:28:56,465
漢字とカタカナのように変換することもできますし

422
00:28:56,465 --> 00:29:00,299
これをアメリカ英語向けにフォーマットすると

423
00:29:00,299 --> 00:29:04,000
平方キロメートルが平方マイルへと変換されて出力されます

424
00:29:06,665 --> 00:29:14,165
またメモリやファイルなどのサイズを表すに適した FormatStyle も用意されています

425
00:29:14,833 --> 00:29:18,532
キロバイトとかメガバイトとかギガバイトなど

426
00:29:18,532 --> 00:29:21,965
最適な単位に自動的に変換して出力します

427
00:29:21,965 --> 00:29:27,000
こちらもスタイル引数やユニット引数で表示形式や単位を制御できます

428
00:29:29,633 --> 00:29:34,599
続いて人の名前をフォーマットするための FormatStyle というのも存在します

429
00:29:34,599 --> 00:29:41,266
 人の名前に関する型である PersonNameComponents という型がありますが

430
00:29:41,266 --> 00:29:45,133
ここから人の名前というのをフォーマットできます

431
00:29:45,133 --> 00:29:51,766
スタイル引数でショート、ミディアム、ロングなどといった表示形式を選択できて

432
00:29:51,766 --> 00:29:55,833
ロケールに応じた姓名の順序を 自動で適用してくれます

433
00:29:58,232 --> 00:30:04,333
このようにローマ字表記で仮に 姓名、ニックネームというのを指定しますと

434
00:30:04,333 --> 00:30:08,066
短縮形の方ではイニシャルが生成されたりですとか

435
00:30:08,066 --> 00:30:12,133
日本のロケールでは姓名の順番になりますが

436
00:30:12,133 --> 00:30:15,000
英語のロケールでは名、姓の順番に

437
00:30:15,000 --> 00:30:17,898
イニシャルが出るというような違いがあります

438
00:30:21,532 --> 00:30:23,932
もうすぐ全部の紹介が終わりますよ

439
00:30:23,932 --> 00:30:28,633
URLに関する FormatStyle というのも デフォルトで存在しています

440
00:30:28,633 --> 00:30:31,965
URLをホスト、パス、クエリなど

441
00:30:31,965 --> 00:30:35,833
特定のコンポーネントに絞ってフォーマットすることができます

442
00:30:35,833 --> 00:30:40,799
例えばこのようにクエリの部分だけ取り出したりですとか

443
00:30:40,799 --> 00:30:42,633
あとはブラウザーアプリのように

444
00:30:42,633 --> 00:30:47,133
URLのドメイン部分だけを ユーザーに表示したりしたいという場合に

445
00:30:47,133 --> 00:30:48,500
役に立ちそうです

446
00:30:51,833 --> 00:30:56,199
その他少し特殊な FormatStyle というのを 最後に紹介します

447
00:30:57,766 --> 00:31:04,965
配列などのシーケンスの要素を連結して 一つの文字列としてフォーマットするスタイルが用意されています

448
00:31:04,965 --> 00:31:10,133
このスタイルはロケールに応じて カンマとかあとはトーテンといった

449
00:31:10,133 --> 00:31:17,365
適切な区切り文字ですとか あとは接続詞を自動で適用してくれます

450
00:31:18,133 --> 00:31:25,133
例えば日本語ではリンゴ、テン、バナナ、 テン、ミカンという風になったりですとか

451
00:31:25,133 --> 00:31:30,133
英語ではアップル、カンマ、バナナ、 カンマ、アンド、オレンジのように

452
00:31:30,133 --> 00:31:33,365
人間が読むときにとても自然なスタイルになってくれます

453
00:31:35,133 --> 00:31:39,133
このリスト FormatStyle の メンバースタイルという引数に

454
00:31:39,133 --> 00:31:42,133
別の FormatStyle を 渡すということもできまして

455
00:31:42,133 --> 00:31:46,299
リストの各要素に個別にフォーマットをしつつ

456
00:31:46,299 --> 00:31:49,333
最終的に連結された文字列というのを

457
00:31:49,333 --> 00:31:51,732
このリスト FormatStyle で やることもできます

458
00:31:53,133 --> 00:31:57,133
数字は数字でフォーマットしておいて 最後それを一つの文字列に

459
00:31:57,133 --> 00:32:00,865
もう一回フォーマットするというようなのが こちらのサンプルですね

460
00:32:02,133 --> 00:32:05,133
これは私たちが直接使うことは ほぼないんですけれども

461
00:32:05,133 --> 00:32:09,133
ストリングをストリングに フォーマットするという方も存在します

462
00:32:09,133 --> 00:32:12,699
入力と出力が変わらないという スタイルなんですけれども

463
00:32:12,699 --> 00:32:15,032
例えばジェネリックなコンテキストにおいて

464
00:32:15,032 --> 00:32:17,532
 FormatStyle がどうしても必要みたいなときに

465
00:32:17,532 --> 00:32:19,299
デフォルトのプレースホルダーとして

466
00:32:19,299 --> 00:32:21,833
使われるのがこちらのストリングスタイルでした

467
00:32:24,066 --> 00:32:25,266
こうですね

468
00:32:27,599 --> 00:32:33,500
これはストアキットのフレームワークにも  FormatStyle が存在していました

469
00:32:33,500 --> 00:32:38,032
こちらはサブスクの期間を

470
00:32:38,032 --> 00:32:43,133
日とか月とか年の単位で フォーマットするためのスタイルが用意されています

471
00:32:43,133 --> 00:32:47,465
これで例えばApp Store Connectとかで指定したサブスクの期間を

472
00:32:47,465 --> 00:32:50,732
アプリ内で適切にローカライズする ということが可能です

473
00:32:54,133 --> 00:32:55,133
大変お疲れ様でした

474
00:32:55,133 --> 00:33:01,133
以上が iOS 26 までに搭載されている 基本の FormatStyle のすべてでした

475
00:33:01,532 --> 00:33:03,865
いつか皆さんの普段の開発で あの FormatStyle があったかもしれないなと

476
00:33:03,865 --> 00:33:06,000
あの FormatStyle があったかもしれないなと

477
00:33:06,000 --> 00:33:08,532
思い出すきっかけになれば嬉しいです

478
00:33:10,898 --> 00:33:15,865
それではこの FormatStyle の外側 インターフェースの話に少し戻りたいと思います

479
00:33:17,133 --> 00:33:20,665
先ほど挙げた FormatStyle の中には

480
00:33:20,665 --> 00:33:24,465
出力される文字列に簡単に装飾ができるタイプの

481
00:33:24,465 --> 00:33:26,099
 FormatStyle というのがあります

482
00:33:27,898 --> 00:33:29,898
このフォーマットの出力の型が

483
00:33:29,898 --> 00:33:32,066
修飾できる文字列である

484
00:33:32,066 --> 00:33:34,500
アトリビューテッドストリングになっています

485
00:33:36,633 --> 00:33:41,133
それではそれがどのように動作するかというのを イメージ見てみましょう

486
00:33:41,365 --> 00:33:44,199
 FormatStyle で書き直した最初のスクリーンショットが

487
00:33:44,199 --> 00:33:45,965
こちらになりますが

488
00:33:47,133 --> 00:33:51,032
ここの日時をフォーマットしている部分を取り出しました

489
00:33:52,599 --> 00:33:56,299
そしてアトリビュートに対応している  FormatStyle の場合は

490
00:33:56,299 --> 00:33:58,566
このように FormatStyle の末尾に

491
00:33:58,566 --> 00:34:02,133
アトリビューテッド、もしくはアトリビューテッドスタイルの

492
00:34:02,133 --> 00:34:05,133
どちらかをつけることができまして

493
00:34:05,133 --> 00:34:11,132
例えばこのように年の部分に対してのみ フォーグラウンドカラーをレッドにするという指定をすれば

494
00:34:11,132 --> 00:34:12,865
それがビューに反映されます

495
00:34:15,132 --> 00:34:17,132
その他よく見る例ですと

496
00:34:17,132 --> 00:34:24,465
例えば通貨をフォーマットしたときに通貨の記号の部分だけ 数字よりもフォントサイズを小さくしたいみたいな

497
00:34:24,465 --> 00:34:26,898
要望が出ることがありますが

498
00:34:26,898 --> 00:34:31,132
これもアトリビューテッドな FormatStyle で 実現することができます

499
00:34:31,132 --> 00:34:36,000
これは円マークの部分が数字よりも ちょっと小さいという感じですね

500
00:34:40,932 --> 00:34:43,132
残り時間の関係で説明は省略しますけれども

501
00:34:43,132 --> 00:34:46,733
iOS 18 からの SwiftUI のストップウォッチですとか

502
00:34:46,733 --> 00:34:52,166
タイマーのような表示に特化したアトリビューテッドな  FormatStyle というのも存在します

503
00:34:53,898 --> 00:34:56,365
では、その SwiftUI の話が出てきましたので

504
00:34:56,365 --> 00:34:59,465
この SwiftUI から FormatStyle を使うという方法も

505
00:34:59,465 --> 00:35:01,532
少し見ていきましょう

506
00:35:03,065 --> 00:35:05,099
このトークの序盤にですね

507
00:35:05,099 --> 00:35:07,166
 SwiftUI の Text のイニシャライザーは

508
00:35:07,166 --> 00:35:11,199
デート型を渡すことはできないと説明しました

509
00:35:12,065 --> 00:35:15,833
なので、Formattedを使うことでString型に変えて

510
00:35:15,833 --> 00:35:18,532
解決しましょうというお話をしたんですけれども

511
00:35:18,532 --> 00:35:21,333
実はですね、テキストにはデート型を受け取れる

512
00:35:21,333 --> 00:35:23,898
イニシャライザーが別に存在しています

513
00:35:24,833 --> 00:35:26,500
それがこの形です

514
00:35:26,833 --> 00:35:30,932
テキストの第一引数には何かしらのデータを置いて

515
00:35:30,932 --> 00:35:35,532
第二引数であるフォーマットの部分に FormatStyle を渡すことで

516
00:35:35,532 --> 00:35:38,432
 SwiftUI のテキストとして取り扱うことができます

517
00:35:39,500 --> 00:35:42,166
これが最もベストな方法かなと思います

518
00:35:42,166 --> 00:35:45,632
特にですね、動作の制約が厳しいウィジェットですとか

519
00:35:45,632 --> 00:35:47,099
ライブアクティビティですとか

520
00:35:47,099 --> 00:35:50,132
コンプリケーションみたいなのを構築する場合には

521
00:35:50,132 --> 00:35:52,833
特にこれを使うべきでしょう

522
00:35:53,666 --> 00:35:56,398
こちらのサンプルコードでは正直微妙なんですけれども

523
00:35:56,398 --> 00:35:57,699
データの型によっては

524
00:35:57,699 --> 00:36:02,565
パフォーマンスの良いディスクリエイト FormatStyle というのは別に存在していて

525
00:36:02,565 --> 00:36:05,065
そちらの恩恵を受けられる可能性もあります

526
00:36:05,333 --> 00:36:08,965
もしよろしければス Ask the Speaker などでおしゃべりできたら嬉しいです

527
00:36:10,233 --> 00:36:14,532
またさらにですね、ここでVStackを使っていますけれども

528
00:36:14,532 --> 00:36:19,266
これを一つのテキストとして取り扱いたい場合は

529
00:36:19,266 --> 00:36:21,065
String Interpolation の方で

530
00:36:21,065 --> 00:36:26,266
このフォーマットという引数を使う書き方も存在します

531
00:36:28,833 --> 00:36:33,833
これまではこちらからユーザーに何か見せるためのフォーマットを使う例で

532
00:36:33,833 --> 00:36:36,833
 SwiftUI  のテキストを使ってきましたが

533
00:36:36,833 --> 00:36:40,233
このフォーマットはテキストフィールドにも使うことができます

534
00:36:41,833 --> 00:36:46,833
何かしらのデータをストリングにフォーマットするというのはずっと見てきたんですけれども

535
00:36:46,833 --> 00:36:49,833
これを逆にユーザーからストリングを受け取って

536
00:36:49,833 --> 00:36:54,833
それを何かしらの手段で解析してこちらのデータ型に変換する

537
00:36:54,833 --> 00:36:56,833
つまりこれはParseの処理ですね

538
00:36:56,833 --> 00:36:59,365
これが必要な場合があります

539
00:37:04,300 --> 00:37:09,833
ここで ParseableFormatStyle というのが存在します

540
00:37:10,632 --> 00:37:14,833
この ParseableFormatStyle における Parse の処理というのは

541
00:37:14,833 --> 00:37:18,833
ParseStrategy のこちらで定義されています

542
00:37:18,833 --> 00:37:24,099
こちらに ParseInput と ParseOutput という型がありますが

543
00:37:24,099 --> 00:37:26,432
これに注目してください

544
00:37:26,432 --> 00:37:29,599
この ParseInput と ParseOutputというのは

545
00:37:29,599 --> 00:37:33,199
元の FormatStyle のInputとOutputと

546
00:37:33,199 --> 00:37:36,532
それぞれ対の関係になるように定められていまして

547
00:37:36,532 --> 00:37:40,699
これによってデータのフォーマットとパースというのが

548
00:37:40,699 --> 00:37:44,500
それぞれ逆向きの関係になっていることが表現されています

549
00:37:44,500 --> 00:37:47,266
僕はこの表現方法めちゃめちゃ好きです

550
00:37:48,333 --> 00:37:51,965
この日時や数値ですとかURLみたいな

551
00:37:51,965 --> 00:37:55,099
規則が明確な FormatStyle を中心に

552
00:37:55,099 --> 00:37:58,833
それらはParseableFormatStyleにも適合しています

553
00:37:58,833 --> 00:38:03,833
この人の名前もParse可能というのが驚きですね

554
00:38:05,032 --> 00:38:07,398
それではこのParseableFormatStyleについては

555
00:38:07,398 --> 00:38:11,833
これを自作する方法を見ながら理解を進めてみることにしましょう

556
00:38:12,398 --> 00:38:15,699
OSに含まれていないスタイルでフォーマットしたい場合

557
00:38:15,699 --> 00:38:19,032
 FormatStyle を自作するという選択肢があります

558
00:38:20,666 --> 00:38:23,666
こちらは私がOSSで開発している

559
00:38:23,666 --> 00:38:26,500
Xcodeのコーディングインテリジェンス機能を

560
00:38:26,500 --> 00:38:28,898
ChatGPTとかCloud以外のモデルでも

561
00:38:28,898 --> 00:38:31,465
使えるようにするというツールがありまして

562
00:38:31,465 --> 00:38:36,333
その中にはユーザーが任意のポート番号を設定できるように

563
00:38:36,333 --> 00:38:40,833
 SwiftUI の TextFiled を使った画面が存在します

564
00:38:41,865 --> 00:38:47,833
このポート番号というのはNWEndpointPortという型なんですけれども

565
00:38:47,833 --> 00:38:51,833
これとストリングのフォーマットを行う FormatStyle というのは

566
00:38:51,833 --> 00:38:54,132
今、標準には存在しません

567
00:38:54,132 --> 00:38:56,500
そのためこれを自分で作ります

568
00:38:58,833 --> 00:39:03,833
ではまず FormatStyle に適合するところから始めましょう

569
00:39:03,833 --> 00:39:06,833
NWEndpointPort型というのを受け取って

570
00:39:06,833 --> 00:39:10,965
それをストリングで返すフォーマットメソッドを実装します

571
00:39:12,599 --> 00:39:18,965
この型は rawValue を取ると UInt16 が得られるので

572
00:39:18,965 --> 00:39:23,099
これをさらに数値としてフォーマットして文字列にします

573
00:39:24,833 --> 00:39:27,833
そして標準の FormatStyle と同様に

574
00:39:27,833 --> 00:39:32,166
ショートカットを提供して無事に完成ということになります

575
00:39:32,833 --> 00:39:37,132
NWEndpointPort の後ろに formatted を付ければ

576
00:39:37,132 --> 00:39:39,199
フォーマットできるというものですね

577
00:39:41,300 --> 00:39:44,833
そしてその先のパーサブル FormatStyle にも

578
00:39:44,833 --> 00:39:46,500
適合させてみることにします

579
00:39:47,833 --> 00:39:49,532
これに適合するためには

580
00:39:49,532 --> 00:39:53,599
対応する ParseStrategy を定義する必要があるですけれども

581
00:39:53,599 --> 00:39:57,333
ParseStrategy のこの parse メソッドにおいて

582
00:39:57,333 --> 00:40:04,000
入力文字列を目的のNWEndpointPort型に変換するロジックを記述します

583
00:40:05,865 --> 00:40:08,699
こちらもアクセスするためのショートカットを書いて

584
00:40:08,699 --> 00:40:10,565
完成ということになります

585
00:40:10,833 --> 00:40:13,599
これでフォーマットの位置方向だけではなくて

586
00:40:13,599 --> 00:40:16,833
逆方向のパースも簡単に行えるようになりました

587
00:40:19,132 --> 00:40:20,766
本日はですね

588
00:40:20,766 --> 00:40:22,666
データのフォーマットというのは

589
00:40:22,666 --> 00:40:27,199
普段の開発でも常日頃行われているということを確認して

590
00:40:27,199 --> 00:40:31,532
フォーマットを行う手段、APIの移り変わりというのを眺めてみました

591
00:40:32,632 --> 00:40:35,599
標準で搭載されている FormatStyle というのは

592
00:40:35,599 --> 00:40:37,800
非常に多くの種類があって

593
00:40:37,800 --> 00:40:40,632
ただそのどれもが Swift らしい安全さや

594
00:40:40,632 --> 00:40:44,398
流行りの機構によってモダンに使えるということが分かりました

595
00:40:45,500 --> 00:40:53,865
また、自分自身で FormatStyle を作って、 拡張できるという柔軟さも備えていることが分かりました

596
00:40:54,666 --> 00:40:58,300
もし今あなたが携わっているプロジェクトで

597
00:40:58,300 --> 00:41:00,733
従来の方法でデータフォーマッティングをされているところがあれば

598
00:41:00,733 --> 00:41:04,565
この FormatStyle への移行もぜひ検討してみてください

599
00:41:06,833 --> 00:41:11,000
本トークの作成にあたっては、多くのAppleの公式のドキュメントですとか

600
00:41:11,000 --> 00:41:13,365
 WWDCのセッションも参考にしております

601
00:41:13,365 --> 00:41:16,233
これらは FormatStyle を深く理解する上で

602
00:41:16,233 --> 00:41:18,932
非常に役に立ちますのでお勧めです

603
00:41:20,766 --> 00:41:22,166
それではぜひ今日から

604
00:41:22,166 --> 00:41:25,766
そろそろ FormatStyle というのを始めてみてください

605
00:41:26,199 --> 00:41:26,898
以上となります

606
00:41:26,898 --> 00:41:28,199
ご静聴ありがとうございました

607
00:41:38,565 --> 00:41:40,565
(司会) 発表ありがとうございました

608
00:41:40,833 --> 00:41:43,432
それではQ&Aに入りたいと思います

609
00:41:43,432 --> 00:41:47,233
コメントやご質問のある方は、 手を挙げてお知らせください

610
00:41:49,833 --> 00:41:52,000
マイクをお持ちします。 お持ちください

611
00:41:59,532 --> 00:42:01,166
(Q) お話ありがとうございます

612
00:42:01,833 --> 00:42:07,199
今まで経験的に、 DateFormatter をずっと使ってきて

613
00:42:08,632 --> 00:42:10,632
ユニットテストとかの観点で

614
00:42:12,199 --> 00:42:17,699
ロケールとかタイムゾーンっていうのを、 現在設定じゃなくて外から指定して

615
00:42:18,833 --> 00:42:21,833
フォーマットを使うっていうことが 結構多かったんですけれども

616
00:42:21,833 --> 00:42:24,833
 FormatStyle を使った場合も、 そういったことは可能なんでしょうか

617
00:42:26,132 --> 00:42:28,132
(treastrain) はい。ご質問いただきありがとうございます

618
00:42:28,565 --> 00:42:33,000
デートに関する FormatStyle の修飾子で

619
00:42:33,000 --> 00:42:34,766
いろんなものを紹介しましたけれども

620
00:42:34,766 --> 00:42:38,233
その中にロケールを指定するという 修飾子も存在しています

621
00:42:38,233 --> 00:42:40,132
なので、それを使うことで

622
00:42:40,132 --> 00:42:44,465
ロケールを注入するということが可能かなと思いますし

623
00:42:44,465 --> 00:42:47,065
もしテスト用途みたいなところであれば

624
00:42:47,065 --> 00:42:50,032
そうですね、ロケールを注入できる

625
00:42:50,032 --> 00:42:52,898
自作の FormatStyle みたいなので一回ラップして

626
00:42:52,898 --> 00:42:55,233
そのラップした方に対して

627
00:42:55,233 --> 00:42:59,166
テストコード側からインジェクションするみたいな設計をすると

628
00:42:59,166 --> 00:43:02,699
結構外側から見たときにきれいかなと思いつつ

629
00:43:03,166 --> 00:43:05,500
それをやってますよというのを チームの中に周知しないと

630
00:43:05,500 --> 00:43:08,166
これは何の型なんだみたいな問題も 起きるかなと思うので

631
00:43:08,166 --> 00:43:11,532
そこはちょっといい塩梅を狙うのが必要かなとも思います

632
00:43:11,833 --> 00:43:12,833
(Q) ありがとうございます

633
00:43:16,065 --> 00:43:17,365
(司会) ありがとうございました

634
00:43:17,833 --> 00:43:21,833
他にコメントやご質問のある方は、 挙手をお願いします

635
00:43:31,233 --> 00:43:32,233
(Q) ありがとうございます

636
00:43:34,132 --> 00:43:37,132
すごい興味本位なことなんですけれども

637
00:43:37,132 --> 00:43:39,865
ダブル型とかフローティングポイントの数値の

638
00:43:39,865 --> 00:43:42,833
 FormatStyle というのがあったと思うんですけれども

639
00:43:42,833 --> 00:43:46,833
そういうフローティングポイントナンバー というのがよくあることとして

640
00:43:46,833 --> 00:43:51,833
丸目精度というのが結構考慮することが あったりするじゃないですか

641
00:43:51,833 --> 00:43:55,833
例えばよくある話として、 0.1たす2は0.3じゃなくて0.30000…

642
00:43:55,833 --> 00:43:57,666
みたいなことがあるんですけれども

643
00:43:57,666 --> 00:44:02,166
例えばその0.1たす0.2の結果をフォーマット

644
00:44:02,166 --> 00:44:06,032
単純に例えば formatted で

645
00:44:06,032 --> 00:44:08,699
出力するとどうなるのかなというのがちょっと気になりました

646
00:44:09,532 --> 00:44:11,000
(treastrain) はい、ありがとうございます

647
00:44:11,000 --> 00:44:15,333
ダブル同士の足し算をした結果を フォーマットする場合は

648
00:44:15,333 --> 00:44:20,099
0.33333の方でストリングとして 出力されてしまいます

649
00:44:20,099 --> 00:44:23,632
なので誤差を含んだ状態で フォーマットしてしまうので

650
00:44:23,632 --> 00:44:28,532
誤差がない計算というのは無理なわけですけれども

651
00:44:28,532 --> 00:44:33,465
そこの問題はフォーマットする前に解決するという考え方が

652
00:44:33,465 --> 00:44:38,865
一応 FormatStyle 側の見た目かなと自分は理解してます

653
00:44:42,833 --> 00:44:43,833
(司会) ありがとうございました

654
00:44:44,632 --> 00:44:48,132
他にコメントやご質問がある方は挙手をお願いします

655
00:44:58,465 --> 00:45:00,233
(Q) 発表ありがとうございます

656
00:45:01,199 --> 00:45:05,432
ローカライズの部分の話がいくつか出てきてたと思うんですけど

657
00:45:05,432 --> 00:45:07,266
一般に業務でやる場合は

658
00:45:07,266 --> 00:45:10,432
ローカライズストリングとかストリングカタログを使って

659
00:45:10,432 --> 00:45:15,065
行う部分と結構被る部分も役割としてはあったかなと思うんですけど

660
00:45:15,065 --> 00:45:17,865
どのように使い分けたりとか

661
00:45:17,865 --> 00:45:21,800
もしくはローカライズある程度 FormatStyle に寄せるべきなのかとか

662
00:45:21,800 --> 00:45:25,099
そういったところのお考えがあれば聞きたいです

663
00:45:25,565 --> 00:45:28,099
(treastrain) はい ありがとうございます

664
00:45:28,099 --> 00:45:30,565
途中で VStack の Text 二個じゃなくて

665
00:45:30,565 --> 00:45:33,865
Text 一個にする形式みたいなのを紹介しましたけども

666
00:45:33,865 --> 00:45:40,365
あれがローカライズドキーとかを使いたいときに

667
00:45:40,365 --> 00:45:44,099
あっちの方 書き方を使うっていうのが

668
00:45:44,099 --> 00:45:47,833
この FormatStyle の使い方かなというふうに思ってます

669
00:45:47,833 --> 00:45:54,699
私は FormatStyle で 40 分話すって結構僕えぐいかなと思ってるんですけども

670
00:45:54,699 --> 00:45:57,465
それが一応 FormatStyle 好きなので

671
00:45:57,465 --> 00:46:01,365
自分の個人の見解としてはローカライズアブルのほうに

672
00:46:01,365 --> 00:46:04,965
このフォーマット側のほうは含めずに

673
00:46:04,965 --> 00:46:09,766
例えば単位の取り扱いですとか地域に合わせた記号の表示みたいのは

674
00:46:09,766 --> 00:46:12,666
この FormatStyle 側に任せて

675
00:46:12,666 --> 00:46:15,965
ローカライズアブルエクシストリングスのほうには書かないっていうのは

676
00:46:15,965 --> 00:46:17,365
お勧めしているというか

677
00:46:17,365 --> 00:46:20,065
普段の個人開発ではそのようにしてます

678
00:46:20,500 --> 00:46:22,300
(Q) ありがとうございます

679
00:46:23,733 --> 00:46:25,599
(司会) ありがとうございます

680
00:46:25,599 --> 00:46:28,300
お時間的に次が最後になりそうです

681
00:46:28,300 --> 00:46:31,599
コメントやご質問のある方は挙手をお願いします

682
00:46:37,833 --> 00:46:40,465
それではお時間になりましたので

683
00:46:40,465 --> 00:46:45,000
これにてQAセッションは終了させていただきます

684
00:46:45,000 --> 00:46:47,666
これで1分間フィードバックのお時間です

