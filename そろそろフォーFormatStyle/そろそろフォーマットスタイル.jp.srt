1
01:00:00,000 --> 01:00:06,966
そろそろフォーマットスタイル

2
01:00:08,033 --> 01:00:12,366
はい それではそろそろフォーマットスタイルというタイトルで

3
01:00:12,366 --> 01:00:15,366
発表しますよろしくお願い致します

4
01:00:15,366 --> 01:00:18,566
発表は私 Tanaka Ryoga が務めさせていただきます

5
01:00:18,566 --> 01:00:22,566
普段はこちらのオレンジ色のアイコンで活動しております

6
01:00:22,566 --> 01:00:25,866
新しいiPhoneの色と同じオレンジ色ですね

7
01:00:25,866 --> 01:00:28,966
個人開発で Swift を使ったアプリケーションを開発したり

8
01:00:28,966 --> 01:00:32,833
あとは株式会社 DeNA でも iOS アプリケーションのデベロッパーを

9
01:00:32,833 --> 01:00:35,366
普段しております

10
01:00:35,366 --> 01:00:38,599
過去、この iOSDC Japan では 3 回

11
01:00:38,599 --> 01:00:40,966
いずれも40分のレギュラートークをしておりまして

12
01:00:40,966 --> 01:00:45,166
今回は 4 回目になります

13
01:00:45,366 --> 01:00:50,366
私の初めての登壇となったのが2021年のトークなんですけれども

14
01:00:50,366 --> 01:00:51,966
こちらのタイトルが

15
01:00:51,966 --> 01:00:55,400
あらゆる情報を楽に正しくストリングにフォーマットする

16
01:00:55,400 --> 01:00:58,166
というものでした

17
01:00:58,166 --> 01:01:00,366
当時のアーカイブを見てみますと

18
01:01:00,366 --> 01:01:03,066
様々なデータをフォーマッターを使って

19
01:01:03,066 --> 01:01:07,566
ストリングに変換していくという内容でした

20
01:01:07,566 --> 01:01:09,633
その年に日本で開催された

21
01:01:09,633 --> 01:01:13,366
国際的なスポーツの開会式のひと幕みたいなデザインで

22
01:01:13,366 --> 01:01:16,566
当時発表してました

23
01:01:16,566 --> 01:01:21,566
その中で2021年で最新のiOSのバージョンであった

24
01:01:21,566 --> 01:01:26,966
iOS15の新機能について少しだけ触れていました

25
01:01:26,966 --> 01:01:28,566
当時のスクリーンショットがこちらです

26
01:01:28,566 --> 01:01:31,566
もしかしたら後ろの方 見えないかもしれないんですけども

27
01:01:31,566 --> 01:01:34,566
Appleの新しい機能に関するドキュメントでは

28
01:01:34,566 --> 01:01:36,566
よくノーオーバービューアベイラブルと

29
01:01:36,566 --> 01:01:39,566
何も書いてないみたいなドキュメントが出てくるんですが

30
01:01:39,566 --> 01:01:41,333
当時そうなっていたのが

31
01:01:41,333 --> 01:01:46,566
本日のテーマであるフォーマットスタイル (FormatStyle) です

32
01:01:46,566 --> 01:01:50,566
フォーマットスタイルはiOS15以降で使用できる仕組みです

33
01:01:50,566 --> 01:01:53,566
リリースされた2021年の当時は

34
01:01:53,566 --> 01:01:57,566
例えばミニマムデプロイメントターゲットなどの関係で

35
01:01:57,566 --> 01:02:01,566
実プロダクトへの投入というのは難しかったかもしれないんですけれども

36
01:02:01,566 --> 01:02:03,566
あれから4年が経ちまして

37
01:02:03,566 --> 01:02:08,566
あとは先日 iOS 26 がリリースされた今

38
01:02:08,566 --> 01:02:11,566
Appleの資料によれば多くのユーザーのデバイスが

39
01:02:11,566 --> 01:02:14,566
すでにフォーマットスタイルをサポートしているという

40
01:02:14,566 --> 01:02:17,566
環境になっていることが分かります

41
01:02:17,566 --> 01:02:19,566
まさにフォーマットスタイルについて触れる

42
01:02:19,566 --> 01:02:24,566
ぴったりなタイミングかなと思って今回発表させていただきます

43
01:02:24,566 --> 01:02:28,566
本トークはSwiftやiOSアプリケーション開発における

44
01:02:28,566 --> 01:02:34,566
データのフォーマットについてこれから学ぼうとしている方

45
01:02:34,566 --> 01:02:37,566
従来のフォーマッターは使ったことがあるけれど

46
01:02:37,566 --> 01:02:42,566
この新しいフォーマットスタイルにはちょっと慣れていないという方

47
01:02:42,566 --> 01:02:44,566
あとは標準には用意されていない

48
01:02:44,566 --> 01:02:47,566
独自のフォーマットスタイルの作り方のサンプルを

49
01:02:47,566 --> 01:02:52,566
知りたい方に向けて発表します

50
01:02:52,566 --> 01:02:58,566
それでは改めましてデータのフォーマットとは何でしょうか

51
01:02:58,566 --> 01:03:01,566
ここに一つスクリーンショットがあります

52
01:03:01,566 --> 01:03:04,566
画面中央に本トークのタイトルと

53
01:03:04,566 --> 01:03:09,566
あとは開始日時が表示されています

54
01:03:09,566 --> 01:03:13,566
SwiftUIのコードで示すとこのようになっています

55
01:03:13,566 --> 01:03:21,566
今はトークの開始日時の部分がテキストに直接文字列で書かれていますね

56
01:03:21,566 --> 01:03:26,566
このタイトルや開始日時がビューの外から与えられるようにします

57
01:03:26,566 --> 01:03:30,566
さらにSwiftには日時を取り扱うことのできる

58
01:03:30,566 --> 01:03:32,566
Date という型がありますから

59
01:03:32,566 --> 01:03:37,566
この Date のプロパティの型を今の String 型から

60
01:03:37,566 --> 01:03:40,566
Date 型で渡されてくるようにします

61
01:03:40,566 --> 01:03:43,566
しかしこのままのコードですと

62
01:03:43,566 --> 01:03:45,566
SwiftUIのテキストのイニシャライザに

63
01:03:45,566 --> 01:03:49,566
この Date 型を渡すことはできないというエラーが発生して

64
01:03:49,566 --> 01:03:54,566
ビルドが通らなくなってしまいます

65
01:03:54,566 --> 01:03:56,566
このビルドエラーを解消するためには

66
01:03:56,566 --> 01:04:01,566
型でいうとこの Date 型から何らかの手段を使って

67
01:04:01,566 --> 01:04:04,566
String 型へと変換し

68
01:04:04,566 --> 01:04:08,566
すいません、SwiftUI のテキストへ渡すようにすると良さそうです

69
01:04:08,566 --> 01:04:10,566
こうですね

70
01:04:11,133 --> 01:04:15,500
それではこの変換を行う方法について考えてみようと思います

71
01:04:17,366 --> 01:04:19,033
Swiftの Date 型には

72
01:04:19,033 --> 01:04:23,866
timeIntervalSinceReferenceDate というプロパティがあります

73
01:04:23,866 --> 01:04:29,566
これは世界標準時の2001年1月1日0時0分から

74
01:04:29,566 --> 01:04:35,566
何秒の差分があるかを示す値が入っています

75
01:04:35,566 --> 01:04:38,566
日本時間の今日の13時の場合

76
01:04:38,566 --> 01:04:43,833
7億8千3万3千6百秒という数字が入っています

77
01:04:45,900 --> 01:04:51,566
この数字からからさらに年、月、日、時、分の

78
01:04:51,833 --> 01:04:56,866
数字を、四則演算を駆使して割り出すというのが良いでしょうか

79
01:04:58,633 --> 01:05:01,833
ただ、西暦の年を計算できたとしても

80
01:05:01,833 --> 01:05:06,033
iOSではユーザーがこれを和暦に設定することもできます

81
01:05:06,433 --> 01:05:09,033
この場合はどのように対応すると良いでしょうか

82
01:05:11,233 --> 01:05:13,333
さらに英語の環境では

83
01:05:13,333 --> 01:05:18,433
そもそも月に当たるのが数字ではなく決まった英単語になりますし

84
01:05:18,633 --> 01:05:22,633
あとは24時間表記ではなくて12時間表記が好まれるかもしれません

85
01:05:24,833 --> 01:05:29,633
何かしらのデータがあって、それを文字列に変換しようとするときに

86
01:05:30,033 --> 01:05:34,233
ユーザーの言語や地域、文化などを考慮して

87
01:05:34,233 --> 01:05:37,300
その人にとって最も馴染みのある形式で

88
01:05:37,300 --> 01:05:39,633
伝えることができるのがベストかなと思います

89
01:05:40,433 --> 01:05:43,433
このことをデータのフォーマットと言っています

90
01:05:45,800 --> 01:05:47,866
iOSのアプリケーションの開発のような

91
01:05:47,866 --> 01:05:51,733
 世界中の多様なユーザーに情報を届けるための

92
01:05:51,733 --> 01:05:54,633
インターフェースを作っている私たちにとって

93
01:05:54,633 --> 01:05:57,599
データを適切な形にフォーマットするというのは

94
01:05:57,599 --> 01:06:01,266
避けては通れない非常に重要なものです

95
01:06:01,266 --> 01:06:02,733
一つのアプリの中でも

96
01:06:02,733 --> 01:06:05,000
いろいろな場所で繰り返し

97
01:06:05,000 --> 01:06:07,133
データをフォーマットすることがあるでしょう

98
01:06:08,866 --> 01:06:11,599
一方で、このデータのフォーマットについては

99
01:06:11,599 --> 01:06:14,333
無数の考慮すべき事柄があるため

100
01:06:14,333 --> 01:06:17,366
いついかなるときも期待通りに動作させる

101
01:06:17,366 --> 01:06:19,800
というのは非常に難しいものです

102
01:06:21,533 --> 01:06:24,166
そこで、よく使われるデータについては

103
01:06:24,166 --> 01:06:27,366
自分でフォーマット処理を書かなくても良いように

104
01:06:27,366 --> 01:06:29,800
SwiftやOSのフレームワークには

105
01:06:29,800 --> 01:06:34,666
あらかじめデータフォーマッティングのAPIが用意されています

106
01:06:35,733 --> 01:06:39,500
それでは、データのフォーマットを試してみましょう

107
01:06:40,333 --> 01:06:43,166
せっかくIOSアプリケーションの開発の現場でも

108
01:06:43,166 --> 01:06:45,733
徐々にコーディングインテリジェンスの活用例が

109
01:06:45,733 --> 01:06:47,766
見られてきた頃かなと思いますので

110
01:06:47,766 --> 01:06:52,466
ここは一つ、とある大規模言語モデル、LLMに聞いてみましょう

111
01:06:53,366 --> 01:06:57,000
Xcode でエラーになっているところを選びまして

112
01:06:57,000 --> 01:07:00,033
このGenerate Fix for Issueのボタンを押してみます

113
01:07:01,033 --> 01:07:05,033
すると、何らかLLMから返事がありました

114
01:07:05,300 --> 01:07:10,033
このようにコードを変更してくれたみたいですね

115
01:07:10,566 --> 01:07:15,033
ここでは、DateFormatterというのが使われています

116
01:07:15,033 --> 01:07:19,666
このDateFormatterの親クラスであるNSFormatterは

117
01:07:19,666 --> 01:07:22,033
Swiftが登場するよりも前

118
01:07:22,033 --> 01:07:26,766
Objective-Cの時代から存在するデータフォーマッティングのAPIです

119
01:07:28,933 --> 01:07:31,833
ファンデーションにはNSFormatterを継承する

120
01:07:31,833 --> 01:07:34,500
13種類のフォーマッターが存在しており

121
01:07:34,500 --> 01:07:41,033
日時の他にも数値や人の名前、重さや長さのような計測値など

122
01:07:41,033 --> 01:07:44,533
様々な種類のデータのフォーマットに対応しています

123
01:07:45,766 --> 01:07:49,133
2016年9月にリリースされたSwift3からは

124
01:07:49,133 --> 01:07:51,966
呼び出し時にNSのセット字が不要となり

125
01:07:51,966 --> 01:07:54,400
このような見た目になりました

126
01:07:54,400 --> 01:07:58,933
LLMが書いたのは、このDateFormatterを使ったコードでした

127
01:08:00,466 --> 01:08:04,566
このフォーマッターは非常に強力で柔軟なAPIですが

128
01:08:04,566 --> 01:08:08,233
特にSwiftの現代的な開発パラダイムですとか

129
01:08:08,233 --> 01:08:10,933
安全性を重視する観点から見ますと

130
01:08:10,933 --> 01:08:14,000
いくつか注意しなければならない点がありました

131
01:08:15,900 --> 01:08:20,033
それでは、DateFormatterを引き続き例にしてお話しします

132
01:08:20,033 --> 01:08:22,066
ここでは昨年末ですね

133
01:08:22,066 --> 01:08:26,033
とくしこしの直前の時刻をDateプロパティとして用意し

134
01:08:26,033 --> 01:08:30,033
このデータをフォーマットしてみることにしましょう

135
01:08:30,033 --> 01:08:34,133
クラスであるDateFormatterのインスタンスを作り

136
01:08:34,133 --> 01:08:38,133
日付時刻のフォーマットの形式を指定します

137
01:08:39,866 --> 01:08:44,033
それらが済んだら、インスタンスメソッドであるstringFromを使って

138
01:08:44,033 --> 01:08:47,500
ストリング型にフォーマットされた結果を得ます

139
01:08:47,500 --> 01:08:50,300
命令的なプログラミングに馴染みがあれば

140
01:08:50,300 --> 01:08:53,033
非常に読みやすいコードかなと思います

141
01:08:53,433 --> 01:08:55,333
もしフォーマットした結果において

142
01:08:55,333 --> 01:08:59,033
時刻の部分が不要だという場合は

143
01:08:59,033 --> 01:09:01,300
この timeStyle の部分に

144
01:09:01,300 --> 01:09:05,033
.none を指定するといった具合にカスタマイズできます

145
01:09:05,033 --> 01:09:09,100
では、年と月の部分だけ欲しくて

146
01:09:09,100 --> 01:09:14,033
この日はいらないという場合にはどのようにすればよいでしょうか

147
01:09:14,033 --> 01:09:18,500
DateFormatterには、より柔軟にフォーマットの形式を指定できる

148
01:09:18,500 --> 01:09:21,033
dateFormat というプロパティがあります

149
01:09:21,833 --> 01:09:29,333
今回は年と月だけ欲しいので、この大文字のYと大文字のMを使って

150
01:09:29,333 --> 01:09:35,033
あとはその後ろに年と月という漢字も出して欲しいので、加えておきます

151
01:09:35,033 --> 01:09:37,833
それではインスタンスメソッドのstringFromで

152
01:09:37,833 --> 01:09:39,533
これをフォーマットしますと

153
01:09:39,533 --> 01:09:45,666
年の数字が2024ではなく2025となってしまいました

154
01:09:45,666 --> 01:09:49,100
これはどこに誤りがあるのでしょうか

155
01:09:51,366 --> 01:09:55,233
この dateFormat プロパティに与える文字列というのは

156
01:09:55,233 --> 01:09:59,433
ユニコード (Unicode) の技術標準の仕様を用いるということになっています

157
01:10:01,333 --> 01:10:04,233
そのユニコードの仕様にある表に従って

158
01:10:04,233 --> 01:10:07,800
デイトフォーマットの文字列を組み立てていく必要があります

159
01:10:07,800 --> 01:10:10,433
すっごい大きな表で

160
01:10:10,433 --> 01:10:14,100
スクリーンには何書いているかもはや分からないんですけれども

161
01:10:14,100 --> 01:10:16,633
先ほどのデイトフォーマットのこの誤りは

162
01:10:16,633 --> 01:10:19,633
この年を示すYという文字

163
01:10:19,633 --> 01:10:24,633
これが大文字ではなく小文字にするべきだったというものでした

164
01:10:24,633 --> 01:10:28,333
これでめでたしといきたいところですけれども

165
01:10:28,333 --> 01:10:31,033
この後、例えば英語の環境で

166
01:10:31,033 --> 01:10:36,433
ディッセンバー2024のような表記もサポートするとなった場合には

167
01:10:36,433 --> 01:10:38,633
今度はどうしましょうか

168
01:10:38,633 --> 01:10:41,233
現状出すとデイトフォーマットに

169
01:10:41,233 --> 01:10:45,133
直接年とか月みたいな漢字も入ってしまっていますし

170
01:10:45,133 --> 01:10:49,100
あとは日本語は年の月に月がきますが

171
01:10:49,100 --> 01:10:53,633
この英語の場合は月が来て年が来るっていう違いもあります

172
01:10:54,966 --> 01:10:58,500
このようにたとえ日時のフォーマットだけをとっても

173
01:10:58,500 --> 01:11:00,866
考慮すべきパターンが無数にあり

174
01:11:00,866 --> 01:11:04,633
あとはフォーマットの形式の文字列指定にミスがあったとしても

175
01:11:04,633 --> 01:11:08,166
プログラムを実行するまで結果が分かりません

176
01:11:08,166 --> 01:11:13,000
ですからこのデイトフォーマットに直接文字列を指定してはいけません

177
01:11:15,133 --> 01:11:17,633
これはAppleのWWDCのセッションでも

178
01:11:17,633 --> 01:11:20,866
ほぼ必ず意図しない結果になってしまうとして

179
01:11:20,866 --> 01:11:25,933
dateFormat に文字列を直接指定するなとはっきり説明されています

180
01:11:27,199 --> 01:11:29,666
大事なことなのでもう一回言うんですけれども

181
01:11:29,666 --> 01:11:33,199
非常に古い資料ではこれしか方法がないということで

182
01:11:33,199 --> 01:11:36,600
dateFormat に直接指定する方法が紹介されていたり

183
01:11:36,600 --> 01:11:39,166
あとはコーディングインテリジェンスのLLMが

184
01:11:39,166 --> 01:11:41,399
この方法を提案してくるかもしれませんが

185
01:11:41,399 --> 01:11:43,233
これは使わないでください

186
01:11:43,233 --> 01:11:46,600
これは Agents.md とかに書いておくといいと思います

187
01:11:49,100 --> 01:11:51,199
ちょっと話が逸れてしまいましたが

188
01:11:51,199 --> 01:11:52,866
はじめのコードに戻ります

189
01:11:53,899 --> 01:11:56,066
改めてこのコードを読みますと

190
01:11:56,066 --> 01:12:00,000
SwiftUIのView Protocolによるボディの中で

191
01:12:00,000 --> 01:12:04,633
formattedDate というのを読んでまして

192
01:12:04,633 --> 01:12:09,633
この formattedDate はComputed Propertyで呼び出されるたびに

193
01:12:09,633 --> 01:12:12,633
デイトフォーマッターのインスタンスを生成し

194
01:12:12,633 --> 01:12:17,866
デイトスタイル、タイムスタイルの指定も行ってフォーマットしています

195
01:12:19,366 --> 01:12:21,733
SwiftUIのViewのボディは

196
01:12:21,733 --> 01:12:25,333
フレームワーク側から何度も呼ばれる可能性があります

197
01:12:26,000 --> 01:12:31,233
呼ばれるたびにこのフォーマッターのインスタンスを都度生成しています

198
01:12:32,233 --> 01:12:34,666
このフォーマッターのインスタンスの生成というのは

199
01:12:34,666 --> 01:12:37,266
非常にコストが高いということが知られています

200
01:12:38,633 --> 01:12:42,333
このコストが高いということについての言及というのは

201
01:12:42,333 --> 01:12:44,633
様々な方がされているんですけれども

202
01:12:44,633 --> 01:12:48,866
例えばこちらのAppleの今年のWWDCのセッションも見てみます

203
01:12:50,166 --> 01:12:55,633
ヒッチやハングといったパフォーマンスが悪いSwiftUIのアプリケーションを

204
01:12:55,633 --> 01:12:58,633
インスルメンツによって計測したところ

205
01:12:58,633 --> 01:13:02,633
先ほど示したコードのようにこのViewのボディから何度も

206
01:13:02,633 --> 01:13:05,533
フォーマッターのインスタンスを生成している箇所が見つかった

207
01:13:05,533 --> 01:13:07,633
というお話でした

208
01:13:08,633 --> 01:13:11,866
それへの対応策としてフォーマッターを使った

209
01:13:11,866 --> 01:13:14,633
このフォーマット5の文字列の生成

210
01:13:14,633 --> 01:13:18,766
このストリングフロムの呼び出しを別な場所で

211
01:13:18,766 --> 01:13:21,166
事前にまとめて実行するようにしたり

212
01:13:21,166 --> 01:13:25,066
あとはそもそもこのフォーマッターのインスタンスの生成回数が

213
01:13:25,066 --> 01:13:26,466
最小限に済むように

214
01:13:26,466 --> 01:13:30,399
キャッシュしておくという方法が紹介されていました

215
01:13:32,633 --> 01:13:35,966
ではここまでの内容を1回まとめたいと思います

216
01:13:37,300 --> 01:13:38,966
これまでのフォーマッターというのは

217
01:13:38,966 --> 01:13:42,633
非常に高機能でカスタマイズ性の高いものでした

218
01:13:42,633 --> 01:13:47,633
ただしいくつかのパターンでは仮にそのカスタマイズに誤りがあっても

219
01:13:47,633 --> 01:13:49,933
コンパイル時に気づくことはできず

220
01:13:49,933 --> 01:13:52,633
実際に動かして確認するといった必要がありました

221
01:13:54,366 --> 01:13:57,633
またフォーマッターのインスタンスを生成するコストや

222
01:13:57,633 --> 01:13:59,800
あとは説明は省略したんですけれども

223
01:13:59,800 --> 01:14:03,633
プロパティの変更のコストも高いということが知られています

224
01:14:05,100 --> 01:14:07,766
そのためそれらの回数を減らすために

225
01:14:07,766 --> 01:14:10,366
自分でキャッシュ機構を実装するなどして

226
01:14:10,366 --> 01:14:12,899
対応を行うというのがベストプラクティスでした

227
01:14:14,333 --> 01:14:17,600
あとは Swift は値型がよく使われますが

228
01:14:17,600 --> 01:14:19,966
このフォーマッターは参照型です

229
01:14:20,500 --> 01:14:24,633
そのキャッシュの共有を行う際もそれを意識する必要があります

230
01:14:25,633 --> 01:14:28,800
あとはスレッドセーフであるかどうかというのも

231
01:14:28,800 --> 01:14:32,633
今のスイフトコンカレンシーの時代には強く意識する必要があるでしょう

232
01:14:34,000 --> 01:14:37,166
そして SwiftUI などで流行っている宣言型ではなく

233
01:14:37,166 --> 01:14:40,300
命令型のAPIデザインとなっています

234
01:14:42,333 --> 01:14:45,733
これまでですね、フォーマッターについて

235
01:14:45,733 --> 01:14:49,633
どれが良いとか悪いとかを深掘るつもりはないんですけれども

236
01:14:49,633 --> 01:14:54,566
ただそれらの姿勢が考え方を活かしながら

237
01:14:54,566 --> 01:14:58,033
今のSwiftの時代にふさわしい新たなインターフェースとして

238
01:14:58,033 --> 01:15:00,533
登場したのが FormatStyle です

239
01:15:02,666 --> 01:15:05,300
このフォーマットスタイルというのは

240
01:15:05,300 --> 01:15:07,800
正確にはプロトコルの名前になっています

241
01:15:07,800 --> 01:15:12,899
iOS 15以降で利用可能で、特定のデータ型を別な型

242
01:15:12,899 --> 01:15:15,300
例えば文字列、ストリング型ですね

243
01:15:15,300 --> 01:15:19,833
に変換するためのインターフェースを定義するものになっています

244
01:15:20,800 --> 01:15:22,666
さまざまな用途に応じた

245
01:15:22,666 --> 01:15:26,033
フォーマットのスタイルがデフォルトで用意されていまして

246
01:15:26,033 --> 01:15:31,266
iOS 26までには46のフォーマットスタイルが存在しています

247
01:15:33,233 --> 01:15:37,166
こちらが従来のフォーマッターで書かれたコードですが

248
01:15:37,166 --> 01:15:42,399
これをフォーマットスタイルを用いるように変更しますと、このようになります

249
01:15:42,966 --> 01:15:46,266
コードが非常に少なくなりましたね

250
01:15:46,966 --> 01:15:49,699
両者のコードを見比べてみましょう

251
01:15:49,699 --> 01:15:55,266
これまで存在していたデイトフォーマッターの記述がそもそも消えました

252
01:15:55,266 --> 01:15:59,833
またこれまではフォーマッター側に存在するメソッドに

253
01:15:59,833 --> 01:16:01,466
引数

254
01:16:01,466 --> 01:16:05,966
フォーマッター側に存在するメソッドの引数にデータを渡していましたが

255
01:16:05,966 --> 01:16:07,866
フォーマットスタイルを使う方法では

256
01:16:07,866 --> 01:16:13,199
データに対してformattedというメソッドをつけるというように変わりました

257
01:16:15,100 --> 01:16:19,366
データに応じたフォーマッターのインスタンスを自分で作ることなく

258
01:16:19,366 --> 01:16:23,566
ただシンプルにデータに対してformattedをつけることだけで

259
01:16:23,566 --> 01:16:26,000
簡単にフォーマットできます

260
01:16:27,300 --> 01:16:32,466
このformattedメソッドの中で詳細なスタイルの指定をすることもできます

261
01:16:32,466 --> 01:16:36,833
指定しない場合はデフォルトの実装が使用されます

262
01:16:38,166 --> 01:16:40,566
柔軟なスタイル指定というのも

263
01:16:40,566 --> 01:16:43,733
先ほどのローマ字の小文字のYがどうで

264
01:16:43,733 --> 01:16:45,966
大文字のMがどうで、みたいな

265
01:16:45,966 --> 01:16:49,766
複雑な文字列のスタイルのルールっていうのを覚えることなく

266
01:16:49,766 --> 01:16:54,033
年が欲しいから year をつけて、月が欲しいから month をつけて

267
01:16:54,033 --> 01:16:58,699
と、このコード補完を効かせながら安全に書くことができます

268
01:16:58,699 --> 01:17:02,866
あとは後から読んだ時の可読性も非常に高いかなと思います

269
01:17:04,966 --> 01:17:08,733
FormatStyle はこのSwiftのために設計されていて

270
01:17:08,733 --> 01:17:12,800
この外側のインターフェースの部分は100%Swiftで書かれています

271
01:17:14,066 --> 01:17:18,266
またフォーマッターがクラス、参照型であったのに対し

272
01:17:18,266 --> 01:17:23,600
フォーマットスタイルは構造体、値型で作るのが基本ということになり

273
01:17:23,600 --> 01:17:26,100
スタック上での割り当てとかコピーオンライトとか

274
01:17:26,100 --> 01:17:30,300
コンパイラーによる最適化の恩恵を受けやすいだろうという利点があります

275
01:17:31,466 --> 01:17:35,233
スタイルの指定はカターン安全に行うことができて

276
01:17:35,233 --> 01:17:39,333
フォーマットスタイルの内部で使用されているフォーマッターのインスタンスは

277
01:17:39,333 --> 01:17:42,366
フレームワーク側で自動的にキャッシュされます

278
01:17:42,366 --> 01:17:46,033
先ほどの手動でキャッシュするみたいなことを

279
01:17:46,033 --> 01:17:48,466
考えなきゃいけないというところから解放されて

280
01:17:48,466 --> 01:17:53,166
パフォーマンス上のメリットも一定程度享受できそうです

281
01:17:53,166 --> 01:17:56,833
あとは、流行りの宣言型のインターフェースとともに

282
01:17:56,833 --> 01:17:59,366
現代の人々から使いやすくなったというのが

283
01:17:59,366 --> 01:18:02,433
このフォーマットスタイルです

284
01:18:03,500 --> 01:18:06,000
従来のこのフォーマッターと

285
01:18:06,000 --> 01:18:10,266
このフォーマットスタイルのインターフェースなどの違いが分かったところで

286
01:18:10,266 --> 01:18:15,666
プロトコルで定義されているフォーマットスタイルのルールについて紹介します

287
01:18:17,033 --> 01:18:20,766
フォーマットスタイルプロトコルに適合する方は

288
01:18:20,766 --> 01:18:26,833
プライマリーアソシエイティットタイプとして、フォーマットの入力側の方と

289
01:18:26,833 --> 01:18:32,633
出力側の方がそれぞれ何であるかというのを指定する必要があります

290
01:18:33,466 --> 01:18:37,466
そして実際に入力された値を使ってフォーマットを行い

291
01:18:37,466 --> 01:18:41,000
結果を出力するメソッドの実装が必要です

292
01:18:42,466 --> 01:18:49,500
本日の最初に示した、このデイト型からストリング型へのフォーマットを行う場合

293
01:18:49,500 --> 01:18:58,233
その FormatInput というのが Date 型になって、FormatOutput というのが String 型ということになります

294
01:19:00,166 --> 01:19:04,433
ここからは、iOS26までに含まれている

295
01:19:04,433 --> 01:19:10,233
すぐに使える FormatStyle の全種類について列挙してみようと思います

296
01:19:10,233 --> 01:19:17,199
ただ、これまでは日時のフォーマットについてお話ししてきましたが

297
01:19:17,199 --> 01:19:22,199
今のiOSには他のデータに対応したフォーマットスタイルというのも存在しています

298
01:19:22,199 --> 01:19:26,666
ただ、これをすべて一度に覚えることは難しいですし

299
01:19:26,666 --> 01:19:30,300
ここからどんどん列挙するとおそらく眠くなってしまうので

300
01:19:30,300 --> 01:19:36,633
もしよろしければ、この後公開される資料ですとかアーカイブなどで振り返りに来ていただければと思います

301
01:19:38,399 --> 01:19:42,600
ではまず、日時や時間について見ていきましょう

302
01:19:42,600 --> 01:19:48,600
Date.FormatStyle というのは日付と時刻のフォーマットを行う

303
01:19:48,600 --> 01:19:50,533
最も基本的なスタイルです

304
01:19:50,533 --> 01:19:56,133
デート型のプロパティに formatted をつけるとこのフォーマットスタイルが使われます

305
01:19:56,133 --> 01:20:01,366
date 引数と time 引数でスタイルを細かく指定でき

306
01:20:01,366 --> 01:20:04,833
様々な表現をすることができます

307
01:20:04,833 --> 01:20:06,866
また、メソッドチェーンを使って

308
01:20:06,866 --> 01:20:14,033
年、月、日、時、分、秒、あとはタイムゾーンなども詳細にしていきます

309
01:20:14,033 --> 01:20:18,266
フィールドの順序というのが最終的な出力に影響しません

310
01:20:18,266 --> 01:20:22,866
OS がロケルに応じて適切に配置してくれます

311
01:20:22,866 --> 01:20:31,066
例えばこの上の例はアメリカ英語のように月、日、年というふうな順番で指定しているんですけれども

312
01:20:31,066 --> 01:20:36,899
これを日本の日本語環境で動かすと、ちゃんと年、月、日と表示されます

313
01:20:36,899 --> 01:20:40,800
その他にも月とか曜日の省略形表示であるとか

314
01:20:40,800 --> 01:20:46,433
あとは数字が一桁の場合にゼロでパリングを埋めるみたいな処理もしてできます

315
01:20:48,233 --> 01:20:54,033
続いて、Date.ISO8601FormatStyle というのがあります

316
01:20:54,033 --> 01:20:58,633
formatted のところで .iso8601 と書くことで

317
01:20:58,633 --> 01:21:01,000
これはサーバーとのデータ通信など

318
01:21:01,000 --> 01:21:03,966
ISO 8601 という仕様がありますが

319
01:21:03,966 --> 01:21:07,699
その日時が必要な場合に非常に便利に使えます

320
01:21:10,199 --> 01:21:12,766
これにタイムゾーンの情報をつけたり

321
01:21:12,766 --> 01:21:14,833
先ほどのデイトフォーマットのように

322
01:21:14,833 --> 01:21:21,000
 欲しい要素をメソッドチェーンで書いて出力する要素を細かく指定できます

323
01:21:22,100 --> 01:21:26,433
ISO 26 では、この DateComponents の方にも

324
01:21:26,433 --> 01:21:30,833
ISO 8601 形式のスタイルが用意されました

325
01:21:32,800 --> 01:21:36,366
こちらも新しく導入されたものになりますが

326
01:21:36,366 --> 01:21:42,066
 HTTP の RFC 9110 に準拠したフォーマットスタイルというのもあります

327
01:21:42,566 --> 01:21:44,866
こちらはウェブの通信において

328
01:21:44,866 --> 01:21:50,899
日時のヘッダーとかを取り扱う際に 格段に容易になるかなと思います

329
01:21:52,166 --> 01:21:56,233
これも同様に DateComponents 版が存在します

330
01:21:57,800 --> 01:22:01,133
出力形式をもっとカスタマイズしたい場合は

331
01:22:01,133 --> 01:22:04,966
Date.VerbatimFormatStyle を使います

332
01:22:05,766 --> 01:22:10,566
先に述べた従来の DateFormatter の dateFormat プロパティのように

333
01:22:10,566 --> 01:22:14,966
カスタムのフォーマットを文字列で直接指定できるスタイルです

334
01:22:14,966 --> 01:22:20,866
ただ、このデイトフォーマットストリングによって提供される ストリングインターポレーションですね

335
01:22:20,866 --> 01:22:26,800
文字列補完項群によって、 タイプセーフにフォーマットをしてできるようになっています

336
01:22:26,800 --> 01:22:29,100
例えば、ここのように

337
01:22:29,100 --> 01:22:35,100
年号と年、月、日をピリオードでつなぐことが求められる

338
01:22:35,100 --> 01:22:37,699
時数のフォーマットというのがあるんですけれども

339
01:22:37,699 --> 01:22:42,899
これをフォーマティでロケルとかタイムゾーンと一緒に指定すれば

340
01:22:42,899 --> 01:22:47,033
iOSデバイスのカレンダーが西暦でも和暦でも

341
01:22:47,033 --> 01:22:56,633
確実にこの例はR07.09.20のように時数の規格にあった出力が得られます

342
01:22:58,899 --> 01:23:02,766
続きまして、この Date.IntervalFormatStyle は

343
01:23:02,766 --> 01:23:07,066
二つのデイトの間の期間をフォーマットするためのスタイルです

344
01:23:07,066 --> 01:23:11,366
デイトの範囲型を入力として受け取りまして

345
01:23:11,366 --> 01:23:15,566
ユーザーのロケルに合わせた自然な形で期間をフォーマットします

346
01:23:15,899 --> 01:23:21,633
例えば、時刻は省略して日付の期間だけを出力するときに

347
01:23:21,633 --> 01:23:29,300
日本の日本語環境であれば19日から21日とナミセン、ナミダッシュで出力されて

348
01:23:29,300 --> 01:23:37,533
アメリカ英語の環境であれば September 19 – 21 という感じで出力されます

349
01:23:38,566 --> 01:23:46,366
そして Date.ComponentsFormatStyle というのもありまして、 これは日付のコンポーネント間の差をフォーマットします

350
01:23:46,566 --> 01:23:48,766
二つの日付の間を

351
01:23:48,766 --> 01:23:52,266
二日であるとか二日と二時間のように

352
01:23:52,266 --> 01:23:54,933
人間が読みやすい形式で表示します

353
01:23:55,433 --> 01:24:00,166
こちらもスタイル、引数で出力スタイルをカスタマイズすることもできます

354
01:24:02,566 --> 01:24:08,033
似たようなもので Date.RelativeFormatStyle というのもあります

355
01:24:08,033 --> 01:24:10,966
こちらは現在の時刻を基準とした

356
01:24:10,966 --> 01:24:16,000
相対的な日時をフォーマットするためのスタイルです

357
01:24:16,000 --> 01:24:18,233
named を使用すると

358
01:24:18,233 --> 01:24:23,566
 先月、今月、来月といった自然言語の表現が得られます

359
01:24:23,566 --> 01:24:29,899
numeric スタイルにすると、 1ヶ月後のように数値での相対表現ができます

360
01:24:31,000 --> 01:24:34,100
非単位の相対表現もできるようになってまして

361
01:24:34,100 --> 01:24:38,300
一昨日、昨日、今日、明日、明後日というような表現が

362
01:24:38,300 --> 01:24:42,166
ロケールに応じて自動的に適用されます

363
01:24:42,166 --> 01:24:46,966
このフォーマットスタイルは現在時刻を基準として

364
01:24:46,966 --> 01:24:49,800
相対的なものを出力するんですけれども

365
01:24:50,399 --> 01:24:52,666
その基準を現在の時刻ではなくて

366
01:24:52,666 --> 01:24:54,566
任意の時刻にしたい場合は

367
01:24:54,566 --> 01:24:58,966
この Date.AnchoredRelativeFormatStyleの 方を使います

368
01:24:58,966 --> 01:25:02,300
特定の日時をアンカーとして指定して

369
01:25:02,300 --> 01:25:09,399
入力された日時を、 その基準として相対的なフォーマットを行います

370
01:25:13,399 --> 01:25:16,600
ここまで日時のフォーマットについてしゃべりまくったんですけれども

371
01:25:16,600 --> 01:25:22,433
数値のフォーマットというのもよく同じぐらい使われるかなと思います

372
01:25:22,433 --> 01:25:26,899
整数ですとか浮動小数点数ですとかデシマル型の

373
01:25:26,899 --> 01:25:29,666
それぞれにフォーマットスタイルが用意されていて

374
01:25:29,666 --> 01:25:35,600
デフォルトでは3桁区切りなどのロケールに応じた表示が行われます

375
01:25:35,600 --> 01:25:41,633
日本の日本語環境だと3桁おきにカンマが出るというような感じですね

376
01:25:41,633 --> 01:25:44,333
さらに rounded 修飾詞を使うと

377
01:25:44,333 --> 01:25:47,533
四捨五入ですとか切り捨てとか切り上げといった

378
01:25:47,533 --> 01:25:51,866
数字の丸めのルールがありますけれども、 それも指定できます

379
01:25:51,866 --> 01:25:56,000
他にも有効桁数を指定できたり、指数表記にしたり

380
01:25:56,000 --> 01:26:00,133
 たくさんの修飾詞があってそれらを使うとカスタマイズできます

381
01:26:02,033 --> 01:26:05,533
それぞれの数値の型には百分率

382
01:26:05,533 --> 01:26:09,500
パーセントとしてフォーマットするスタイルも用意されています

383
01:26:09,500 --> 01:26:15,699
数値が自動的に100倍されてロケールに応じたパーセントの記号が付与されます

384
01:26:15,699 --> 01:26:19,066
パーセント記号をどこにつけるかですとか

385
01:26:19,066 --> 01:26:23,666
そもそもパーセント記号が何かというのもロケールに応じて違うので

386
01:26:23,666 --> 01:26:26,000
それらを自動調整してくれます

387
01:26:28,000 --> 01:26:32,266
同様に通貨としてフォーマットするスタイルも用意されています

388
01:26:32,266 --> 01:26:34,533
 通貨コードを指定することでロケールに応じた

389
01:26:34,533 --> 01:26:40,199
通貨記号や、 少数点以下の桁数というのもここでサポートされます

390
01:26:40,800 --> 01:26:44,366
同じ国や地域の中でも言語が違えば

391
01:26:44,366 --> 01:26:47,633
通貨の記号を表示する場所が変わったりもするので

392
01:26:47,633 --> 01:26:49,199
それもサポートしています

393
01:26:52,133 --> 01:26:56,300
続いて、iOS16で導入された

394
01:26:56,300 --> 01:26:59,366
デュレーション型を使うフォーマットスタイルも紹介します

395
01:27:01,000 --> 01:27:03,933
Duration.TimeFormatStyle というのがありまして

396
01:27:03,933 --> 01:27:10,533
これはデュレーションの値を時、分、秒の形式でフォーマットします

397
01:27:11,600 --> 01:27:13,466
パターンという引数があって

398
01:27:13,466 --> 01:27:17,699
ここに hourMinute とか hourMinuteSecond などを指定することで

399
01:27:17,699 --> 01:27:22,566
時間と分と秒の表示形式を細かく制御できます

400
01:27:23,300 --> 01:27:29,666
padHourToLength などを使うと桁数を揃えるということもできます

401
01:27:31,366 --> 01:27:34,633
これには UnitsFormatStyle というのもありまして

402
01:27:34,633 --> 01:27:40,033
これはデュレーションの値を自動的に最適な単位を使う形でフォーマットしてくれます

403
01:27:40,033 --> 01:27:43,633
この使うべき単位をこちらから指定することもできますし

404
01:27:43,633 --> 01:27:46,666
あとはそのゼロで桁を埋めるということもできます

405
01:27:48,966 --> 01:27:53,000
続いて計測値に関するフォーマットスタイルです

406
01:27:54,133 --> 01:27:57,466
Swiftにおける計測値について皆さんご存知でしょうか

407
01:27:57,466 --> 01:28:01,033
Swiftのファンデーションには様々な値を示すことができる

408
01:28:01,033 --> 01:28:03,500
Measurement という単位があります

409
01:28:05,199 --> 01:28:08,866
例えば面積を示すデータがあるときに

410
01:28:08,866 --> 01:28:12,733
シンプルにイント型とかダブル型を使うことが

411
01:28:12,733 --> 01:28:15,266
真っ先に思い浮かぶかもしれませんが

412
01:28:15,600 --> 01:28:19,033
ユニットエリアのメジャーメント型にしておくことで

413
01:28:19,033 --> 01:28:22,833
型システムによってこのデータが面積であることを

414
01:28:22,833 --> 01:28:24,500
明確に示すことができます

415
01:28:25,399 --> 01:28:29,766
またそのデータの単位も同時に持つことができます

416
01:28:29,766 --> 01:28:36,433
ここでは東北の3つの県の面積を平方キロメートルで表しています

417
01:28:36,433 --> 01:28:41,399
なので後ろに squareKilometers って書いてますね

418
01:28:41,699 --> 01:28:44,266
これらに formatted をつけることで

419
01:28:44,266 --> 01:28:47,733
データの数値とその単位を一緒に出力してくれます

420
01:28:47,733 --> 01:28:52,800
 単位の出力のスタイルをこのキロメートル二乗というところから

421
01:28:52,800 --> 01:28:56,466
漢字とカタカナのように変換することもできますし

422
01:28:56,466 --> 01:29:00,300
これをアメリカ英語向けにフォーマットすると

423
01:29:00,300 --> 01:29:04,000
平方キロメートルが平方マイルへと変換されて出力されます

424
01:29:06,666 --> 01:29:14,166
またメモリやファイルなどのサイズを表すに適したフォーマットスタイルも用意されています

425
01:29:14,833 --> 01:29:18,533
キロバイトとかメガバイトとかギガバイトなど

426
01:29:18,533 --> 01:29:21,966
最適な単位に自動的に変換して出力します

427
01:29:21,966 --> 01:29:27,000
こちらもスタイル引数やユニット引数で表示形式や単位を制御できます

428
01:29:29,633 --> 01:29:34,600
続いて人の名前をフォーマットするための FormatStyle というのも存在します

429
01:29:34,600 --> 01:29:41,266
 人の名前に関する型である PersonNameComponents という型がありますが

430
01:29:41,266 --> 01:29:45,133
ここから人の名前というのをフォーマットできます

431
01:29:45,133 --> 01:29:51,766
スタイル引数でショート、ミディアム、ロングなどといった表示形式を選択できて

432
01:29:51,766 --> 01:29:55,833
ロケールに応じた姓名の順序を 自動で適用してくれます

433
01:29:58,233 --> 01:30:04,333
このようにローマ字表記で仮に 姓名、ニックネームというのを指定しますと

434
01:30:04,333 --> 01:30:08,066
短縮形の方ではイニシャルが生成されたりですとか

435
01:30:08,066 --> 01:30:12,133
日本のロケールでは姓名の順番になりますが

436
01:30:12,133 --> 01:30:15,000
英語のロケールでは名、姓の順番に

437
01:30:15,000 --> 01:30:17,899
イニシャルが出るというような違いがあります

438
01:30:21,533 --> 01:30:23,933
もうすぐ全部の紹介が終わりますよ

439
01:30:23,933 --> 01:30:28,633
URLに関するフォーマットスタイルというのも デフォルトで存在しています

440
01:30:28,633 --> 01:30:31,966
URLをホスト、パス、クエリなど

441
01:30:31,966 --> 01:30:35,833
特定のコンポーネントに絞ってフォーマットすることができます

442
01:30:35,833 --> 01:30:40,800
例えばこのようにクエリの部分だけ取り出したりですとか

443
01:30:40,800 --> 01:30:42,633
あとはブラウザーアプリのように

444
01:30:42,633 --> 01:30:47,133
URLのドメイン部分だけを ユーザーに表示したりしたいという場合に

445
01:30:47,133 --> 01:30:48,500
役に立ちそうです

446
01:30:51,833 --> 01:30:56,199
その他少し特殊なフォーマットスタイルというのを 最後に紹介します

447
01:30:57,766 --> 01:31:04,966
配列などのシーケンスの要素を連結して 一つの文字列としてフォーマットするスタイルが用意されています

448
01:31:04,966 --> 01:31:10,133
このスタイルはロケールに応じて カンマとかあとはトーテンといった

449
01:31:10,133 --> 01:31:17,366
適切な区切り文字ですとか あとは接続詞を自動で適用してくれます

450
01:31:18,133 --> 01:31:25,133
例えば日本語ではリンゴ、テン、バナナ、 テン、ミカンという風になったりですとか

451
01:31:25,133 --> 01:31:30,133
英語ではアップル、カンマ、バナナ、 カンマ、アンド、オレンジのように

452
01:31:30,133 --> 01:31:33,366
人間が読むときにとても自然なスタイルになってくれます

453
01:31:35,133 --> 01:31:39,133
このリストフォーマットスタイルの メンバースタイルという引数に

454
01:31:39,133 --> 01:31:42,133
別のフォーマットスタイルを 渡すということもできまして

455
01:31:42,133 --> 01:31:46,300
リストの各要素に個別にフォーマットをしつつ

456
01:31:46,300 --> 01:31:49,333
最終的に連結された文字列というのを

457
01:31:49,333 --> 01:31:51,733
このリストフォーマットスタイルで やることもできます

458
01:31:53,133 --> 01:31:57,133
数字は数字でフォーマットしておいて 最後それを一つの文字列に

459
01:31:57,133 --> 01:32:00,866
もう一回フォーマットするというようなのが こちらのサンプルですね

460
01:32:02,133 --> 01:32:05,133
これは私たちが直接使うことは ほぼないんですけれども

461
01:32:05,133 --> 01:32:09,133
ストリングをストリングに フォーマットするという方も存在します

462
01:32:09,133 --> 01:32:12,699
入力と出力が変わらないという スタイルなんですけれども

463
01:32:12,699 --> 01:32:15,033
例えばジェネリックなコンテキストにおいて

464
01:32:15,033 --> 01:32:17,533
フォーマットスタイルがどうしても必要みたいなときに

465
01:32:17,533 --> 01:32:19,300
デフォルトのプレースホルダーとして

466
01:32:19,300 --> 01:32:21,833
使われるのがこちらのストリングスタイルでした

467
01:32:24,066 --> 01:32:25,266
こうですね

468
01:32:27,600 --> 01:32:33,500
これはストアキットのフレームワークにも フォーマットスタイルが存在していました

469
01:32:33,500 --> 01:32:38,033
こちらはサブスクの期間を

470
01:32:38,033 --> 01:32:43,133
日とか月とか年の単位で フォーマットするためのスタイルが用意されています

471
01:32:43,133 --> 01:32:47,466
これで例えばApp Store Connectとかで指定したサブスクの期間を

472
01:32:47,466 --> 01:32:50,733
アプリ内で適切にローカライズする ということが可能です

473
01:32:54,133 --> 01:32:55,133
大変お疲れ様でした

474
01:32:55,133 --> 01:33:01,133
以上がiOS26までに搭載されている 基本のフォーマットスタイルのすべてでした

475
01:33:01,533 --> 01:33:03,866
いつか皆さんの普段の開発で あのフォーマットスタイルがあったかもしれないなと

476
01:33:03,866 --> 01:33:06,000
あのフォーマットスタイルがあったかもしれないなと

477
01:33:06,000 --> 01:33:08,533
思い出すきっかけになれば嬉しいです

478
01:33:10,899 --> 01:33:15,866
それではこのフォーマットスタイルの外側 インターフェースの話に少し戻りたいと思います

479
01:33:17,133 --> 01:33:20,666
先ほど挙げたフォーマットスタイルの中には

480
01:33:20,666 --> 01:33:24,466
出力される文字列に簡単に装飾ができるタイプの

481
01:33:24,466 --> 01:33:26,100
フォーマットスタイルというのがあります

482
01:33:27,899 --> 01:33:29,899
このフォーマットの出力の型が

483
01:33:29,899 --> 01:33:32,066
修飾できる文字列である

484
01:33:32,066 --> 01:33:34,500
アトリビューテッドストリングになっています

485
01:33:36,633 --> 01:33:41,133
それではそれがどのように動作するかというのを イメージ見てみましょう

486
01:33:41,366 --> 01:33:44,199
フォーマットスタイルで書き直した最初のスクリーンショットが

487
01:33:44,199 --> 01:33:45,966
こちらになりますが

488
01:33:47,133 --> 01:33:51,033
ここの日時をフォーマットしている部分を取り出しました

489
01:33:52,600 --> 01:33:56,300
そしてアトリビュートに対応している フォーマットスタイルの場合は

490
01:33:56,300 --> 01:33:58,566
このようにフォーマットスタイルの末尾に

491
01:33:58,566 --> 01:34:02,133
アトリビューテッド、もしくはアトリビューテッドスタイルの

492
01:34:02,133 --> 01:34:05,133
どちらかをつけることができまして

493
01:34:05,133 --> 01:34:11,133
例えばこのように年の部分に対してのみ フォーグラウンドカラーをレッドにするという指定をすれば

494
01:34:11,133 --> 01:34:12,866
それがビューに反映されます

495
01:34:15,133 --> 01:34:17,133
その他よく見る例ですと

496
01:34:17,133 --> 01:34:24,466
例えば通貨をフォーマットしたときに通貨の記号の部分だけ 数字よりもフォントサイズを小さくしたいみたいな

497
01:34:24,466 --> 01:34:26,899
要望が出ることがありますが

498
01:34:26,899 --> 01:34:31,133
これもアトリビューテッドなフォーマットスタイルで 実現することができます

499
01:34:31,133 --> 01:34:36,000
これは円マークの部分が数字よりも ちょっと小さいという感じですね

500
01:34:40,933 --> 01:34:43,133
残り時間の関係で説明は省略しますけれども

501
01:34:43,133 --> 01:34:46,733
iOS 18からのSuite UIのストップウォッチですとか

502
01:34:46,733 --> 01:34:52,166
タイマーのような表示に特化したアトリビューテッドな フォーマットスタイルというのも存在します

503
01:34:53,899 --> 01:34:56,366
では、そのSwiftUIの話が出てきましたので

504
01:34:56,366 --> 01:34:59,466
このSwiftUIからフォーマットスタイルを使うという方法も

505
01:34:59,466 --> 01:35:01,533
少し見ていきましょう

506
01:35:03,066 --> 01:35:05,100
このトークの序盤にですね

507
01:35:05,100 --> 01:35:07,166
SwiftUIのテキストのイニシャライザーは

508
01:35:07,166 --> 01:35:11,199
デート型を渡すことはできないと説明しました

509
01:35:12,066 --> 01:35:15,833
なので、Formattedを使うことでString型に変えて

510
01:35:15,833 --> 01:35:18,533
解決しましょうというお話をしたんですけれども

511
01:35:18,533 --> 01:35:21,333
実はですね、テキストにはデート型を受け取れる

512
01:35:21,333 --> 01:35:23,899
イニシャライザーが別に存在しています

513
01:35:24,833 --> 01:35:26,500
それがこの形です

514
01:35:26,833 --> 01:35:30,933
テキストの第一引数には何かしらのデータを置いて

515
01:35:30,933 --> 01:35:35,533
第二引数であるフォーマットの部分にフォーマットスタイルを渡すことで

516
01:35:35,533 --> 01:35:38,433
SwiftUIのテキストとして取り扱うことができます

517
01:35:39,500 --> 01:35:42,166
これが最もベストな方法かなと思います

518
01:35:42,166 --> 01:35:45,633
特にですね、動作の制約が厳しいウィジェットですとか

519
01:35:45,633 --> 01:35:47,100
ライブアクティビティですとか

520
01:35:47,100 --> 01:35:50,133
コンプリケーションみたいなのを構築する場合には

521
01:35:50,133 --> 01:35:52,833
特にこれを使うべきでしょう

522
01:35:53,666 --> 01:35:56,399
こちらのサンプルコードでは正直微妙なんですけれども

523
01:35:56,399 --> 01:35:57,699
データの型によっては

524
01:35:57,699 --> 01:36:02,566
パフォーマンスの良いディスクリエイトフォーマットスタイルというのは別に存在していて

525
01:36:02,566 --> 01:36:05,066
そちらの恩恵を受けられる可能性もあります

526
01:36:05,333 --> 01:36:08,966
もしよろしければス Ask the Speaker などでおしゃべりできたら嬉しいです

527
01:36:10,233 --> 01:36:14,533
またさらにですね、ここでVStackを使っていますけれども

528
01:36:14,533 --> 01:36:19,266
これを一つのテキストとして取り扱いたい場合は

529
01:36:19,266 --> 01:36:21,066
String Interpolation の方で

530
01:36:21,066 --> 01:36:26,266
このフォーマットという引数を使う書き方も存在します

531
01:36:28,833 --> 01:36:33,833
これまではこちらからユーザーに何か見せるためのフォーマットを使う例で

532
01:36:33,833 --> 01:36:36,833
SwiftUIのテキストを使ってきましたが

533
01:36:36,833 --> 01:36:40,233
このフォーマットはテキストフィールドにも使うことができます

534
01:36:41,833 --> 01:36:46,833
何かしらのデータをストリングにフォーマットするというのはずっと見てきたんですけれども

535
01:36:46,833 --> 01:36:49,833
これを逆にユーザーからストリングを受け取って

536
01:36:49,833 --> 01:36:54,833
それを何かしらの手段で解析してこちらのデータ型に変換する

537
01:36:54,833 --> 01:36:56,833
つまりこれはParseの処理ですね

538
01:36:56,833 --> 01:36:59,366
これが必要な場合があります

539
01:37:04,300 --> 01:37:09,833
ここでParseableFormatStyleというのが存在します

540
01:37:10,633 --> 01:37:14,833
このParseableFormatStyleにおけるParseの処理というのは

541
01:37:14,833 --> 01:37:18,833
ParseStrategyのこちらで定義されています

542
01:37:18,833 --> 01:37:24,100
こちらにParseInputとParseOutputという型がありますが

543
01:37:24,100 --> 01:37:26,433
これに注目してください

544
01:37:26,433 --> 01:37:29,600
このParseInputとParseOutputというのは

545
01:37:29,600 --> 01:37:33,199
元のフォーマットスタイルのInputとOutputと

546
01:37:33,199 --> 01:37:36,533
それぞれ対の関係になるように定められていまして

547
01:37:36,533 --> 01:37:40,699
これによってデータのフォーマットとパースというのが

548
01:37:40,699 --> 01:37:44,500
それぞれ逆向きの関係になっていることが表現されています

549
01:37:44,500 --> 01:37:47,266
僕はこの表現方法めちゃめちゃ好きです

550
01:37:48,333 --> 01:37:51,966
この日時や数値ですとかURLみたいな

551
01:37:51,966 --> 01:37:55,100
規則が明確なフォーマットスタイルを中心に

552
01:37:55,100 --> 01:37:58,833
それらはParseableFormatStyleにも適合しています

553
01:37:58,833 --> 01:38:03,833
この人の名前もParse可能というのが驚きですね

554
01:38:05,033 --> 01:38:07,399
それではこのParseableFormatStyleについては

555
01:38:07,399 --> 01:38:11,833
これを自作する方法を見ながら理解を進めてみることにしましょう

556
01:38:12,399 --> 01:38:15,699
OSに含まれていないスタイルでフォーマットしたい場合

557
01:38:15,699 --> 01:38:19,033
フォーマットスタイルを自作するという選択肢があります

558
01:38:20,666 --> 01:38:23,666
こちらは私がOSSで開発している

559
01:38:23,666 --> 01:38:26,500
Xcodeのコーディングインテリジェンス機能を

560
01:38:26,500 --> 01:38:28,899
ChatGPTとかCloud以外のモデルでも

561
01:38:28,899 --> 01:38:31,466
使えるようにするというツールがありまして

562
01:38:31,466 --> 01:38:36,333
その中にはユーザーが任意のポート番号を設定できるように

563
01:38:36,333 --> 01:38:40,833
SwiftUIの TextFiled を使った画面が存在します

564
01:38:41,866 --> 01:38:47,833
このポート番号というのはNWEndpointPortという型なんですけれども

565
01:38:47,833 --> 01:38:51,833
これとストリングのフォーマットを行うフォーマットスタイルというのは

566
01:38:51,833 --> 01:38:54,133
今、標準には存在しません

567
01:38:54,133 --> 01:38:56,500
そのためこれを自分で作ります

568
01:38:58,833 --> 01:39:03,833
ではまずフォーマットスタイルに適合するところから始めましょう

569
01:39:03,833 --> 01:39:06,833
NWEndpointPort型というのを受け取って

570
01:39:06,833 --> 01:39:10,966
それをストリングで返すフォーマットメソッドを実装します

571
01:39:12,600 --> 01:39:18,966
この型は rawValue を取ると UInt16 が得られるので

572
01:39:18,966 --> 01:39:23,100
これをさらに数値としてフォーマットして文字列にします

573
01:39:24,833 --> 01:39:27,833
そして標準のフォーマットスタイルと同様に

574
01:39:27,833 --> 01:39:32,166
ショートカットを提供して無事に完成ということになります

575
01:39:32,833 --> 01:39:37,133
NWEndpointPort の後ろに formatted を付ければ

576
01:39:37,133 --> 01:39:39,199
フォーマットできるというものですね

577
01:39:41,300 --> 01:39:44,833
そしてその先のパーサブルフォーマットスタイルにも

578
01:39:44,833 --> 01:39:46,500
適合させてみることにします

579
01:39:47,833 --> 01:39:49,533
これに適合するためには

580
01:39:49,533 --> 01:39:53,600
対応する ParseStrategy を定義する必要があるですけれども

581
01:39:53,600 --> 01:39:57,333
ParseStrategy のこの parse メソッドにおいて

582
01:39:57,333 --> 01:40:04,000
入力文字列を目的のNWEndpointPort型に変換するロジックを記述します

583
01:40:05,866 --> 01:40:08,699
こちらもアクセスするためのショートカットを書いて

584
01:40:08,699 --> 01:40:10,566
完成ということになります

585
01:40:10,833 --> 01:40:13,600
これでフォーマットの位置方向だけではなくて

586
01:40:13,600 --> 01:40:16,833
逆方向のパースも簡単に行えるようになりました

587
01:40:19,133 --> 01:40:20,766
本日はですね

588
01:40:20,766 --> 01:40:22,666
データのフォーマットというのは

589
01:40:22,666 --> 01:40:27,199
普段の開発でも常日頃行われているということを確認して

590
01:40:27,199 --> 01:40:31,533
フォーマットを行う手段、APIの移り変わりというのを眺めてみました

591
01:40:32,633 --> 01:40:35,600
標準で搭載されているフォーマットスタイルというのは

592
01:40:35,600 --> 01:40:37,800
非常に多くの種類があって

593
01:40:37,800 --> 01:40:40,633
ただそのどれもが Swift らしい安全さや

594
01:40:40,633 --> 01:40:44,399
流行りの機構によってモダンに使えるということが分かりました

595
01:40:45,500 --> 01:40:53,866
また、自分自身でフォーマットスタイルを作って、 拡張できるという柔軟さも備えていることが分かりました

596
01:40:54,666 --> 01:40:58,300
もし今あなたが携わっているプロジェクトで

597
01:40:58,300 --> 01:41:00,733
従来の方法でデータフォーマッティングをされているところがあれば

598
01:41:00,733 --> 01:41:04,566
このフォーマットスタイルへの移行もぜひ検討してみてください

599
01:41:06,833 --> 01:41:11,000
本トークの作成にあたっては、多くのAppleの公式のドキュメントですとか

600
01:41:11,000 --> 01:41:13,366
 WWDCのセッションも参考にしております

601
01:41:13,366 --> 01:41:16,233
これらはフォーマットスタイルを深く理解する上で

602
01:41:16,233 --> 01:41:18,933
非常に役に立ちますのでお勧めです

603
01:41:20,766 --> 01:41:22,166
それではぜひ今日から

604
01:41:22,166 --> 01:41:25,766
そろそろ FormatStyle というのを始めてみてください

605
01:41:26,199 --> 01:41:26,899
以上となります

606
01:41:26,899 --> 01:41:28,199
ご静聴ありがとうございました

607
01:41:38,566 --> 01:41:40,566
(司会) 発表ありがとうございました

608
01:41:40,833 --> 01:41:43,433
それではQ&Aに入りたいと思います

609
01:41:43,433 --> 01:41:47,233
コメントやご質問のある方は、 手を挙げてお知らせください

610
01:41:49,833 --> 01:41:52,000
マイクをお持ちします。 お持ちください

611
01:41:59,533 --> 01:42:01,166
(Q) お話ありがとうございます

612
01:42:01,833 --> 01:42:07,199
今まで経験的に、 DateFormatter をずっと使ってきて

613
01:42:08,633 --> 01:42:10,633
ユニットテストとかの観点で

614
01:42:12,199 --> 01:42:17,699
ロケールとかタイムゾーンっていうのを、 現在設定じゃなくて外から指定して

615
01:42:18,833 --> 01:42:21,833
フォーマットを使うっていうことが 結構多かったんですけれども

616
01:42:21,833 --> 01:42:24,833
フォーマットスタイルを使った場合も、 そういったことは可能なんでしょうか

617
01:42:26,133 --> 01:42:28,133
(treastrain) はい。ご質問いただきありがとうございます

618
01:42:28,566 --> 01:42:33,000
デートに関するフォーマットスタイルの修飾子で

619
01:42:33,000 --> 01:42:34,766
いろんなものを紹介しましたけれども

620
01:42:34,766 --> 01:42:38,233
その中にロケールを指定するという 修飾子も存在しています

621
01:42:38,233 --> 01:42:40,133
なので、それを使うことで

622
01:42:40,133 --> 01:42:44,466
ロケールを注入するということが可能かなと思いますし

623
01:42:44,466 --> 01:42:47,066
もしテスト用途みたいなところであれば

624
01:42:47,066 --> 01:42:50,033
そうですね、ロケールを注入できる

625
01:42:50,033 --> 01:42:52,899
自作のフォーマットスタイルみたいなので一回ラップして

626
01:42:52,899 --> 01:42:55,233
そのラップした方に対して

627
01:42:55,233 --> 01:42:59,166
テストコード側からインジェクションするみたいな設計をすると

628
01:42:59,166 --> 01:43:02,699
結構外側から見たときにきれいかなと思いつつ

629
01:43:03,166 --> 01:43:05,500
それをやってますよというのを チームの中に周知しないと

630
01:43:05,500 --> 01:43:08,166
これは何の型なんだみたいな問題も 起きるかなと思うので

631
01:43:08,166 --> 01:43:11,533
そこはちょっといい塩梅を狙うのが必要かなとも思います

632
01:43:11,833 --> 01:43:12,833
(Q) ありがとうございます

633
01:43:16,066 --> 01:43:17,366
(司会) ありがとうございました

634
01:43:17,833 --> 01:43:21,833
他にコメントやご質問のある方は、 挙手をお願いします

635
01:43:31,233 --> 01:43:32,233
(Q) ありがとうございます

636
01:43:34,133 --> 01:43:37,133
すごい興味本位なことなんですけれども

637
01:43:37,133 --> 01:43:39,866
ダブル型とかフローティングポイントの数値の

638
01:43:39,866 --> 01:43:42,833
フォーマットスタイルというのがあったと思うんですけれども

639
01:43:42,833 --> 01:43:46,833
そういうフローティングポイントナンバー というのがよくあることとして

640
01:43:46,833 --> 01:43:51,833
丸目精度というのが結構考慮することが あったりするじゃないですか

641
01:43:51,833 --> 01:43:55,833
例えばよくある話として、 0.1たす2は0.3じゃなくて0.30000…

642
01:43:55,833 --> 01:43:57,666
みたいなことがあるんですけれども

643
01:43:57,666 --> 01:44:02,166
例えばその0.1たす0.2の結果をフォーマット

644
01:44:02,166 --> 01:44:06,033
単純に例えば formatted で

645
01:44:06,033 --> 01:44:08,699
出力するとどうなるのかなというのがちょっと気になりました

646
01:44:09,533 --> 01:44:11,000
(treastrain) はい、ありがとうございます

647
01:44:11,000 --> 01:44:15,333
ダブル同士の足し算をした結果を フォーマットする場合は

648
01:44:15,333 --> 01:44:20,100
0.33333の方でストリングとして 出力されてしまいます

649
01:44:20,100 --> 01:44:23,633
なので誤差を含んだ状態で フォーマットしてしまうので

650
01:44:23,633 --> 01:44:28,533
誤差がない計算というのは無理なわけですけれども

651
01:44:28,533 --> 01:44:33,466
そこの問題はフォーマットする前に解決するという考え方が

652
01:44:33,466 --> 01:44:38,866
一応フォーマットスタイル側の見た目かなと自分は理解してます

653
01:44:42,833 --> 01:44:43,833
(司会) ありがとうございました

654
01:44:44,633 --> 01:44:48,133
他にコメントやご質問がある方は挙手をお願いします

655
01:44:58,466 --> 01:45:00,233
(Q) 発表ありがとうございます

656
01:45:01,199 --> 01:45:05,433
ローカライズの部分の話がいくつか出てきてたと思うんですけど

657
01:45:05,433 --> 01:45:07,266
一般に業務でやる場合は

658
01:45:07,266 --> 01:45:10,433
ローカライズストリングとかストリングカタログを使って

659
01:45:10,433 --> 01:45:15,066
行う部分と結構被る部分も役割としてはあったかなと思うんですけど

660
01:45:15,066 --> 01:45:17,866
どのように使い分けたりとか

661
01:45:17,866 --> 01:45:21,800
もしくはローカライズある程度フォーマットスタイルに寄せるべきなのかとか

662
01:45:21,800 --> 01:45:25,100
そういったところのお考えがあれば聞きたいです

663
01:45:25,566 --> 01:45:28,100
(treastrain) はい ありがとうございます

664
01:45:28,100 --> 01:45:30,566
途中で VStack の Text 二個じゃなくて

665
01:45:30,566 --> 01:45:33,866
Text 一個にする形式みたいなのを紹介しましたけども

666
01:45:33,866 --> 01:45:40,366
あれがローカライズドキーとかを使いたいときに

667
01:45:40,366 --> 01:45:44,100
あっちの方 書き方を使うっていうのが

668
01:45:44,100 --> 01:45:47,833
この FormatStyle の使い方かなというふうに思ってます

669
01:45:47,833 --> 01:45:54,699
私は FormatStyle で 40 分話すって結構僕えぐいかなと思ってるんですけども

670
01:45:54,699 --> 01:45:57,466
それが一応フォーマットスタイル好きなので

671
01:45:57,466 --> 01:46:01,366
自分の個人の見解としてはローカライズアブルのほうに

672
01:46:01,366 --> 01:46:04,966
このフォーマット側のほうは含めずに

673
01:46:04,966 --> 01:46:09,766
例えば単位の取り扱いですとか地域に合わせた記号の表示みたいのは

674
01:46:09,766 --> 01:46:12,666
このフォーマットスタイル側に任せて

675
01:46:12,666 --> 01:46:15,966
ローカライズアブルエクシストリングスのほうには書かないっていうのは

676
01:46:15,966 --> 01:46:17,366
お勧めしているというか

677
01:46:17,366 --> 01:46:20,066
普段の個人開発ではそのようにしてます

678
01:46:20,500 --> 01:46:22,300
(Q) ありがとうございます

679
01:46:23,733 --> 01:46:25,600
(司会) ありがとうございます

680
01:46:25,600 --> 01:46:28,300
お時間的に次が最後になりそうです

681
01:46:28,300 --> 01:46:31,600
コメントやご質問のある方は挙手をお願いします

682
01:46:37,833 --> 01:46:40,466
それではお時間になりましたので

683
01:46:40,466 --> 01:46:45,000
これにてQAセッションは終了させていただきます

684
01:46:45,000 --> 01:46:47,666
これで1分間フィードバックのお時間です

