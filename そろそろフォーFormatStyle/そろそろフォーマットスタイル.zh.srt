1
01:00:00,000 --> 01:00:06,966
差不多該開始了 FormatStyle

2
01:00:08,033 --> 01:00:12,366
好的，那麼接下來我將以「差不多該開始了 FormatStyle」

3
01:00:12,366 --> 01:00:15,366
為題進行發表，請多多指教

4
01:00:15,366 --> 01:00:18,566
本次發表由我 Tanaka Ryoga 擔任

5
01:00:18,566 --> 01:00:22,566
平常我是以這個橘色圖示進行活動

6
01:00:22,566 --> 01:00:25,866
跟新款 iPhone 的顏色是一樣的橘色呢

7
01:00:25,866 --> 01:00:28,966
個人開發方面，我使用 Swift 開發應用程式

8
01:00:28,966 --> 01:00:35,366
另外在 DeNA 股份有限公司也擔 任 iOS 應用程式開發者

9
01:00:35,366 --> 01:00:38,599
過去在 iOSDC Japan 曾經進行過 3 次演講

10
01:00:38,599 --> 01:00:40,966
都是 40 分鐘的常規演講

11
01:00:40,966 --> 01:00:45,166
這次是第 4 次

12
01:00:45,366 --> 01:00:50,366
我第一次登台演講是在 2021 年

13
01:00:50,366 --> 01:00:51,966
當時的題目是

14
01:00:51,966 --> 01:00:58,166
「輕鬆正確地將各種資訊格式化為字串」

15
01:00:58,166 --> 01:01:00,366
回顧當時的存檔

16
01:01:00,366 --> 01:01:07,566
內容是使用 Formatter 將各種資料轉換為字串

17
01:01:07,566 --> 01:01:13,366
當時的設計就像是那年在日本舉辦的國際體育賽事開幕式的一幕

18
01:01:13,366 --> 01:01:16,566
我是用那樣的設計發表的

19
01:01:16,566 --> 01:01:21,566
其中對於 2021 年當時最新的 iOS 版本

20
01:01:21,566 --> 01:01:26,966
iOS 15 的新功能稍微提到了一些

21
01:01:26,966 --> 01:01:28,566
當時的螢幕截圖是這樣的

22
01:01:28,566 --> 01:01:31,566
坐在後面的朋友可能看不太清楚

23
01:01:31,566 --> 01:01:34,566
在 Apple 關於新功能的文件中

24
01:01:34,566 --> 01:01:36,566
經常會出現「No overview available」

25
01:01:36,566 --> 01:01:39,566
也就是什麼都沒寫的文件

26
01:01:39,566 --> 01:01:41,333
當時就是這樣的狀況

27
01:01:41,333 --> 01:01:46,566
而這就是今天的主題—格式樣式 (FormatStyle)

28
01:01:46,566 --> 01:01:50,566
FormatStyle 是 iOS 15 以後可以使用的功能

29
01:01:50,566 --> 01:01:53,566
在 2021 年剛發布的當時

30
01:01:53,566 --> 01:01:57,566
例如因為最低部署目標 (Minimum Deployment Target) 等關係

31
01:01:57,566 --> 01:02:01,566
要導入實際產品可能有些困難

32
01:02:01,566 --> 01:02:03,566
但從那時起已經過了 4 年

33
01:02:03,566 --> 01:02:08,566
而且前陣子 iOS 26 也發布了

34
01:02:08,566 --> 01:02:11,566
根據 Apple 的資料，許多使用者的裝置

35
01:02:11,566 --> 01:02:14,566
已經支援 FormatStyle

36
01:02:14,566 --> 01:02:17,566
環境已經成熟了

37
01:02:17,566 --> 01:02:19,566
正是探討 FormatStyle

38
01:02:19,566 --> 01:02:24,566
最合適的時機，所以這次我決定進行發表

39
01:02:24,566 --> 01:02:28,566
本次演講的對象是在 Swift 或 iOS 應用程式開發中

40
01:02:28,566 --> 01:02:34,566
準備學習資料格式化的朋友

41
01:02:34,566 --> 01:02:37,566
雖然使用過傳統的格式化器 (Formatter)

42
01:02:37,566 --> 01:02:42,566
但對這個新的格式樣式還不太熟悉的朋友

43
01:02:42,566 --> 01:02:44,566
以及標準函式庫中沒有提供的

44
01:02:44,566 --> 01:02:47,566
自訂格式樣式的製作範例

45
01:02:47,566 --> 01:02:52,566
想要了解的朋友

46
01:02:52,566 --> 01:02:58,566
那麼，讓我們重新思考一下，什麼是資料格式化呢？

47
01:02:58,566 --> 01:03:01,566
這裡有一張螢幕截圖

48
01:03:01,566 --> 01:03:04,566
畫面中央顯示著本次演講的標題

49
01:03:04,566 --> 01:03:09,566
以及開始日期時間

50
01:03:09,566 --> 01:03:13,566
用 SwiftUI 的程式碼表示就是這樣

51
01:03:13,566 --> 01:03:21,566
現在演講開始日期時間的部分是直接在 Text 中寫入字串

52
01:03:21,566 --> 01:03:26,566
讓這個標題和開始日期時間從 View 外部傳入

53
01:03:26,566 --> 01:03:30,566
而且 Swift 有可以處理日期時間的

54
01:03:30,566 --> 01:03:32,566
Date 型別

55
01:03:32,566 --> 01:03:37,566
所以將這個 Date 屬性的型別從現在的 String 型別

56
01:03:37,566 --> 01:03:40,566
改為以 Date 型別傳入

57
01:03:40,566 --> 01:03:43,566
但是如果程式碼維持這樣的話

58
01:03:43,566 --> 01:03:45,566
SwiftUI 的 Text 初始化器

59
01:03:45,566 --> 01:03:49,566
無法傳入這個 Date 型別，會發生錯誤

60
01:03:49,566 --> 01:03:54,566
導致無法建置

61
01:03:54,566 --> 01:03:56,566
要解決這個建置錯誤

62
01:03:56,566 --> 01:04:01,566
就型別而言，需要使用某種方法從這個 Date 型別

63
01:04:01,566 --> 01:04:04,566
轉換為 String 型別

64
01:04:04,566 --> 01:04:08,566
抱歉，然後傳給 SwiftUI 的 Text 就可以了

65
01:04:08,566 --> 01:04:10,566
就是這樣

66
01:04:11,133 --> 01:04:15,500
那麼，讓我們來思考一下如何進行這個轉換

67
01:04:17,366 --> 01:04:19,033
Swift 的 Date 型別

68
01:04:19,033 --> 01:04:23,866
有 timeIntervalSinceReferenceDate 這個屬性

69
01:04:23,866 --> 01:04:29,566
這是從世界標準時間 2001 年 1 月 1 日 0 時 0 分開始

70
01:04:29,566 --> 01:04:35,566
有多少秒差異的值

71
01:04:35,566 --> 01:04:38,566
以日本時間今天 13 點來說

72
01:04:38,566 --> 01:04:43,833
會是 7 億 8033 萬 3600 秒這個數字

73
01:04:45,900 --> 01:04:51,566
從這個數字，進一步從年、月、日、時、分

74
01:04:51,833 --> 01:04:56,866
數字要透過四則運算來推算，這樣做比較好嗎？

75
01:04:58,633 --> 01:05:01,833
不過，就算能夠計算出西曆年份

76
01:05:01,833 --> 01:05:06,033
在 iOS 中使用者也可以將其設定為和曆

77
01:05:06,433 --> 01:05:09,033
這種情況下該如何因應才好呢？

78
01:05:11,233 --> 01:05:13,333
此外在英語環境中

79
01:05:13,333 --> 01:05:18,433
月份本來就不是數字而是固定的英文單字

80
01:05:18,633 --> 01:05:22,633
而且可能會偏好使用 12 小時制而非 24 小時制

81
01:05:24,833 --> 01:05:29,633
當有某些資料需要轉換成字串時

82
01:05:30,033 --> 01:05:34,233
考慮使用者的語言、地區、文化等因素

83
01:05:34,233 --> 01:05:39,633
我認為能以對該使用者來說最熟悉的格式來傳達資訊是最理想的

84
01:05:40,433 --> 01:05:43,433
這就稱為資料的格式化 (Format)

85
01:05:45,800 --> 01:05:47,866
對於像是我們這些開發 iOS 應用程式的人

86
01:05:47,866 --> 01:05:54,633
為世界各地多元使用者打造資訊傳遞介面的人來說

87
01:05:54,633 --> 01:06:01,266
將資料格式化成適當的形式，是無法迴避且非常重要的課題

88
01:06:01,266 --> 01:06:07,133
在一個應用程式中，可能會在各種地方反覆進行資料格式化

89
01:06:08,866 --> 01:06:14,333
另一方面，關於資料格式化有無數需要考慮的事項

90
01:06:14,333 --> 01:06:19,800
要讓它在任何時候都能如預期運作是非常困難的

91
01:06:21,533 --> 01:06:24,166
因此，對於常用的資料類型

92
01:06:24,166 --> 01:06:27,366
為了不需要自己撰寫格式化處理

93
01:06:27,366 --> 01:06:34,666
Swift 和 OS 的框架中已經預先準備好資料格式化的 API

94
01:06:35,733 --> 01:06:39,500
那麼，讓我們來試試資料格式化吧

95
01:06:40,333 --> 01:06:43,166
難得在 iOS 應用程式開發現場

96
01:06:43,166 --> 01:06:47,766
也逐漸能看到編碼智慧 (Coding Intelligence) 的應用案例

97
01:06:47,766 --> 01:06:52,466
這裡就來問問某個大型語言模型 (LLM) 吧

98
01:06:53,366 --> 01:07:00,033
選擇 Xcode 中出現錯誤的地方，按下「Generate Fix for Issue」按鈕

99
01:07:01,033 --> 01:07:05,033
結果，LLM 給出了某種回應

100
01:07:05,300 --> 01:07:10,033
看起來它幫我們修改了程式碼

101
01:07:10,566 --> 01:07:15,033
這裡使用了 DateFormatter

102
01:07:15,033 --> 01:07:19,666
DateFormatter 的父類別 NSFormatter

103
01:07:19,666 --> 01:07:22,033
是在 Swift 出現之前

104
01:07:22,033 --> 01:07:26,766
從 Objective-C 時代就已經存在的資料格式化 API

105
01:07:28,933 --> 01:07:34,500
Foundation 中有 13 種繼承 NSFormatter 的格式化器

106
01:07:34,500 --> 01:07:41,033
除了日期時間之外，還支援數值、人名、重量和長度等測量值

107
01:07:41,033 --> 01:07:44,533
對應各種類型的資料格式化

108
01:07:45,766 --> 01:07:49,133
從 2016 年 9 月發布的 Swift 3 開始

109
01:07:49,133 --> 01:07:54,400
呼叫時不再需要 NS 前綴，變成了這樣的外觀

110
01:07:54,400 --> 01:07:58,933
LLM 寫的就是使用這個 DateFormatter 的程式碼

111
01:08:00,466 --> 01:08:04,566
這個格式化器是非常強大且靈活的 API

112
01:08:04,566 --> 01:08:10,933
但從 Swift 現代開發典範以及重視安全性的觀點來看

113
01:08:10,933 --> 01:08:14,000
有幾個必須注意的地方

114
01:08:15,900 --> 01:08:20,033
那麼，讓我們繼續以 DateFormatter 為例來說明

115
01:08:20,033 --> 01:08:26,033
這裡準備了去年年底，也就是跨年前的時刻作為 Date 屬性

116
01:08:26,033 --> 01:08:30,033
讓我們來格式化這個資料

117
01:08:30,033 --> 01:08:38,133
建立 DateFormatter 類別的實例，指定日期時間格式化的形式

118
01:08:39,866 --> 01:08:44,033
完成後，使用實例方法 stringFrom

119
01:08:44,033 --> 01:08:47,500
取得格式化為 String 型別的結果

120
01:08:47,500 --> 01:08:53,033
如果熟悉命令式程式設計，我認為這是非常易讀的程式碼

121
01:08:53,433 --> 01:08:59,033
如果格式化結果中不需要時刻的部分

122
01:08:59,033 --> 01:09:05,033
可以在 timeStyle 的部分指定 .none 來進行客製化

123
01:09:05,033 --> 01:09:14,033
那麼，如果只想要年和月的部分，不需要日的話，該怎麼做呢？

124
01:09:14,033 --> 01:09:21,033
DateFormatter 有一個可以更靈活指定格式化形式的 dateFormat 屬性

125
01:09:21,833 --> 01:09:29,333
這次因為只想要年和月，所以使用大寫的 Y 和大寫的 M

126
01:09:29,333 --> 01:09:35,033
然後因為希望在後面也顯示「年」和「月」的漢字，所以加上去

127
01:09:35,033 --> 01:09:39,533
那麼用實例方法 stringFrom 來格式化的話

128
01:09:39,533 --> 01:09:45,666
年份的數字變成了 2025 而不是 2024

129
01:09:45,666 --> 01:09:49,100
這是哪裡出錯了呢？

130
01:09:51,366 --> 01:09:55,233
這個 dateFormat 屬性所接受的字串

131
01:09:55,233 --> 01:09:59,433
必須使用 Unicode 技術標準的規範

132
01:10:01,333 --> 01:10:07,800
必須根據 Unicode 規範中的表格來組建 dateFormat 的字串

133
01:10:07,800 --> 01:10:10,433
那是一個非常龐大的表格

134
01:10:10,433 --> 01:10:14,100
從螢幕上已經看不清楚寫了什麼

135
01:10:14,100 --> 01:10:16,633
剛才 dateFormat 的這個錯誤

136
01:10:16,633 --> 01:10:24,633
是表示年份的 Y 這個字元，應該要用小寫而不是大寫

137
01:10:24,633 --> 01:10:28,333
本來想說這樣就解決了

138
01:10:28,333 --> 01:10:31,033
但之後如果在英語環境中

139
01:10:31,033 --> 01:10:36,433
也要支援像 December 2024 這樣的表記方式

140
01:10:36,433 --> 01:10:38,633
這時候該怎麼辦呢？

141
01:10:38,633 --> 01:10:45,133
目前的狀況是 DateFormatter 中直接包含了年、月等漢字

142
01:10:45,133 --> 01:10:49,100
而且日文是年在前、月在後

143
01:10:49,100 --> 01:10:53,633
但在英文的情況是月在前、年在後，有這樣的差異

144
01:10:54,966 --> 01:10:58,500
像這樣即使只是日期時間的格式

145
01:10:58,500 --> 01:11:00,866
需要考慮的模式就有無數種

146
01:11:00,866 --> 01:11:04,633
而且即使格式字串的指定有錯誤

147
01:11:04,633 --> 01:11:08,166
在執行程式之前也無法知道結果

148
01:11:08,166 --> 01:11:13,000
因此不應該直接在 DateFormatter 中指定字串

149
01:11:15,133 --> 01:11:17,633
在 Apple 的 WWDC 講座中

150
01:11:17,633 --> 01:11:20,866
也明確指出這幾乎必定會產生非預期的結果

151
01:11:20,866 --> 01:11:25,933
清楚說明了不要直接在 dateFormat 中指定字串

152
01:11:27,199 --> 01:11:29,666
因為很重要所以再說一次

153
01:11:29,666 --> 01:11:33,199
在非常舊的資料中可能會說只有這個方法

154
01:11:33,199 --> 01:11:36,600
而介紹直接對 dateFormat 指定的方法

155
01:11:36,600 --> 01:11:41,399
或是程式碼智慧工具的 LLM 可能會建議這個方法

156
01:11:41,399 --> 01:11:43,233
但請不要使用

157
01:11:43,233 --> 01:11:46,600
我想這應該寫在 Agents.md 之類的地方會比較好

158
01:11:49,100 --> 01:11:51,199
話題有點偏離了

159
01:11:51,199 --> 01:11:52,866
讓我們回到最初的程式碼

160
01:11:53,899 --> 01:11:56,066
重新閱讀這段程式碼

161
01:11:56,066 --> 01:12:00,000
在 SwiftUI 的 View Protocol 的 body 中

162
01:12:00,000 --> 01:12:04,633
呼叫了 formattedDate

163
01:12:04,633 --> 01:12:09,633
這個 formattedDate 是 Computed Property，每次被呼叫時

164
01:12:09,633 --> 01:12:12,633
都會生成 DateFormatter 的實例

165
01:12:12,633 --> 01:12:17,866
並指定 dateStyle、timeStyle 來進行格式化

166
01:12:19,366 --> 01:12:25,333
SwiftUI 的 View 的 body 可能會被框架多次呼叫

167
01:12:26,000 --> 01:12:31,233
每次被呼叫時都會重新生成 formatter 的實例

168
01:12:32,233 --> 01:12:37,266
眾所周知，生成 formatter 實例的成本非常高

169
01:12:38,633 --> 01:12:44,633
關於這個高成本的問題，已經有許多人提及

170
01:12:44,633 --> 01:12:48,866
例如我們來看看 Apple 今年 WWDC 的講座

171
01:12:50,166 --> 01:12:55,633
可以從效能不好的 SwiftUI 應用程式中發現有 hitches 或 hangs

172
01:12:55,633 --> 01:12:58,633
透過 Instruments 測量

173
01:12:58,633 --> 01:13:05,533
在剛剛那段程式碼中 View 的 body 中多次生成 formatter 實例的地方

174
01:13:05,533 --> 01:13:07,633
這類的話題

175
01:13:08,633 --> 01:13:14,633
作為對應策略，使用 formatter 來生成格式化字串

176
01:13:14,633 --> 01:13:21,166
將 string(from:) 的呼叫改為在其他地方事先統一執行

177
01:13:21,166 --> 01:13:26,466
或是將 formatter 實例的生成次數降到最低

178
01:13:26,466 --> 01:13:30,399
透過快取的方式，該議程中介紹了這些方法

179
01:13:32,633 --> 01:13:35,966
那麼讓我們總結一下到目前為止的內容

180
01:13:37,300 --> 01:13:42,633
傳統的 formatter 是功能非常強大且可高度客製化的

181
01:13:42,633 --> 01:13:47,633
但在某些模式下，即使客製化有錯誤

182
01:13:47,633 --> 01:13:52,633
在編譯時也無法察覺，必須實際執行才能確認

183
01:13:54,366 --> 01:13:57,633
此外，生成 formatter 實例的成本

184
01:13:57,633 --> 01:14:03,633
以及雖然省略說明，但屬性變更的成本也很高

185
01:14:05,100 --> 01:14:12,899
因此最佳實踐是自行實作快取機制來減少這些操作的次數

186
01:14:14,333 --> 01:14:17,600
另外，Swift 通常使用值型別 (value type)

187
01:14:17,600 --> 01:14:19,966
但是這個 formatter 是參考型別 (reference type)

188
01:14:20,500 --> 01:14:24,633
在共享快取時也需要注意這一點

189
01:14:25,633 --> 01:14:32,633
還有在現今 Swift Concurrency 的時代，是否執行緒安全也需要特別注意

190
01:14:34,000 --> 01:14:40,300
而且它不是 SwiftUI 等流行的宣告式，而是命令式的 API 設計

191
01:14:42,333 --> 01:14:49,633
到目前為止，我並不打算深入探討 formatter 的好壞

192
01:14:49,633 --> 01:14:54,566
只是，利用這些特性和思維方式的現在

193
01:14:54,566 --> 01:15:00,533
作為符合現今 Swift 時代的全新介面而登場的就是 FormatStyle

194
01:15:02,666 --> 01:15:07,800
這個格式樣式，正確來說是一個協定（Protocol）的名稱

195
01:15:07,800 --> 01:15:12,899
可在 iOS 15 及以後使用，用於將特定的資料型別轉換為另一種型別

196
01:15:12,899 --> 01:15:19,833
例如字串（String）型別的介面

197
01:15:20,800 --> 01:15:26,033
系統預設準備了各種用途的格式樣式

198
01:15:26,033 --> 01:15:31,266
截至 iOS 26 為止，共有 46 種格式樣式存在

199
01:15:33,233 --> 01:15:37,166
這是使用傳統 Formatter 撰寫的程式碼

200
01:15:37,166 --> 01:15:42,399
如果改用格式樣式來撰寫的話，會變成這樣

201
01:15:42,966 --> 01:15:46,266
程式碼變得非常精簡了呢

202
01:15:46,966 --> 01:15:49,699
讓我們比較一下兩者的程式碼

203
01:15:49,699 --> 01:15:55,266
過去存在的 DateFormatter 的程式碼整段就消失了

204
01:15:55,266 --> 01:16:05,966
而且過去是將資料傳遞給格式器端存在的方法的參數

205
01:16:05,966 --> 01:16:13,199
但使用 FormatStyle 的方法則是改為對資料加上 formatted 這個方法

206
01:16:15,100 --> 01:16:19,366
不需要自己建立對應資料的格式器實例

207
01:16:19,366 --> 01:16:23,566
只需簡單地對資料加上 formatted

208
01:16:23,566 --> 01:16:26,000
就能輕鬆進行格式化

209
01:16:27,300 --> 01:16:32,466
也可以在這個 formatted 方法中指定詳細的樣式

210
01:16:32,466 --> 01:16:36,833
如果不指定的話，就會使用預設的實作

211
01:16:38,166 --> 01:16:40,566
關於彈性的樣式指定

212
01:16:40,566 --> 01:16:45,966
也不需要記住剛才提到的羅馬字小寫 Y 會怎樣、大寫 M 會怎樣之類

213
01:16:45,966 --> 01:16:49,766
複雜的字串樣式規則

214
01:16:49,766 --> 01:16:54,033
想要年份就加上 year，想要月份就加上 month

215
01:16:54,033 --> 01:16:58,699
可以一邊使用程式碼補全功能一邊安全地撰寫

216
01:16:58,699 --> 01:17:02,866
而且之後閱讀時的可讀性也非常高

217
01:17:04,966 --> 01:17:08,733
FormatStyle 是為 Swift 而設計的

218
01:17:08,733 --> 01:17:12,800
外部介面的部分是 100% 用 Swift 撰寫的

219
01:17:14,066 --> 01:17:18,266
而且相對於格式器是類別（Class）、參考型別

220
01:17:18,266 --> 01:17:23,600
FormatStyle 是用結構（Struct）、值型別 (Value Type) 來建立

221
01:17:23,600 --> 01:17:26,100
具有容易受到堆疊上的配置、寫入時複製（Copy-on-Write）

222
01:17:26,100 --> 01:17:30,300
編譯器最佳化等好處的優點

223
01:17:31,466 --> 01:17:35,233
樣式的指定可以以型別安全的方式進行

224
01:17:35,233 --> 01:17:42,366
FormatStyle 內部使用的格式器實例會由框架端自動快取

225
01:17:42,366 --> 01:17:48,466
從剛才必須考慮手動快取之類的事情中解放出來

226
01:17:48,466 --> 01:17:53,166
在效能上的優點似乎也能在一定程度上享受到

227
01:17:53,166 --> 01:17:56,833
還有，搭配流行的宣告式介面

228
01:17:56,833 --> 01:18:02,433
對現代的人們來說變得更容易使用，就是這個 FormatStyle

229
01:18:03,500 --> 01:18:10,266
了解了傳統的 Formatter 與 FormatStyle 在介面等方面的差異之後

230
01:18:10,266 --> 01:18:15,666
接下來要介紹協定中定義的格式樣式規則

231
01:18:17,033 --> 01:18:20,766
符合格式樣式協定的型別

232
01:18:20,766 --> 01:18:23,266
作為主要關聯型別（Primary Associated Type）的形式

233
01:18:23,266 --> 01:18:32,633
必須指定格式的輸入端型別與輸出端型別分別是什麼

234
01:18:33,466 --> 01:18:41,000
然後需要實作使用實際用來輸入的值進行格式化並輸出結果的方法

235
01:18:42,466 --> 01:18:49,500
在今天一開始展示的，從 Date 型別到 String 型別的格式化的情況下

236
01:18:49,500 --> 01:18:58,233
FormatInput 會是 Date 型別，FormatOutput 則會是 String 型別

237
01:19:00,166 --> 01:19:10,233
接下來，我想列舉 iOS 26 之前包含的所有可立即使用的格式樣式種類

238
01:19:10,233 --> 01:19:17,199
不過，到目前為止我們都在討論日期時間的格式化

239
01:19:17,199 --> 01:19:22,199
現在的 iOS 也存在對應其他資料的格式樣式

240
01:19:22,199 --> 01:19:26,666
不過，要一次記住這些全部是有難度的

241
01:19:26,666 --> 01:19:30,300
而且從這裡開始不斷列舉的話可能會讓人想睡覺

242
01:19:30,300 --> 01:19:36,633
如果方便的話，希望大家可以在之後公開的資料或是封存影片中回來複習

243
01:19:38,399 --> 01:19:42,600
那麼首先，讓我們來看看日期與時間

244
01:19:42,600 --> 01:19:50,533
Date.FormatStyle 是進行日期與時刻格式化的最基本樣式

245
01:19:50,533 --> 01:19:56,133
Date 型別的屬性加上 formatted 後，就會使用這個格式樣式

246
01:19:56,133 --> 01:20:04,833
可以透過 date 參數和 time 參數來更進一步地指定樣式，來達到各種不同的表現方式

247
01:20:04,833 --> 01:20:14,033
此外，使用方法鏈可以詳細設定年、月、日、時、分、秒，以及時區等資訊

248
01:20:14,033 --> 01:20:18,266
欄位的順序不會影響最終的輸出結果

249
01:20:18,266 --> 01:20:22,866
作業系統會根據地區設定 (locale) 適當地進行配置

250
01:20:22,866 --> 01:20:31,066
例如，上面的例子是按照美式英語的月、日、年順序來指定的

251
01:20:31,066 --> 01:20:36,899
但在日本的日語環境下執行時，就會正確地顯示為年、月、日

252
01:20:36,899 --> 01:20:40,800
此外，還可以進行月份或星期的縮寫顯示

253
01:20:40,800 --> 01:20:46,433
以及當數字為一位數時用零填補 (padding) 等處理

254
01:20:48,233 --> 01:20:54,033
接下來， 有一個叫做 Date.ISO8601FormatStyle 的東西

255
01:20:54,033 --> 01:20:58,633
在 formatted 地方寫上 .iso8601

256
01:20:58,633 --> 01:21:01,000
這在與伺服器進行資料通訊等情況下

257
01:21:01,000 --> 01:21:07,699
有 ISO 8601 這個規範，當需要該日期時間格式時，可以非常方便地使用

258
01:21:10,199 --> 01:21:14,833
可以加上時區資訊，或者像剛才的 date format 一樣

259
01:21:14,833 --> 01:21:21,000
用方法鏈寫出想要的元素，細緻地指定要輸出的元素

260
01:21:22,100 --> 01:21:30,833
在 iOS 26 中，DateComponents 也準備了 ISO 8601 格式的樣式

261
01:21:32,800 --> 01:21:42,066
這也是新導入的功能，還有符合 HTTP 的 RFC 9110 規範的格式樣式

262
01:21:42,566 --> 01:21:50,899
在網頁通訊中處理日期時間標頭 (header) 等時，我認為會變得格外容易

263
01:21:52,166 --> 01:21:56,233
這個同樣也有 DateComponents 版本

264
01:21:57,800 --> 01:22:04,966
如果想要更進一步自訂輸出格式，可以使用 Date.VerbatimFormatStyle

265
01:22:05,766 --> 01:22:10,566
就像前面提到的傳統 DateFormatter 的 dateFormat 屬性一樣

266
01:22:10,566 --> 01:22:15,000
這是一個可以用字串直接指定自訂格式的樣式

267
01:22:15,000 --> 01:22:20,866
不過，透過這個 Date.FormatString 所提供的字串插值 (string interpolation)

268
01:22:20,866 --> 01:22:26,800
藉由字串補完項群，可以以型別安全的方式進行格式化

269
01:22:26,800 --> 01:22:37,699
例如，像這裡這樣，有一種需要用年號和年、月、日用句點連接的和曆格式

270
01:22:37,699 --> 01:22:42,899
如果在格式化時與地區設定和時區一起指定的話

271
01:22:42,899 --> 01:22:47,033
無論 iOS 裝置的日曆是西曆還是和曆

272
01:22:47,033 --> 01:22:56,633
都能確實地得到像這個例子 R07.09.20 這樣符合和曆規格的輸出

273
01:22:58,899 --> 01:23:02,766
接下來，這個 Date.IntervalFormatStyle

274
01:23:02,766 --> 01:23:07,066
是用來格式化兩個日期之間期間的樣式

275
01:23:07,066 --> 01:23:11,366
它接收日期的範圍型別作為輸入

276
01:23:11,366 --> 01:23:15,566
以符合使用者地區設定的自然形式來格式化期間

277
01:23:15,899 --> 01:23:21,633
例如，省略時刻只輸出日期期間時

278
01:23:21,633 --> 01:23:29,300
在日本的日語環境下會輸出「19日〜21日」用波浪線、波浪破折號

279
01:23:29,300 --> 01:23:37,533
在美式英語環境下則會輸出「September 19 – 21」這樣的形式

280
01:23:38,566 --> 01:23:46,366
還有 Date.ComponentsFormatStyle，這個會格式化日期元件之間的差異

281
01:23:46,566 --> 01:23:54,933
將兩個日期之間的差異以「2 天」或「2 天 2 小時」等人類易讀的形式顯示

282
01:23:55,433 --> 01:24:00,166
這個也可以透過 style 參數來自訂輸出樣式

283
01:24:02,566 --> 01:24:08,033
類似的還有 Date.RelativeFormatStyle

284
01:24:08,033 --> 01:24:16,000
這是用來格式化以現在時刻為基準的相對日期時間的樣式

285
01:24:16,000 --> 01:24:18,233
使用 named 樣式的話

286
01:24:18,233 --> 01:24:23,566
就可以得到「上個月」、「這個月」、「下個月」等自然語言的表達

287
01:24:23,566 --> 01:24:29,899
改用 numeric 樣式的話，可以進行「1 個月後」這樣的數值相對表達

288
01:24:31,000 --> 01:24:34,100
也能進行非單位的相對表達

289
01:24:34,100 --> 01:24:38,300
像是「前天」、「昨天」、「今天」、「明天」、「後天」這樣的表達

290
01:24:38,300 --> 01:24:42,166
會根據地區設定自動套用

291
01:24:42,166 --> 01:24:49,800
這個格式樣式會以現在時刻為基準輸出相對的內容

292
01:24:50,399 --> 01:24:54,566
如果想要指定任意時刻為基準的話

293
01:24:54,566 --> 01:24:58,966
就使用這個 Date.AnchoredRelativeFormatStyle

294
01:24:58,966 --> 01:25:02,300
將特定的日期時間指定為錨點

295
01:25:02,300 --> 01:25:09,399
然後以該基準對輸入的日期時間進行相對格式化

296
01:25:13,399 --> 01:25:16,600
關於日期時間的格式化已經講了很多

297
01:25:16,600 --> 01:25:22,433
但我想數值的格式化也是同樣常用的功能

298
01:25:22,433 --> 01:25:29,666
整數、浮點數、Decimal 型別都各自有對應的 FormatStyle

299
01:25:29,666 --> 01:25:35,600
預設會根據裝置的地區、進行三位數分隔等顯示

300
01:25:35,600 --> 01:25:41,633
在日本的日語環境下，就是每三位數會出現逗號的感覺

301
01:25:41,633 --> 01:25:51,866
此外使用 rounded 的話，可以指定四捨五入、無條件捨去、無條件進位等數字的進位規則

302
01:25:51,866 --> 01:25:56,000
還可以指定有效位數、使用指數表示法等

303
01:25:56,000 --> 01:26:00,133
有很多修飾詞可以用來自訂

304
01:26:02,033 --> 01:26:09,500
各個數值型別也都準備了以百分率、百分比形式格式化的樣式

305
01:26:09,500 --> 01:26:15,699
數值會自動乘以 100 倍，並根據地區設定加上百分比符號

306
01:26:15,699 --> 01:26:23,666
百分比符號要放在哪裡、百分比符號本身是什麼，這些都會因地區設定而不同

307
01:26:23,666 --> 01:26:26,000
這個部分也會自動幫我們調整

308
01:26:28,000 --> 01:26:32,266
同樣地也有格式化貨幣的樣式

309
01:26:32,266 --> 01:26:40,199
透過指定貨幣代碼，可以支援根據地區設定的貨幣符號以及小數點以下的位數

310
01:26:40,800 --> 01:26:44,366
即使在同一個國家或地區，如果語言不同

311
01:26:44,366 --> 01:26:49,199
貨幣符號顯示的位置也會改變，這點也有支援

312
01:26:52,133 --> 01:26:59,366
接下來介紹 iOS 16 導入的 Duration 型別所使用的 FormatStyle

313
01:27:01,000 --> 01:27:03,933
有一個叫做 Duration.TimeFormatStyle 的樣式

314
01:27:03,933 --> 01:27:10,533
它會將 Duration 的值以時、分、秒的形式格式化

315
01:27:11,600 --> 01:27:17,699
有一個叫做 pattern 的參數，在這裡指定 hourMinute 或 hourMinuteSecond 等

316
01:27:17,699 --> 01:27:22,566
就可以細緻地控制時、分、秒的顯示格式

317
01:27:23,300 --> 01:27:29,666
使用 padHourToLength 等方法，也可以對齊位數

318
01:27:31,366 --> 01:27:34,633
還有一個叫做 UnitsFormatStyle 的樣式

319
01:27:34,633 --> 01:27:40,033
它會自動使用最適合的單位來格式化 Duration 的值

320
01:27:40,033 --> 01:27:46,666
可以從這邊指定要使用的單位，也可以用零來填補位數

321
01:27:48,966 --> 01:27:53,000
接下來是關於測量值的 FormatStyle

322
01:27:54,133 --> 01:27:57,466
大家知道 Swift 中的測量值嗎？

323
01:27:57,466 --> 01:28:03,500
Swift 的 Foundation 中有一個可以表示各種值的單位，叫做 Measurement

324
01:28:05,199 --> 01:28:08,866
例如當有表示面積的資料時

325
01:28:08,866 --> 01:28:15,266
可能首先會想到簡單地使用 Int 型別或 Double 型別

326
01:28:15,600 --> 01:28:19,033
但如果使用 UnitArea 的 Measurement 型別

327
01:28:19,033 --> 01:28:24,500
就可以透過型別系統明確地表示這個資料是面積

328
01:28:25,399 --> 01:28:29,766
同時也可以持有該資料的單位

329
01:28:29,766 --> 01:28:36,433
這裡用平方公里表示東北三個縣的面積

330
01:28:36,433 --> 01:28:41,399
所以後面寫著 squareKilometers

331
01:28:41,699 --> 01:28:47,733
對這些加上 formatted 後，就會一起輸出資料的數值和單位

332
01:28:47,733 --> 01:28:52,800
可以將單位的輸出樣式從這個「平方公里」

333
01:28:52,800 --> 01:28:56,466
轉換成漢字和片假名的形式

334
01:28:56,466 --> 01:29:00,300
如果針對美式英語格式化的話

335
01:29:00,300 --> 01:29:04,000
平方公里就會轉換成平方英里輸出

336
01:29:06,666 --> 01:29:14,166
也準備了適合表示記憶體或檔案大小的 FormatStyle

337
01:29:14,833 --> 01:29:21,966
會自動轉換成 KB、MB、GB 等最適合的單位並輸出

338
01:29:21,966 --> 01:29:27,000
這個也可以用 style 參數和 unit 參數來控制顯示格式和單位

339
01:29:29,633 --> 01:29:34,600
接下來也有用來格式化人名的 FormatStyle

340
01:29:34,600 --> 01:29:41,266
有一個關於人名的型別叫做 PersonNameComponents

341
01:29:41,266 --> 01:29:45,133
可以從這裡格式化人名

342
01:29:45,133 --> 01:29:51,766
用 style 參數可以選擇 short、medium、long 等顯示格式

343
01:29:51,766 --> 01:29:55,833
會根據地區設定自動套用姓名的順序

344
01:29:58,233 --> 01:30:04,333
像這樣用羅馬拼音指定姓名、暱稱的話

345
01:30:04,333 --> 01:30:12,133
在縮寫形式中會產生縮寫字母，在日本地區設定中會是姓名的順序

346
01:30:12,133 --> 01:30:17,899
但在英語地區設定中則會以名、姓的順序顯示縮寫字母，有這樣的差異

347
01:30:21,533 --> 01:30:23,933
馬上就要介紹完全部了

348
01:30:23,933 --> 01:30:28,633
關於 URL 的格式樣式也有預設存在

349
01:30:28,633 --> 01:30:35,833
可以將 URL 的 host、path、qury等特定元件進行格式化

350
01:30:35,833 --> 01:30:40,800
例如像這樣只取出 query 的部分

351
01:30:40,800 --> 01:30:47,133
或是像瀏覽器應用程式那樣，只想向使用者顯示 URL 的網域部分時

352
01:30:47,133 --> 01:30:48,500
應該會很有用

353
01:30:51,833 --> 01:30:56,199
最後要介紹其他一些比較特殊的格式樣式

354
01:30:57,766 --> 01:31:04,966
有準備將陣列等序列的元素連結起來，格式化為一個字串的樣式

355
01:31:04,966 --> 01:31:10,133
這個樣式會根據地區設定，自動套用逗號或頓號等

356
01:31:10,133 --> 01:31:17,366
適當的分隔符號，以及連接詞

357
01:31:18,133 --> 01:31:25,133
例如在日文中會變成「蘋果、頓號、香蕉、頓號、橘子」這樣

358
01:31:25,133 --> 01:31:30,133
在英文中則會是「apple、逗號、banana、逗號、and、orange」這樣

359
01:31:30,133 --> 01:31:33,366
變成人類閱讀時非常自然的樣式

360
01:31:35,133 --> 01:31:39,133
這個列表格式樣式的成員樣式 (member style) 參數

361
01:31:39,133 --> 01:31:42,133
也可以傳入其他的格式樣式

362
01:31:42,133 --> 01:31:49,333
對列表的各個元素個別進行格式化，最終連結成的字串

363
01:31:49,333 --> 01:31:51,733
也可以用這個列表格式樣式來處理

364
01:31:53,133 --> 01:31:57,133
先將數字格式化，最後再將它格式化為一個字串

365
01:31:57,133 --> 01:32:00,866
這就是這個範例的做法

366
01:32:02,133 --> 01:32:05,133
這個我們幾乎不會直接使用

367
01:32:05,133 --> 01:32:09,133
但也有將字串格式化為字串的方式

368
01:32:09,133 --> 01:32:12,699
是一種輸入和輸出不變的樣式

369
01:32:12,699 --> 01:32:17,533
例如在泛型的情境中（譯按：或型別推斷），一定需要格式樣式的時候

370
01:32:17,533 --> 01:32:21,833
作為預設的替代文字 (placeholder) 使用的，就是這個字串樣式

371
01:32:24,066 --> 01:32:25,266
就是這樣

372
01:32:27,600 --> 01:32:33,500
StoreKit 框架中也有 FormatStyle 存在

373
01:32:33,500 --> 01:32:43,133
這裡準備了用來將訂閱期間以日、月、年為單位進行格式化的樣式

374
01:32:43,133 --> 01:32:47,466
例如在 App Store Connect 中指定的訂閱期間

375
01:32:47,466 --> 01:32:50,733
就可以在應用程式內適當地進行本地化

376
01:32:54,133 --> 01:32:55,133
非常辛苦了

377
01:32:55,133 --> 01:33:01,133
以上就是 iOS 26 之前搭載的所有基本格式樣式

378
01:33:01,533 --> 01:33:03,866
希望將來在各位平常的開發中

379
01:33:03,866 --> 01:33:08,533
我會很開心如果這些能成為大家想起「或許有那個格式樣式」的契機

380
01:33:10,899 --> 01:33:15,866
那麼接下來想稍微回到格式樣式外部介面的話題

381
01:33:17,133 --> 01:33:20,666
在剛才提到的格式樣式中

382
01:33:20,666 --> 01:33:26,100
有可以輕鬆對輸出的字串進行裝飾的類型的 FormatStyle

383
01:33:27,899 --> 01:33:34,500
這個格式的輸出型別是可以加上屬性的字串，也就是 AttributedString

384
01:33:36,633 --> 01:33:41,133
那麼來看看它是如何運作的

385
01:33:41,366 --> 01:33:45,966
用 FormatStyle 改寫後最初螢幕截圖是這個

386
01:33:47,133 --> 01:33:51,033
我取出了這裡格式化日期時間的部分

387
01:33:52,600 --> 01:33:56,300
如果是支援屬性 (attribute) 的格式樣式

388
01:33:56,300 --> 01:34:02,133
可以像這樣在 FormatStyle 的最後，加上 attributed 或 attributedStyle

389
01:34:02,133 --> 01:34:05,133
兩者都可以

390
01:34:05,133 --> 01:34:11,133
例如像這樣只對年份的部分指定前景色為紅色

391
01:34:11,133 --> 01:34:12,866
就會反映在視圖 (view) 上

392
01:34:15,133 --> 01:34:17,133
其他常見的例子

393
01:34:17,133 --> 01:34:24,466
例如格式化貨幣時，只想讓貨幣符號的部分字體大小比數字小

394
01:34:24,466 --> 01:34:26,899
這樣的需求有時會出現

395
01:34:26,899 --> 01:34:31,133
這也可以用有 attributed 的 FormatStyle 來達成

396
01:34:31,133 --> 01:34:36,000
這是日圓符號的部分比數字稍微小一點的呈現

397
01:34:40,933 --> 01:34:43,133
因為時間關係省略說明

398
01:34:43,133 --> 01:34:46,733
從 iOS 18 開始的 SwiftUI 碼表

399
01:34:46,733 --> 01:34:52,166
也有專門用於計時器等顯示的帶屬性格式樣式存在

400
01:34:53,899 --> 01:34:56,366
那麼，既然提到了 SwiftUI 的話題

401
01:34:56,366 --> 01:35:01,533
我們也來稍微看一下從 SwiftUI 使用 FormatStyle 的方法

402
01:35:03,066 --> 01:35:11,199
在這場演講的開頭，我說明了 SwiftUI 的 Text 初始化器無法傳入 Date 型別

403
01:35:12,066 --> 01:35:18,533
所以我提到可以使用 formatted 方法轉換成 String 型別來解決這個問題

404
01:35:18,533 --> 01:35:23,899
但實際上，Text 還有另一個可以接收 Date 型別的初始化器存在

405
01:35:24,833 --> 01:35:26,500
就是這個形式

406
01:35:26,833 --> 01:35:30,933
在 Text 的第一個參數放入某種資料

407
01:35:30,933 --> 01:35:35,533
在第二個參數的 format 部分傳入 FormatStyle

408
01:35:35,533 --> 01:35:38,433
就可以作為 SwiftUI 的 Text 來處理

409
01:35:39,500 --> 01:35:42,166
我認為這是最佳的方法

410
01:35:42,166 --> 01:35:47,100
特別是在建構運作限制嚴格的 Widget、Live Activity

411
01:35:47,100 --> 01:35:52,833
或是 Complication 這類功能時，更應該使用這個方法

412
01:35:53,666 --> 01:35:56,399
雖然在這個範例程式碼中不太明顯

413
01:35:56,399 --> 01:35:57,699
但根據資料型別的不同

414
01:35:57,699 --> 01:36:02,566
還存在效能更好的 DiscreteFormatStyle

415
01:36:02,566 --> 01:36:05,066
也有可能受惠於此

416
01:36:05,333 --> 01:36:08,966
如果可以的話，很希望能在 Ask the Speaker 等場合聊聊天

417
01:36:10,233 --> 01:36:14,533
此外，這裡雖然使用了 VStack

418
01:36:14,533 --> 01:36:19,266
但如果想要將它作為一個 Text 來處理的話

419
01:36:19,266 --> 01:36:26,266
也可以使用 String Interpolation 中帶有 format 參數的寫法

420
01:36:28,833 --> 01:36:33,833
到目前為止，我們都是使用 SwiftUI 的 Text 來展示

421
01:36:33,833 --> 01:36:36,833
從這邊向使用者顯示內容的格式範例

422
01:36:36,833 --> 01:36:40,233
但這個格式也可以用在 TextField 上

423
01:36:41,833 --> 01:36:46,833
我們一直在看如何將某種資料格式化為字串

424
01:36:46,833 --> 01:36:49,833
但反過來，從使用者接收字串

425
01:36:49,833 --> 01:36:54,833
再用某種方法解析並轉換成這邊的資料型別

426
01:36:54,833 --> 01:36:56,833
也就是 Parse 的處理

427
01:36:56,833 --> 01:36:59,366
有時候會需要這樣的處理

428
01:37:04,300 --> 01:37:09,833
這時就有 ParseableFormatStyle 存在

429
01:37:10,633 --> 01:37:14,833
這個 ParseableFormatStyle 的 Parse 處理

430
01:37:14,833 --> 01:37:18,833
是在 ParseStrategy 這邊定義的

431
01:37:18,833 --> 01:37:26,433
這裡有 ParseInput 和 ParseOutput 這兩個型別，請注意看

432
01:37:26,433 --> 01:37:29,600
這個 ParseInput 和 ParseOutput

433
01:37:29,600 --> 01:37:36,533
被定義為與原本 FormatStyle 的 Input 和 Output 分別是對應的

434
01:37:36,533 --> 01:37:40,699
藉此表現出資料的格式化 (Format) 與解析 (Parse)

435
01:37:40,699 --> 01:37:44,500
分別是相反方向的關係

436
01:37:44,500 --> 01:37:47,266
我超喜歡這種表現方式

437
01:37:48,333 --> 01:37:51,966
以日期時間、數值或 URL 這類

438
01:37:51,966 --> 01:37:55,100
規則明確的 FormatStyle 為核心

439
01:37:55,100 --> 01:37:58,833
它們也都符合 ParseableFormatStyle

440
01:37:58,833 --> 01:38:03,833
連人名也可以 Parse，真是令人驚訝呢

441
01:38:05,033 --> 01:38:07,399
那麼關於這個 ParseableFormatStyle

442
01:38:07,399 --> 01:38:11,833
我們來看看如何自己製作的方法，同時加深理解吧

443
01:38:12,399 --> 01:38:15,699
如果想用作業系統沒有包含的樣式來格式化

444
01:38:15,699 --> 01:38:19,033
可以選擇自己製作 FormatStyle

445
01:38:20,666 --> 01:38:26,500
這是我作為開源軟體開發的工具，可以讓 Xcode 的程式碼智慧功能

446
01:38:26,500 --> 01:38:31,466
也能使用 ChatGPT 或 Claude 以外的模型的工具

447
01:38:31,466 --> 01:38:36,333
其中有一個畫面，讓使用者可以設定任意的連接埠號碼

448
01:38:36,333 --> 01:38:40,833
使用了 SwiftUI 的 TextField

449
01:38:41,866 --> 01:38:47,833
這個連接埠號碼是 NWEndpointPort 這個型別

450
01:38:47,833 --> 01:38:51,833
但用來格式化它與字串的格式樣式

451
01:38:51,833 --> 01:38:54,133
目前在標準函式庫中並不存在

452
01:38:54,133 --> 01:38:56,500
所以我需要自己做一個

453
01:38:58,833 --> 01:39:03,833
那麼首先從符合 FormatStyle 開始吧

454
01:39:03,833 --> 01:39:06,833
接收 NWEndpointPort 型別

455
01:39:06,833 --> 01:39:10,966
實作回傳字串的 format 方法

456
01:39:12,600 --> 01:39:18,966
這個型別取得 rawValue 可以得到 UInt16

457
01:39:18,966 --> 01:39:23,100
再將它作為數值格式化成字串

458
01:39:24,833 --> 01:39:32,166
然後跟標準的格式樣式一樣，提供捷徑，就此順利完成

459
01:39:32,833 --> 01:39:37,133
在 NWEndpointPort 後面加上 .formatted

460
01:39:37,133 --> 01:39:39,199
就可以格式化了

461
01:39:41,300 --> 01:39:46,500
接著我們也來讓它來試著符合 ParseableFormatStyle

462
01:39:47,833 --> 01:39:53,600
要符合這個協定，需要定義對應的 ParseStrategy

463
01:39:53,600 --> 01:39:57,333
在 ParseStrategy 的這個 parse 方法中

464
01:39:57,333 --> 01:40:04,000
撰寫將輸入字串轉換為目標 NWEndpointPort 型別的邏輯

465
01:40:05,866 --> 01:40:10,566
這邊也會寫一個用於存取的捷徑，這樣就完成了

466
01:40:10,833 --> 01:40:16,833
這樣一來，不僅可以進行格式化的正向處理，反向的解析也能輕鬆完成了

467
01:40:19,133 --> 01:40:27,199
今天我們確認了資料格式化在日常開發中是經常進行的作業

468
01:40:27,199 --> 01:40:31,533
並且觀察了進行格式化的手段、API 的演變過程

469
01:40:32,633 --> 01:40:37,800
標準提供的 FormatStyle 有非常多種

470
01:40:37,800 --> 01:40:40,633
而且每一種都具備 Swift 特有的安全性

471
01:40:40,633 --> 01:40:44,399
並能透過現行常見的機制以現代化的方式使用

472
01:40:45,500 --> 01:40:53,866
此外，我們也了解到可以自己建立 FormatStyle ，具備可擴充的彈性

473
01:40:54,666 --> 01:41:00,733
如果您目前參與的專案中，有使用傳統方法進行資料格式化的地方

474
01:41:00,733 --> 01:41:04,566
請務必考慮遷移到使用 FormatStyle

475
01:41:06,833 --> 01:41:13,366
本次演講的製作參考了許多 Apple 的官方文件以及 WWDC 的議程

476
01:41:13,366 --> 01:41:18,933
這些資源對於深入理解 FormatStyle 非常有幫助，在此推薦給大家

477
01:41:20,766 --> 01:41:25,766
那麼，請從今天開始，試著使用 FormatStyle 吧

478
01:41:26,199 --> 01:41:28,199
以上就是全部內容。感謝各位聆聽

479
01:41:38,566 --> 01:41:40,566
(主持) 感謝您的發表

480
01:41:40,833 --> 01:41:43,433
那麼現在進入問答時間

481
01:41:43,433 --> 01:41:47,233
有意見或問題的朋友，請舉手讓我們知道

482
01:41:49,833 --> 01:41:52,000
我們會將麥克風送過去。請拿著麥克風

483
01:41:59,533 --> 01:42:01,166
(Q) 感謝您的分享

484
01:42:01,833 --> 01:42:07,199
根據我過去的經驗，一直以來都在使用 DateFormatter

485
01:42:08,633 --> 01:42:10,633
從單元測試的角度來看

486
01:42:12,199 --> 01:42:17,699
經常需要從外部指定語系 (Locale) 或時區 (Time Zone)，而不是使用當前設定

487
01:42:18,833 --> 01:42:21,833
來使用格式化功能

488
01:42:21,833 --> 01:42:24,833
請問使用 FormatStyle 的情況下，也能做到這樣的事情嗎？

489
01:42:26,133 --> 01:42:28,133
(treastrain) 好的。感謝您的提問

490
01:42:28,566 --> 01:42:33,000
在日期相關的 FormatStyle 的修飾子中

491
01:42:33,000 --> 01:42:34,766
我介紹了各種不同的選項

492
01:42:34,766 --> 01:42:38,233
其中也有指定語系的修飾子存在

493
01:42:38,233 --> 01:42:44,466
所以使用那個修飾子，就可以注入語系設定

494
01:42:44,466 --> 01:42:47,066
如果是測試用的話

495
01:42:47,066 --> 01:42:51,633
可以用能夠注入語系的自訂 FormatStyle

496
01:42:51,633 --> 01:42:52,899
包裝一層

497
01:42:52,899 --> 01:42:59,166
然後對包裝後的版本從測試程式碼端進行注入的設計

498
01:42:59,166 --> 01:43:02,699
從外部來看會比較簡潔

499
01:43:03,166 --> 01:43:05,500
不過如果不在團隊中告知大家正在這樣做的話

500
01:43:05,500 --> 01:43:08,166
可能會產生「這到底是什麼型別」之類的問題

501
01:43:08,166 --> 01:43:11,533
所以在那方面需要找到一個好的平衡點

502
01:43:11,833 --> 01:43:12,833
(Q) 謝謝您

503
01:43:16,066 --> 01:43:17,366
(主持) 感謝您

504
01:43:17,833 --> 01:43:21,833
其他有意見或問題的朋友，請舉手

505
01:43:31,233 --> 01:43:32,233
(Q) 謝謝

506
01:43:34,133 --> 01:43:37,133
這是個純粹出於興趣的問題

507
01:43:37,133 --> 01:43:42,833
我記得有 Double 型別或浮點數的 FormatStyle

508
01:43:42,833 --> 01:43:46,833
這種浮點數常見的情況是

509
01:43:46,833 --> 01:43:51,833
需要考慮捨入精度的問題對吧

510
01:43:51,833 --> 01:43:55,833
例如常見的例子，0.1 加 0.2 不是 0.3 而是 0.30000...

511
01:43:55,833 --> 01:43:57,666
這樣的情況

512
01:43:57,666 --> 01:44:02,166
例如將 0.1 加 0.2 的結果進行格式化

513
01:44:02,166 --> 01:44:08,699
單純用 formatted 輸出的話會變成什麼樣子，我有點好奇

514
01:44:09,533 --> 01:44:11,000
(treastrain) 謝謝您的提問

515
01:44:11,000 --> 01:44:15,333
如果要格式化 Double 相加的結果

516
01:44:15,333 --> 01:44:20,100
會以 0.33333 這樣的字串形式輸出

517
01:44:20,100 --> 01:44:23,633
所以會在包含誤差的狀態下進行格式化

518
01:44:23,633 --> 01:44:28,533
雖然無誤差的計算本來就不可能

519
01:44:28,533 --> 01:44:38,866
但我認為 FormatStyle 的設計理念是，這個問題應該在格式化之前就解決

520
01:44:42,833 --> 01:44:43,833
(主持) 感謝您

521
01:44:44,633 --> 01:44:48,133
其他有意見或問題的朋友請舉手

522
01:44:58,466 --> 01:45:00,233
(Q) 感謝您的發表

523
01:45:01,199 --> 01:45:05,433
我想您提到了幾個關於本地化的部分

524
01:45:05,433 --> 01:45:10,433
一般在業務上進行時，會使用 Localized String 或 String Catalogs

525
01:45:10,433 --> 01:45:15,066
我想在執行的部分與角色上有相當多重疊的地方

526
01:45:15,066 --> 01:45:17,866
請問要如何區分使用

527
01:45:17,866 --> 01:45:21,800
或者是否應該在某種程度上將本地化靠攏到格式樣式

528
01:45:21,800 --> 01:45:25,100
如果您對這方面有什麼想法，我想聽聽看

529
01:45:25,566 --> 01:45:28,100
(treastrain) 好的，謝謝您

530
01:45:28,100 --> 01:45:30,566
我在中途介紹了不是用 VStack 的兩個 Text

531
01:45:30,566 --> 01:45:33,866
而是用一個 Text 的形式

532
01:45:33,866 --> 01:45:40,366
當想要使用本地化鍵 (Localized Key) 的時候

533
01:45:40,366 --> 01:45:44,100
使用那種寫法

534
01:45:44,100 --> 01:45:47,833
我認為這就是 FormatStyle 的使用方式

535
01:45:47,833 --> 01:45:54,699
我覺得用格式樣式講 40 分鐘對我來說還蠻硬核的

536
01:45:54,699 --> 01:45:57,466
不過因為我喜歡 FormatStyle

537
01:45:57,466 --> 01:46:01,366
以我個人的見解來說，在可本地化 (Localizable) 的部分

538
01:46:01,366 --> 01:46:04,966
不包含格式這一側

539
01:46:04,966 --> 01:46:09,766
例如單位的處理或是配合地區的符號顯示

540
01:46:09,766 --> 01:46:12,666
交給格式樣式這一側來處理

541
01:46:12,666 --> 01:46:15,966
不寫在可本地化字串 (Localizable Strings) 裡

542
01:46:15,966 --> 01:46:17,366
我是這樣建議的

543
01:46:17,366 --> 01:46:20,066
平常在個人開發時也是這樣做的

544
01:46:20,500 --> 01:46:22,300
(Q) 謝謝您

545
01:46:23,733 --> 01:46:25,600
(主持) 謝謝

546
01:46:25,600 --> 01:46:28,300
時間上看來下一個會是最後一個問題

547
01:46:28,300 --> 01:46:31,600
有意見或問題的人請舉手

548
01:46:37,833 --> 01:46:40,466
那麼時間到了

549
01:46:40,466 --> 01:46:45,000
問答時間到此結束

550
01:46:45,000 --> 01:46:47,666
接下來是一分鐘回饋時間

