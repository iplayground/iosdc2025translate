1
00:00:00,000 --> 00:00:06,964
差不多該開始了 FormatStyle

2
00:00:08,032 --> 00:00:12,364
好的，那麼接下來我將以「也該是時候用 FormatStyle 了吧」

3
00:00:12,364 --> 00:00:15,364
為題進行發表，請大家多多指教

4
00:00:15,364 --> 00:00:18,565
本次發表由我 Tanaka Ryoga 擔任

5
00:00:18,565 --> 00:00:22,565
平常我是用這個橘色圖示在網路上走跳

6
00:00:22,565 --> 00:00:25,861
跟新款 iPhone 的顏色是一樣的橘色呢

7
00:00:25,861 --> 00:00:28,963
個人開發方面，我使用 Swift 開發應用程式

8
00:00:28,963 --> 00:00:35,362
另外在 DeNA 股份有限公司也擔任 iOS 應用程式開發者

9
00:00:35,362 --> 00:00:38,597
過去在 iOSDC Japan 曾經進行過 3 次演講

10
00:00:38,597 --> 00:00:40,965
都是 40 分鐘的常規演講

11
00:00:40,965 --> 00:00:45,164
這次是第 4 次

12
00:00:45,362 --> 00:00:50,362
我第一次登台演講是在 2021 年

13
00:00:50,362 --> 00:00:51,965
當時的題目是

14
00:00:51,965 --> 00:00:58,164
「輕鬆正確地將各種資訊格式化為字串」

15
00:00:58,164 --> 00:01:00,362
回顧當時的存檔

16
00:01:00,362 --> 00:01:07,563
內容是使用 Formatter 將各種資料轉換為字串

17
00:01:07,563 --> 00:01:13,364
當時的設計就像是那年在日本舉辦的國際體育賽事開幕式的一幕

18
00:01:13,364 --> 00:01:16,563
我是用那樣的設計發表的

19
00:01:16,563 --> 00:01:21,563
其中對於 2021 年當時最新的 iOS 版本

20
00:01:21,563 --> 00:01:26,965
iOS 15 的新功能稍微提到了一些

21
00:01:26,965 --> 00:01:28,563
當時的螢幕截圖是這樣的

22
00:01:28,563 --> 00:01:31,563
坐在後面的朋友可能看不太清楚

23
00:01:31,563 --> 00:01:34,563
在 Apple 關於新功能的文件中

24
00:01:34,563 --> 00:01:36,563
經常會出現「No overview available」

25
00:01:36,563 --> 00:01:39,563
也就是什麼都沒寫的文件

26
00:01:39,563 --> 00:01:41,331
當時就是這樣的狀況

27
00:01:41,331 --> 00:01:46,563
而這就是今天的主題—格式樣式 (FormatStyle)

28
00:01:46,563 --> 00:01:50,563
FormatStyle 是 iOS 15 以後可以使用的功能

29
00:01:50,563 --> 00:01:53,563
在 2021 年剛發布的當時

30
00:01:53,563 --> 00:01:57,563
例如因為最低支援版本 (Minimum Deployment Target) 等關係

31
00:01:57,563 --> 00:02:01,563
要導入實際產品可能有些困難

32
00:02:01,563 --> 00:02:03,563
但從那時起已經過了 4 年

33
00:02:03,563 --> 00:02:08,562
而且前陣子 iOS 26 也發布了

34
00:02:08,562 --> 00:02:11,562
根據 Apple 的資料，許多使用者的裝置

35
00:02:11,562 --> 00:02:14,562
已經支援 FormatStyle

36
00:02:14,562 --> 00:02:17,562
環境已經成熟了

37
00:02:17,562 --> 00:02:19,562
正是探討 FormatStyle

38
00:02:19,562 --> 00:02:24,562
最合適的時機，所以這次我決定進行發表

39
00:02:24,562 --> 00:02:28,562
本次演講的對象是在 Swift 或 iOS 應用程式開發中

40
00:02:28,562 --> 00:02:34,562
準備學習資料格式化處理的朋友

41
00:02:34,562 --> 00:02:37,562
雖然使用過傳統的格式化器 (Formatter)

42
00:02:37,562 --> 00:02:42,562
但對這個新的格式樣式還不太熟悉的朋友

43
00:02:42,562 --> 00:02:44,562
以及標準 library 中沒有提供的

44
00:02:44,562 --> 00:02:47,562
自訂格式樣式的製作範例

45
00:02:47,562 --> 00:02:52,562
想要了解的朋友

46
00:02:52,562 --> 00:02:58,562
接下來，讓我們重新思考一下，什麼是資料格式化處理呢？

47
00:02:58,562 --> 00:03:01,562
這裡有一張螢幕截圖

48
00:03:01,562 --> 00:03:04,562
畫面中央顯示著本次演講的標題

49
00:03:04,562 --> 00:03:09,562
以及開始日期時間

50
00:03:09,562 --> 00:03:13,562
用 SwiftUI 的程式碼表示就是這樣

51
00:03:13,562 --> 00:03:21,562
現在演講開始日期時間的部分是直接在 Text 中寫入字串

52
00:03:21,562 --> 00:03:26,562
讓這個標題和開始日期時間從 View 外部傳入

53
00:03:26,562 --> 00:03:30,562
而且 Swift 有可以處理日期時間的

54
00:03:30,562 --> 00:03:32,562
Date 型別

55
00:03:32,562 --> 00:03:37,562
所以將這個 Date 屬性的型別從現在的 String 型別

56
00:03:37,562 --> 00:03:40,562
改為 Date 型別傳入

57
00:03:40,562 --> 00:03:43,562
但是如果程式碼維持這樣的話

58
00:03:43,562 --> 00:03:45,562
SwiftUI 的 Text 初始化器

59
00:03:45,562 --> 00:03:49,562
無法傳入這個 Date 型別，會發生錯誤

60
00:03:49,562 --> 00:03:54,562
導致無法建置

61
00:03:54,562 --> 00:03:56,562
要解決這個建置錯誤

62
00:03:56,562 --> 00:04:01,562
就型別而言，需要使用某種方法從這個 Date 型別

63
00:04:01,562 --> 00:04:04,562
轉換為 String 型別

64
00:04:04,562 --> 00:04:08,562
抱歉，然後傳給 SwiftUI 的 Text 就可以了

65
00:04:08,562 --> 00:04:10,562
就是這樣

66
00:04:11,132 --> 00:04:15,500
那麼，讓我們來思考一下如何進行這個轉換

67
00:04:17,362 --> 00:04:19,031
Swift 的 Date 型別

68
00:04:19,031 --> 00:04:23,862
有 timeIntervalSinceReferenceDate 這個屬性

69
00:04:23,862 --> 00:04:29,564
這是從世界標準時間 2001 年 1 月 1 日 0 時 0 分開始

70
00:04:29,564 --> 00:04:35,564
有多少秒差異的值

71
00:04:35,564 --> 00:04:38,564
以日本時間今天 13 點來說

72
00:04:38,564 --> 00:04:43,833
會是 7 億 8033 萬 3600 秒這個數字

73
00:04:45,899 --> 00:04:51,564
從這個數字，進一步從年、月、日、時、分

74
00:04:51,833 --> 00:04:56,862
數字要透過四則運算來推算，這樣做比較好嗎？

75
00:04:58,632 --> 00:05:01,833
不過，就算能夠計算出西曆年份

76
00:05:01,833 --> 00:05:06,031
在 iOS 中使用者也可以將其設定為和曆

77
00:05:06,430 --> 00:05:09,031
這種情況下該如何因應才好呢？

78
00:05:11,233 --> 00:05:13,333
此外在英語環境中

79
00:05:13,333 --> 00:05:18,430
月份本來就不是數字而是固定的英文單字

80
00:05:18,632 --> 00:05:22,632
而且可能會偏好使用 12 小時制而非 24 小時制

81
00:05:24,833 --> 00:05:29,632
當有某些資料需要轉換成字串時

82
00:05:30,031 --> 00:05:34,233
考慮使用者的語言、地區、文化等因素

83
00:05:34,233 --> 00:05:39,632
我認為能以對該使用者來說最熟悉的格式來傳達資訊是最理想的

84
00:05:40,430 --> 00:05:43,430
這就稱為資料的格式化 (Format)

85
00:05:45,800 --> 00:05:47,862
對於像是我們這些開發 iOS 應用程式的人

86
00:05:47,862 --> 00:05:54,632
為世界各地多元使用者打造資訊傳遞介面的人來說

87
00:05:54,632 --> 00:06:01,266
將資料格式化處理成適當的形式，是無法迴避且非常重要的課題

88
00:06:01,266 --> 00:06:07,132
在一個應用程式中，可能會在各種地方反覆進行資料格式化處理

89
00:06:08,862 --> 00:06:14,333
另一方面，關於資料格式化處理有無數需要考慮的事項

90
00:06:14,333 --> 00:06:19,800
要讓它在任何時候都能如預期運作是非常困難的

91
00:06:21,531 --> 00:06:24,165
因此，對於常用的資料類型

92
00:06:24,165 --> 00:06:27,362
為了不需要自己撰寫格式化處理

93
00:06:27,362 --> 00:06:34,665
Swift 和 OS 的框架中已經預先準備好資料格式化處理的 API

94
00:06:35,733 --> 00:06:39,500
接下來，讓我們來試試資料格式化處理吧

95
00:06:40,333 --> 00:06:43,165
難得在 iOS 應用程式開發現場

96
00:06:43,165 --> 00:06:47,766
也逐漸能看到編碼智慧 (Coding Intelligence) 的應用案例

97
00:06:47,766 --> 00:06:52,463
這裡就來問問某個大型語言模型 (LLM) 吧

98
00:06:53,362 --> 00:07:00,031
選擇 Xcode 中出現錯誤的地方，按下「Generate Fix for Issue」按鈕

99
00:07:01,031 --> 00:07:05,031
結果，LLM 給出了某種回應

100
00:07:05,300 --> 00:07:10,031
看起來它幫我們修改了程式碼

101
00:07:10,564 --> 00:07:15,031
這裡使用了 DateFormatter

102
00:07:15,031 --> 00:07:19,665
DateFormatter 的父類別 NSFormatter

103
00:07:19,665 --> 00:07:22,031
是在 Swift 出現之前

104
00:07:22,031 --> 00:07:26,766
從 Objective-C 時代就已經存在的資料格式化處理 API

105
00:07:28,930 --> 00:07:34,500
Foundation 中有 13 種繼承 NSFormatter 的格式化器

106
00:07:34,500 --> 00:07:41,031
除了日期時間之外，還支援數值、人名、重量和長度等測量值

107
00:07:41,031 --> 00:07:44,531
對應各種類型的資料格式化處理

108
00:07:45,766 --> 00:07:49,132
從 2016 年 9 月發布的 Swift 3 開始

109
00:07:49,132 --> 00:07:54,399
呼叫時不再需要 NS 前綴，變成了這樣的外觀

110
00:07:54,399 --> 00:07:58,930
LLM 寫的就是使用這個 DateFormatter 的程式碼

111
00:08:00,463 --> 00:08:04,564
這個格式化器是非常強大且靈活的 API

112
00:08:04,564 --> 00:08:10,930
但從 Swift 現代開發典範以及重視安全性的觀點來看

113
00:08:10,930 --> 00:08:14,000
有幾個必須注意的地方

114
00:08:15,899 --> 00:08:20,031
那麼，讓我們繼續以 DateFormatter 為例來說明

115
00:08:20,031 --> 00:08:26,028
這裡準備了去年年底，也就是跨年前的時刻作為 Date 屬性

116
00:08:26,028 --> 00:08:30,028
讓我們來格式化這個資料

117
00:08:30,028 --> 00:08:38,129
建立 DateFormatter 類別的實例，指定日期時間格式化的形式

118
00:08:39,864 --> 00:08:44,032
完成後，使用實例方法 stringFrom

119
00:08:44,032 --> 00:08:47,500
取得格式化為 String 型別的結果

120
00:08:47,500 --> 00:08:53,032
如果熟悉命令式程式設計，我認為這是非常易讀的程式碼

121
00:08:53,431 --> 00:08:59,032
如果格式化結果中不需要時刻的部分

122
00:08:59,032 --> 00:09:05,032
可以在 timeStyle 的部分指定 .none 來進行客製化

123
00:09:05,032 --> 00:09:14,033
那麼，如果只想要年和月的部分，不需要日的話，該怎麼做呢？

124
00:09:14,033 --> 00:09:21,033
DateFormatter 有一個可以更靈活指定格式化形式的 dateFormat 屬性

125
00:09:21,831 --> 00:09:29,331
這次因為只想要年和月，所以使用大寫的 Y 和大寫的 M

126
00:09:29,331 --> 00:09:35,033
然後因為希望在後面也顯示「年」和「月」的漢字，所以加上去

127
00:09:35,033 --> 00:09:39,533
接下來用實例方法 stringFrom 來格式化的話

128
00:09:39,533 --> 00:09:45,666
年份的數字變成了 2025 而不是 2024

129
00:09:45,666 --> 00:09:49,100
這是哪裡出錯了呢？

130
00:09:51,364 --> 00:09:55,230
這個 dateFormat 屬性所接受的字串

131
00:09:55,230 --> 00:09:59,431
必須使用 Unicode 技術標準的規範

132
00:10:01,331 --> 00:10:07,798
必須根據 Unicode 規範中的表格來組建 dateFormat 的字串

133
00:10:07,798 --> 00:10:10,431
那是一個非常龐大的表格

134
00:10:10,431 --> 00:10:14,100
從螢幕上已經看不清楚寫了什麼

135
00:10:14,100 --> 00:10:16,629
剛才 dateFormat 的這個錯誤

136
00:10:16,629 --> 00:10:24,629
是表示年份的 Y 這個字元，應該要用小寫而不是大寫

137
00:10:24,629 --> 00:10:28,331
本來想說這樣就解決了

138
00:10:28,331 --> 00:10:31,033
但之後如果在英語環境中

139
00:10:31,033 --> 00:10:36,431
也要支援像 December 2024 這樣的表記方式

140
00:10:36,431 --> 00:10:38,629
這時候該怎麼辦呢？

141
00:10:38,629 --> 00:10:45,129
目前的狀況是 DateFormatter 中直接包含了年、月等漢字

142
00:10:45,129 --> 00:10:49,100
而且日文是年在前、月在後

143
00:10:49,100 --> 00:10:53,629
但在英文的情況是月在前、年在後，有這樣的差異

144
00:10:54,966 --> 00:10:58,500
像這樣即使只是日期時間的格式

145
00:10:58,500 --> 00:11:00,864
需要考慮的模式就有無數種

146
00:11:00,864 --> 00:11:04,629
而且即使格式字串的指定有錯誤

147
00:11:04,629 --> 00:11:08,166
在執行程式之前也無法知道結果

148
00:11:08,166 --> 00:11:13,000
因此不應該直接在 DateFormatter 中指定字串

149
00:11:15,129 --> 00:11:17,629
在 Apple 的 WWDC 講座中

150
00:11:17,629 --> 00:11:20,864
也明確指出這幾乎必定會產生非預期的結果

151
00:11:20,864 --> 00:11:25,931
清楚說明了不要直接在 dateFormat 中指定字串

152
00:11:27,197 --> 00:11:29,666
因為很重要所以再說一次

153
00:11:29,666 --> 00:11:33,197
在非常舊的資料中可能會說只有這個方法

154
00:11:33,197 --> 00:11:36,600
而介紹直接對 dateFormat 指定的方法

155
00:11:36,600 --> 00:11:41,399
或是程式碼智慧工具的 LLM 可能會建議這個方法

156
00:11:41,399 --> 00:11:43,230
但請不要使用

157
00:11:43,230 --> 00:11:46,600
我想這應該寫在 Agents.md 之類的地方會比較好

158
00:11:49,100 --> 00:11:51,197
話題有點偏離了

159
00:11:51,197 --> 00:11:52,864
讓我們回到最初的程式碼

160
00:11:53,899 --> 00:11:56,062
重新閱讀這段程式碼

161
00:11:56,062 --> 00:12:00,000
在 SwiftUI 的 View Protocol 的 body 中

162
00:12:00,000 --> 00:12:04,629
呼叫了 formattedDate

163
00:12:04,629 --> 00:12:09,629
這個 formattedDate 是 Computed Property，每次被呼叫時

164
00:12:09,629 --> 00:12:12,629
都會建立 DateFormatter 的實例

165
00:12:12,629 --> 00:12:17,864
並指定 dateStyle、timeStyle 來進行格式化

166
00:12:19,364 --> 00:12:25,331
SwiftUI 的 View 的 body 可能會被框架多次呼叫

167
00:12:26,000 --> 00:12:31,230
每次被呼叫時都會重新建立 formatter 的實例

168
00:12:32,230 --> 00:12:37,264
眾所周知，建立 formatter 實例的成本非常高

169
00:12:38,629 --> 00:12:44,629
關於這個高成本的問題，已經有許多人提及

170
00:12:44,629 --> 00:12:48,864
例如我們來看看 Apple 今年 WWDC 的講座

171
00:12:50,166 --> 00:12:55,629
可以從效能不好的 SwiftUI 應用程式中發現有 hitches 或 hangs

172
00:12:55,629 --> 00:12:58,629
透過 Instruments 測量

173
00:12:58,629 --> 00:13:05,533
在剛剛那段程式碼中 View 的 body 中多次建立 formatter 實例的地方

174
00:13:05,533 --> 00:13:07,629
這類的話題

175
00:13:08,629 --> 00:13:14,629
作為對應策略，使用 formatter 來建立格式化字串

176
00:13:14,629 --> 00:13:21,166
將 string(from:) 的呼叫改為在其他地方事先統一執行

177
00:13:21,166 --> 00:13:26,466
或是將 formatter 實例的建立次數降到最低

178
00:13:26,466 --> 00:13:30,399
透過快取的方式，該議程中介紹了這些方法

179
00:13:32,629 --> 00:13:35,966
那麼讓我們總結一下到目前為止的內容

180
00:13:37,298 --> 00:13:42,629
傳統的 formatter 是功能非常強大且可高度客製化的

181
00:13:42,629 --> 00:13:47,629
但在某些模式下，即使客製化有錯誤

182
00:13:47,629 --> 00:13:52,629
在編譯時也無法察覺，必須實際執行才能確認

183
00:13:54,364 --> 00:13:57,629
另外，建立 formatter 實例的成本

184
00:13:57,629 --> 00:14:03,629
以及雖然省略說明，但屬性變更的成本也很高

185
00:14:05,100 --> 00:14:12,899
因此最佳實踐是自行實作快取機制來減少這些操作的次數

186
00:14:14,331 --> 00:14:17,600
另外，Swift 通常使用值型別 (value type)

187
00:14:17,600 --> 00:14:19,966
但是這個 formatter 是參考型別 (reference type)

188
00:14:20,500 --> 00:14:24,629
在共享快取時也需要注意這一點

189
00:14:25,629 --> 00:14:32,629
還有在現今 Swift Concurrency 的時代，是否執行緒安全也需要特別注意

190
00:14:34,000 --> 00:14:40,298
而且它不是 SwiftUI 等流行的宣告式，而是命令式的 API 設計

191
00:14:42,331 --> 00:14:49,629
到目前為止，我並不打算深入探討 formatter 的好壞

192
00:14:49,629 --> 00:14:54,562
只是，利用這些特性和思維方式的現在

193
00:14:54,562 --> 00:15:00,533
作為符合現今 Swift 時代的全新介面而登場的就是 FormatStyle

194
00:15:02,666 --> 00:15:07,798
這個格式樣式，正確來說是一個協定（Protocol）的名稱

195
00:15:07,798 --> 00:15:12,899
可在 iOS 15 及以後使用，用於將特定的資料型別轉換為另一種型別

196
00:15:12,899 --> 00:15:19,831
例如字串（String）型別的介面

197
00:15:20,798 --> 00:15:26,033
系統預設準備了各種用途的格式樣式

198
00:15:26,033 --> 00:15:31,264
截至 iOS 26 為止，共有 46 種格式樣式存在

199
00:15:33,230 --> 00:15:37,166
這是使用傳統 Formatter 撰寫的程式碼

200
00:15:37,166 --> 00:15:42,399
如果改用格式樣式來撰寫的話，會變成這樣

201
00:15:42,966 --> 00:15:46,264
程式碼變得非常精簡了呢

202
00:15:46,966 --> 00:15:49,697
讓我們比較一下兩者的程式碼

203
00:15:49,697 --> 00:15:55,264
過去存在的 DateFormatter 的程式碼整段就消失了

204
00:15:55,264 --> 00:16:05,966
而且過去是將資料傳遞給格式器端存在的方法的參數

205
00:16:05,966 --> 00:16:13,197
但使用 FormatStyle 的方法則是改為對資料加上 formatted 這個方法

206
00:16:15,100 --> 00:16:19,364
不需要自己建立對應資料的格式器實例

207
00:16:19,364 --> 00:16:23,562
只需簡單地對資料加上 formatted

208
00:16:23,562 --> 00:16:26,000
就能輕鬆進行格式化

209
00:16:27,298 --> 00:16:32,466
也可以在這個 formatted 方法中指定詳細的樣式

210
00:16:32,466 --> 00:16:36,831
如果不指定的話，就會使用預設的實作

211
00:16:38,166 --> 00:16:40,562
關於彈性的樣式指定

212
00:16:40,562 --> 00:16:45,966
也不需要記住剛才提到的羅馬字小寫 Y 會怎樣、大寫 M 會怎樣之類

213
00:16:45,966 --> 00:16:49,764
複雜的字串樣式規則

214
00:16:49,764 --> 00:16:54,033
想要年份就加上 year，想要月份就加上 month

215
00:16:54,033 --> 00:16:58,696
可以一邊使用程式碼補全功能一邊安全地撰寫

216
00:16:58,696 --> 00:17:02,864
而且之後閱讀時的可讀性也非常高

217
00:17:04,962 --> 00:17:08,730
FormatStyle 是為 Swift 而設計的

218
00:17:08,730 --> 00:17:12,798
外部介面的部分是 100% 用 Swift 撰寫的

219
00:17:14,064 --> 00:17:18,265
而且相對於格式器是類別（Class）、參考型別

220
00:17:18,265 --> 00:17:23,596
FormatStyle 是用結構（Struct）、值型別 (Value Type) 來建立

221
00:17:23,596 --> 00:17:26,096
具有容易受到堆疊上的配置、寫入時複製（Copy-on-Write）

222
00:17:26,096 --> 00:17:30,298
編譯器最佳化等好處的優點

223
00:17:31,462 --> 00:17:35,230
樣式的指定可以以 type-safe 的方式進行

224
00:17:35,230 --> 00:17:42,364
FormatStyle 內部使用的格式器實例會由框架端自動快取

225
00:17:42,364 --> 00:17:48,462
從剛才必須考慮手動快取之類的事情中解放出來

226
00:17:48,462 --> 00:17:53,163
在效能上的優點似乎也能在一定程度上享受到

227
00:17:53,163 --> 00:17:56,832
還有，搭配流行的宣告式介面

228
00:17:56,832 --> 00:18:02,431
對現代的人們來說變得更容易使用，就是這個 FormatStyle

229
00:18:03,500 --> 00:18:10,265
了解了傳統的 Formatter 與 FormatStyle 在介面等方面的差異之後

230
00:18:10,265 --> 00:18:15,663
接下來要介紹協定中定義的格式樣式規則

231
00:18:17,029 --> 00:18:20,765
符合格式樣式協定的型別

232
00:18:20,765 --> 00:18:23,265
作為主要關聯型別（Primary Associated Type）的形式

233
00:18:23,265 --> 00:18:32,631
必須指定格式的輸入端型別與輸出端型別分別是什麼

234
00:18:33,462 --> 00:18:41,000
然後需要實作使用實際用來輸入的值進行格式化並輸出結果的方法

235
00:18:42,462 --> 00:18:49,500
在今天一開始展示的，從 Date 型別到 String 型別的格式化的情況下

236
00:18:49,500 --> 00:18:58,230
FormatInput 會是 Date 型別，FormatOutput 則會是 String 型別

237
00:19:00,163 --> 00:19:10,230
接下來，我想列舉 iOS 26 之前包含的所有可立即使用的格式樣式種類

238
00:19:10,230 --> 00:19:17,198
不過，到目前為止我們都在討論日期時間的格式化

239
00:19:17,198 --> 00:19:22,198
現在的 iOS 也存在對應其他資料的格式樣式

240
00:19:22,198 --> 00:19:26,663
不過，要一次記住這些全部是有難度的

241
00:19:26,663 --> 00:19:30,298
而且從這裡開始不斷列舉的話可能會讓人想睡覺

242
00:19:30,298 --> 00:19:36,631
如果方便的話，希望大家可以在之後公開的資料或是封存影片中回來複習

243
00:19:38,395 --> 00:19:42,596
那麼首先，讓我們來看看日期與時間

244
00:19:42,596 --> 00:19:50,529
Date.FormatStyle 是進行日期與時刻格式化的最基本樣式

245
00:19:50,529 --> 00:19:56,131
Date 型別的屬性加上 formatted 後，就會使用這個格式樣式

246
00:19:56,131 --> 00:20:04,832
可以透過 date 參數和 time 參數來更進一步地指定樣式，來達到各種不同的表現方式

247
00:20:04,832 --> 00:20:14,029
此外，使用方法鏈可以詳細設定年、月、日、時、分、秒，以及時區等資訊

248
00:20:14,029 --> 00:20:18,265
欄位的順序不會影響最終的輸出結果

249
00:20:18,265 --> 00:20:22,864
作業系統會根據地區設定 (locale) 適當地進行配置

250
00:20:22,864 --> 00:20:31,064
像是，上面的例子是按照美式英語的月、日、年順序來指定的

251
00:20:31,064 --> 00:20:36,895
但在日本的日語環境下執行時，就會正確地顯示為年、月、日

252
00:20:36,895 --> 00:20:40,798
另外，還可以進行月份或星期的縮寫顯示

253
00:20:40,798 --> 00:20:46,431
以及當數字為一位數時用零填補 (padding) 等處理

254
00:20:48,230 --> 00:20:54,029
接下來， 有一個叫做 Date.ISO8601FormatStyle 的東西

255
00:20:54,029 --> 00:20:58,631
在 formatted 地方寫上 .iso8601

256
00:20:58,631 --> 00:21:01,000
這在與伺服器進行資料通訊等情況下

257
00:21:01,000 --> 00:21:07,698
有 ISO 8601 這個規範，當需要該日期時間格式時，可以非常方便地使用

258
00:21:10,198 --> 00:21:14,832
可以加上時區資訊，或者像剛才的 date format 一樣

259
00:21:14,832 --> 00:21:21,000
用方法鏈寫出想要的元素，細緻地指定要輸出的元素

260
00:21:22,096 --> 00:21:30,832
在 iOS 26 中，DateComponents 也準備了 ISO 8601 格式的樣式

261
00:21:32,798 --> 00:21:42,064
這也是新導入的功能，還有符合 HTTP 的 RFC 9110 規範的格式樣式

262
00:21:42,564 --> 00:21:50,895
在網頁通訊中處理日期時間標頭 (header) 等時，我認為會變得格外容易

263
00:21:52,163 --> 00:21:56,230
這個同樣也有 DateComponents 版本

264
00:21:57,798 --> 00:22:04,962
如果想要更進一步自訂輸出格式，可以使用 Date.VerbatimFormatStyle

265
00:22:05,765 --> 00:22:10,564
就像前面提到的傳統 DateFormatter 的 dateFormat 屬性一樣

266
00:22:10,564 --> 00:22:15,000
這是一個可以用字串直接指定自訂格式的樣式

267
00:22:15,000 --> 00:22:20,864
不過，透過這個 Date.FormatString 所提供的字串插值 (string interpolation)

268
00:22:20,864 --> 00:22:26,798
藉由字串補完項群，可以以 type-safe 的方式進行格式化

269
00:22:26,798 --> 00:22:37,698
例如，像這裡這樣，有一種需要用年號和年、月、日用句點連接的和曆格式

270
00:22:37,698 --> 00:22:42,895
如果在格式化時與地區設定和時區一起指定的話

271
00:22:42,895 --> 00:22:47,029
無論 iOS 裝置的日曆是西曆還是和曆

272
00:22:47,029 --> 00:22:56,631
都能確實地得到像這個例子 R07.09.20 這樣符合和曆規格的輸出

273
00:22:58,895 --> 00:23:02,765
接下來，這個 Date.IntervalFormatStyle

274
00:23:02,765 --> 00:23:07,064
是用來格式化兩個日期之間期間的樣式

275
00:23:07,064 --> 00:23:11,364
它接收日期的範圍型別作為輸入

276
00:23:11,364 --> 00:23:15,564
以符合使用者地區設定的自然形式來格式化期間

277
00:23:15,895 --> 00:23:21,631
例如，省略時刻只輸出日期期間時

278
00:23:21,631 --> 00:23:29,298
在日本的日語環境下會輸出「19日〜21日」用波浪線、波浪破折號

279
00:23:29,298 --> 00:23:37,529
在美式英語環境下則會輸出「September 19 – 21」這樣的形式

280
00:23:38,564 --> 00:23:46,364
還有 Date.ComponentsFormatStyle，這個會格式化日期元件之間的差異

281
00:23:46,564 --> 00:23:54,931
將兩個日期之間的差異以「2 天」或「2 天 2 小時」等人類易讀的形式顯示

282
00:23:55,431 --> 00:24:00,163
這個也可以透過 style 參數來自訂輸出樣式

283
00:24:02,564 --> 00:24:08,029
類似的還有 Date.RelativeFormatStyle

284
00:24:08,029 --> 00:24:16,000
這是用來格式化以現在時刻為基準的相對日期時間的樣式

285
00:24:16,000 --> 00:24:18,230
使用 named 樣式的話

286
00:24:18,230 --> 00:24:23,564
就可以得到「上個月」、「這個月」、「下個月」等自然語言的表達

287
00:24:23,564 --> 00:24:29,895
改用 numeric 樣式的話，可以進行「1 個月後」這樣的數值相對表達

288
00:24:31,000 --> 00:24:34,096
也能進行非單位的相對表達

289
00:24:34,096 --> 00:24:38,298
像是「前天」、「昨天」、「今天」、「明天」、「後天」這樣的表達

290
00:24:38,298 --> 00:24:42,163
會根據地區設定自動套用

291
00:24:42,163 --> 00:24:49,798
這個格式樣式會以現在時刻為基準輸出相對的內容

292
00:24:50,395 --> 00:24:54,564
如果想要指定任意時刻為基準的話

293
00:24:54,564 --> 00:24:58,962
就使用這個 Date.AnchoredRelativeFormatStyle

294
00:24:58,962 --> 00:25:02,298
將特定的日期時間指定為錨點

295
00:25:02,298 --> 00:25:09,395
然後以該基準對輸入的日期時間進行相對格式化

296
00:25:13,395 --> 00:25:16,596
關於日期時間的格式化已經講了很多

297
00:25:16,596 --> 00:25:22,431
但我想數值的格式化也是同樣常用的功能

298
00:25:22,431 --> 00:25:29,663
整數、浮點數、Decimal 型別都各自有對應的 FormatStyle

299
00:25:29,663 --> 00:25:35,596
預設會根據裝置的地區、進行三位數分隔等顯示

300
00:25:35,596 --> 00:25:41,631
在日本的日語環境下，就是每三位數會出現逗號的感覺

301
00:25:41,631 --> 00:25:51,864
此外使用 rounded 的話，可以指定四捨五入、無條件捨去、無條件進位等數字的進位規則

302
00:25:51,864 --> 00:25:56,000
還可以指定有效位數、使用指數表示法等

303
00:25:56,000 --> 00:26:00,131
有很多修飾詞可以用來自訂

304
00:26:02,029 --> 00:26:09,500
各個數值型別也都準備了以百分率、百分比形式格式化的樣式

305
00:26:09,500 --> 00:26:15,698
數值會自動乘 100 倍，並根據地區設定加上百分比符號

306
00:26:15,698 --> 00:26:23,663
百分比符號要放在哪裡、百分比符號本身是什麼，這些都會因地區設定而不同

307
00:26:23,663 --> 00:26:26,000
這個部分也會自動幫我們調整

308
00:26:28,000 --> 00:26:32,265
同樣地也有格式化貨幣的樣式

309
00:26:32,265 --> 00:26:40,198
透過指定貨幣代碼，可以支援根據地區設定的貨幣符號以及小數點以下的位數

310
00:26:40,798 --> 00:26:44,364
即使在同一個國家或地區，如果語言不同

311
00:26:44,364 --> 00:26:49,198
貨幣符號顯示的位置也會改變，這點也有支援

312
00:26:52,131 --> 00:26:59,364
接下來介紹 iOS 16 導入的 Duration 型別所使用的 FormatStyle

313
00:27:01,000 --> 00:27:03,931
有一個叫做 Duration.TimeFormatStyle 的樣式

314
00:27:03,931 --> 00:27:10,529
它會將 Duration 的值以時、分、秒的形式格式化

315
00:27:11,596 --> 00:27:17,698
有一個叫做 pattern 的參數，在這裡指定 hourMinute 或 hourMinuteSecond 等

316
00:27:17,698 --> 00:27:22,564
就可以細緻地控制時、分、秒的顯示格式

317
00:27:23,298 --> 00:27:29,663
使用 padHourToLength 等方法，也可以對齊位數

318
00:27:31,364 --> 00:27:34,631
還有一個叫做 UnitsFormatStyle 的樣式

319
00:27:34,631 --> 00:27:40,029
它會自動使用最適合的單位來格式化 Duration 的值

320
00:27:40,029 --> 00:27:46,663
可以從這邊指定要使用的單位，也可以用零來填補位數

321
00:27:48,962 --> 00:27:53,000
接下來是關於測量值的 FormatStyle

322
00:27:54,131 --> 00:27:57,462
大家知道 Swift 中的測量值嗎？

323
00:27:57,462 --> 00:28:03,500
Swift 的 Foundation 中有一個可以表示各種值的單位，叫做 Measurement

324
00:28:05,198 --> 00:28:08,864
例如當有表示面積的資料時

325
00:28:08,864 --> 00:28:15,265
可能首先會想到簡單地使用 Int 型別或 Double 型別

326
00:28:15,596 --> 00:28:19,029
但如果使用 UnitArea 的 Measurement 型別

327
00:28:19,029 --> 00:28:24,500
就可以透過型別系統明確地表示這個資料是面積

328
00:28:25,395 --> 00:28:29,765
同時也可以持有該資料的單位

329
00:28:29,765 --> 00:28:36,431
這裡用平方公里表示東北三個縣的面積

330
00:28:36,431 --> 00:28:41,395
所以後面寫著 squareKilometers

331
00:28:41,698 --> 00:28:47,730
對這些加上 formatted 後，就會一起輸出資料的數值和單位

332
00:28:47,730 --> 00:28:52,798
可以將單位的輸出樣式從這個「平方公里」

333
00:28:52,798 --> 00:28:56,462
轉換成漢字和片假名的形式

334
00:28:56,462 --> 00:29:00,298
如果針對美式英語格式化的話

335
00:29:00,298 --> 00:29:04,000
平方公里就會轉換成平方英里輸出

336
00:29:06,663 --> 00:29:14,163
也準備了適合表示記憶體或檔案大小的 FormatStyle

337
00:29:14,832 --> 00:29:21,962
會自動轉換成 KB、MB、GB 等最適合的單位並輸出

338
00:29:21,962 --> 00:29:27,000
這個也可以用 style 參數和 unit 參數來控制顯示格式和單位

339
00:29:29,631 --> 00:29:34,596
接下來也有用來格式化人名的 FormatStyle

340
00:29:34,596 --> 00:29:41,265
有一個關於人名的型別叫做 PersonNameComponents

341
00:29:41,265 --> 00:29:45,131
可以從這裡格式化人名

342
00:29:45,131 --> 00:29:51,765
用 style 參數可以選擇 short、medium、long 等顯示格式

343
00:29:51,765 --> 00:29:55,832
會根據地區設定自動套用姓名的順序

344
00:29:58,230 --> 00:30:04,332
像這樣用羅馬拼音指定姓名、暱稱的話

345
00:30:04,332 --> 00:30:12,131
在縮寫形式中會產生縮寫字母，在日本地區設定中會是姓名的順序

346
00:30:12,131 --> 00:30:17,895
但在英語地區設定中則會以名、姓的順序顯示縮寫字母，有這樣的差異

347
00:30:21,529 --> 00:30:23,931
馬上就要介紹完全部了

348
00:30:23,931 --> 00:30:28,631
關於 URL 的格式樣式也有預設存在

349
00:30:28,631 --> 00:30:35,832
可以將 URL 的 host、path、qury等特定元件進行格式化

350
00:30:35,832 --> 00:30:40,798
例如像這樣只取出 query 的部分

351
00:30:40,798 --> 00:30:47,131
或是像瀏覽器應用程式那樣，只想向使用者顯示 URL 的網域部分時

352
00:30:47,131 --> 00:30:48,500
應該會很有用

353
00:30:51,832 --> 00:30:56,198
最後要介紹其他一些比較特殊的格式樣式

354
00:30:57,765 --> 00:31:04,962
有準備將陣列等序列的元素連結起來，格式化為一個字串的樣式

355
00:31:04,962 --> 00:31:10,131
這個樣式會根據地區設定，自動套用逗號或頓號等

356
00:31:10,131 --> 00:31:17,364
適當的分隔符號，以及連接詞

357
00:31:18,131 --> 00:31:25,131
例如在日文中會變成「蘋果、頓號、香蕉、頓號、橘子」這樣

358
00:31:25,131 --> 00:31:30,131
在英文中則會是「apple、逗號、banana、逗號、and、orange」這樣

359
00:31:30,131 --> 00:31:33,364
變成人類閱讀時非常自然的樣式

360
00:31:35,131 --> 00:31:39,131
這個列表格式樣式的成員樣式 (member style) 參數

361
00:31:39,131 --> 00:31:42,131
也可以傳入其他的格式樣式

362
00:31:42,131 --> 00:31:49,332
對列表的各個元素個別進行格式化，最終連結成的字串

363
00:31:49,332 --> 00:31:51,730
也可以用這個列表格式樣式來處理

364
00:31:53,131 --> 00:31:57,131
先將數字格式化，最後再將它格式化為一個字串

365
00:31:57,131 --> 00:32:00,864
這就是這個範例的做法

366
00:32:02,131 --> 00:32:05,131
這個我們幾乎不會直接使用

367
00:32:05,131 --> 00:32:09,131
但也有將字串格式化為字串的方式

368
00:32:09,131 --> 00:32:12,698
是一種輸入和輸出不變的樣式

369
00:32:12,698 --> 00:32:17,529
例如在泛型的情境中（譯按：或型別推斷），一定需要格式樣式的時候

370
00:32:17,529 --> 00:32:21,832
作為預設的替代文字 (placeholder) 使用的，就是這個字串樣式

371
00:32:24,064 --> 00:32:25,265
就是這樣

372
00:32:27,596 --> 00:32:33,500
StoreKit 框架中也有 FormatStyle 存在

373
00:32:33,500 --> 00:32:43,131
這裡準備了用來將訂閱期間以日、月、年為單位進行格式化的樣式

374
00:32:43,131 --> 00:32:47,462
例如在 App Store Connect 中指定的訂閱期間

375
00:32:47,462 --> 00:32:50,730
就可以在應用程式內適當地進行本地化

376
00:32:54,131 --> 00:32:55,131
非常辛苦了

377
00:32:55,131 --> 00:33:01,131
以上就是 iOS 26 之前搭載的所有基本格式樣式

378
00:33:01,529 --> 00:33:03,864
希望將來在各位平常的開發中

379
00:33:03,864 --> 00:33:08,529
我會很開心如果這些能成為大家想起「或許有那個格式樣式」的契機

380
00:33:10,895 --> 00:33:15,864
那麼接下來想稍微回到格式樣式外部介面的話題

381
00:33:17,131 --> 00:33:20,663
在剛才提到的格式樣式中

382
00:33:20,663 --> 00:33:26,096
有可以輕鬆對輸出的字串進行裝飾的類型的 FormatStyle

383
00:33:27,895 --> 00:33:34,500
這個格式的輸出型別是可以加上屬性的字串，也就是 AttributedString

384
00:33:36,631 --> 00:33:41,131
那麼來看看它是如何運作的

385
00:33:41,364 --> 00:33:45,962
用 FormatStyle 改寫後最初螢幕截圖是這個

386
00:33:47,131 --> 00:33:51,029
我取出了這裡格式化日期時間的部分

387
00:33:52,596 --> 00:33:56,298
如果是支援屬性 (attribute) 的格式樣式

388
00:33:56,298 --> 00:34:02,130
可以像這樣在 FormatStyle 的最後，加上 attributed 或 attributedStyle

389
00:34:02,130 --> 00:34:05,130
兩者都可以

390
00:34:05,130 --> 00:34:11,130
例如像這樣只對年份的部分指定前景色為紅色

391
00:34:11,130 --> 00:34:12,864
就會反映在視圖 (view) 上

392
00:34:15,130 --> 00:34:17,130
其他常見的例子

393
00:34:17,130 --> 00:34:24,465
例如格式化貨幣時，只想讓貨幣符號的部分字體大小比數字小

394
00:34:24,465 --> 00:34:26,898
這樣的需求有時會出現

395
00:34:26,898 --> 00:34:31,130
這也可以用有 attributed 的 FormatStyle 來達成

396
00:34:31,130 --> 00:34:36,000
這是日圓符號的部分比數字稍微小一點的呈現

397
00:34:40,931 --> 00:34:43,130
因為時間關係省略說明

398
00:34:43,130 --> 00:34:46,733
從 iOS 18 開始的 SwiftUI 碼表

399
00:34:46,733 --> 00:34:52,166
也有專門用於計時器等顯示的帶屬性格式樣式存在

400
00:34:53,898 --> 00:34:56,364
那麼，既然提到了 SwiftUI 的話題

401
00:34:56,364 --> 00:35:01,532
我們也來稍微看一下從 SwiftUI 使用 FormatStyle 的方法

402
00:35:03,063 --> 00:35:11,197
在這場演講的開頭，我說明了 SwiftUI 的 Text 初始化器無法傳入 Date 型別

403
00:35:12,063 --> 00:35:18,532
所以我提到可以使用 formatted 方法轉換成 String 型別來解決這個問題

404
00:35:18,532 --> 00:35:23,898
但實際上，Text 還有另一個可以接收 Date 型別的初始化器存在

405
00:35:24,831 --> 00:35:26,500
就是這個形式

406
00:35:26,831 --> 00:35:30,931
在 Text 的第一個參數放入某種資料

407
00:35:30,931 --> 00:35:35,532
在第二個參數的 format 部分傳入 FormatStyle

408
00:35:35,532 --> 00:35:38,431
就可以作為 SwiftUI 的 Text 來處理

409
00:35:39,500 --> 00:35:42,166
我認為這是最佳的方法

410
00:35:42,166 --> 00:35:47,099
特別是在建構運作限制嚴格的 Widget、Live Activity

411
00:35:47,099 --> 00:35:52,831
或是 Complication 這類功能時，更應該使用這個方法

412
00:35:53,666 --> 00:35:56,398
雖然在這個範例程式碼中不太明顯

413
00:35:56,398 --> 00:35:57,697
但根據資料型別的不同

414
00:35:57,697 --> 00:36:02,563
還存在效能更好的 DiscreteFormatStyle

415
00:36:02,563 --> 00:36:05,063
也有可能受惠於此

416
00:36:05,331 --> 00:36:08,965
如果可以的話，很希望能在 Ask the Speaker 等場合聊聊天

417
00:36:10,233 --> 00:36:14,532
另外，這裡雖然使用了 VStack

418
00:36:14,532 --> 00:36:19,264
但如果想要將它作為一個 Text 來處理的話

419
00:36:19,264 --> 00:36:26,264
也可以使用 String Interpolation 中帶有 format 參數的寫法

420
00:36:28,831 --> 00:36:33,831
到目前為止，我們都是使用 SwiftUI 的 Text 來展示

421
00:36:33,831 --> 00:36:36,831
從這邊向使用者顯示內容的格式範例

422
00:36:36,831 --> 00:36:40,233
但這個格式也可以用在 TextField 上

423
00:36:41,831 --> 00:36:46,831
我們一直在看如何將某種資料格式化為字串

424
00:36:46,831 --> 00:36:49,831
但反過來，從使用者接收字串

425
00:36:49,831 --> 00:36:54,831
再用某種方法解析並轉換成這邊的資料型別

426
00:36:54,831 --> 00:36:56,831
也就是 Parse 的處理

427
00:36:56,831 --> 00:36:59,364
有時候會需要這樣的處理

428
00:37:04,300 --> 00:37:09,831
這時就有 ParseableFormatStyle 存在

429
00:37:10,630 --> 00:37:14,831
這個 ParseableFormatStyle 的 Parse 處理

430
00:37:14,831 --> 00:37:18,831
是在 ParseStrategy 這邊定義的

431
00:37:18,831 --> 00:37:26,431
這裡有 ParseInput 和 ParseOutput 這兩個型別，請注意看

432
00:37:26,431 --> 00:37:29,599
這個 ParseInput 和 ParseOutput

433
00:37:29,599 --> 00:37:36,532
被定義為與原本 FormatStyle 的 Input 和 Output 分別是對應的

434
00:37:36,532 --> 00:37:40,697
藉此表現出資料的格式化 (Format) 與解析 (Parse)

435
00:37:40,697 --> 00:37:44,500
分別是相反方向的關係

436
00:37:44,500 --> 00:37:47,264
我超喜歡這種表現方式

437
00:37:48,331 --> 00:37:51,965
以日期時間、數值或 URL 這類

438
00:37:51,965 --> 00:37:55,099
規則明確的 FormatStyle 為核心

439
00:37:55,099 --> 00:37:58,831
它們也都符合 ParseableFormatStyle

440
00:37:58,831 --> 00:38:03,831
連人名也可以 Parse，真是令人驚訝呢

441
00:38:05,032 --> 00:38:07,398
那麼關於這個 ParseableFormatStyle

442
00:38:07,398 --> 00:38:11,831
我們來看看如何自己製作的方法，來加深理解吧

443
00:38:12,398 --> 00:38:15,697
如果想用作業系統沒有包含的樣式來格式化

444
00:38:15,697 --> 00:38:19,032
可以選擇自己製作 FormatStyle

445
00:38:20,666 --> 00:38:26,500
這是我作為開源軟體開發的工具，可以讓 Xcode 的程式碼智慧功能

446
00:38:26,500 --> 00:38:31,465
也能使用 ChatGPT 或 Claude 以外的模型的工具

447
00:38:31,465 --> 00:38:36,331
其中有一個畫面，讓使用者可以設定任意的連接埠號碼

448
00:38:36,331 --> 00:38:40,831
使用了 SwiftUI 的 TextField

449
00:38:41,864 --> 00:38:47,831
這個連接埠號碼是 NWEndpointPort 這個型別

450
00:38:47,831 --> 00:38:51,831
但用來格式化它與字串的格式樣式

451
00:38:51,831 --> 00:38:54,130
目前在標準 library 中並不存在

452
00:38:54,130 --> 00:38:56,500
所以我需要自己做一個

453
00:38:58,831 --> 00:39:03,831
那麼首先從符合 FormatStyle 開始吧

454
00:39:03,831 --> 00:39:06,831
接收 NWEndpointPort 型別

455
00:39:06,831 --> 00:39:10,965
實作回傳字串的 format 方法

456
00:39:12,599 --> 00:39:18,965
這個型別取得 rawValue 可以得到 UInt16

457
00:39:18,965 --> 00:39:23,099
再將它作為數值格式化成字串

458
00:39:24,831 --> 00:39:32,166
然後跟標準的格式樣式一樣，提供捷徑，就此順利完成

459
00:39:32,831 --> 00:39:37,130
在 NWEndpointPort 後面加上 .formatted

460
00:39:37,130 --> 00:39:39,197
就可以格式化了

461
00:39:41,300 --> 00:39:46,500
接著我們也來讓它來試著符合 ParseableFormatStyle

462
00:39:47,831 --> 00:39:53,599
要符合這個協定，需要定義對應的 ParseStrategy

463
00:39:53,599 --> 00:39:57,331
在 ParseStrategy 的這個 parse 方法中

464
00:39:57,331 --> 00:40:04,000
撰寫將輸入字串轉換為目標 NWEndpointPort 型別的邏輯

465
00:40:05,864 --> 00:40:10,563
這邊也會寫一個用於存取的捷徑，這樣就完成了

466
00:40:10,831 --> 00:40:16,831
這樣一來，不僅可以進行格式化的正向處理，反向的解析也能輕鬆完成了

467
00:40:19,130 --> 00:40:27,197
今天我們確認了資料格式化處理在日常開發中是經常進行的作業

468
00:40:27,197 --> 00:40:31,532
並且觀察了進行格式化的手段、API 的演變過程

469
00:40:32,630 --> 00:40:37,800
標準提供的 FormatStyle 有非常多種

470
00:40:37,800 --> 00:40:40,630
而且每一種都具備 Swift 特有的安全性

471
00:40:40,630 --> 00:40:44,398
並能透過現行常見的機制以現代化的方式使用

472
00:40:45,500 --> 00:40:53,864
另外，我們也了解到可以自己建立 FormatStyle ，具備可擴充的彈性

473
00:40:54,666 --> 00:41:00,733
如果您目前參與的專案中，有使用傳統方法進行資料格式化處理的地方

474
00:41:00,733 --> 00:41:04,563
請務必考慮遷移到使用 FormatStyle

475
00:41:06,831 --> 00:41:13,364
本次演講的製作參考了許多 Apple 的官方文件以及 WWDC 的議程

476
00:41:13,364 --> 00:41:18,931
這些資源對於深入理解 FormatStyle 非常有幫助，在此推薦給大家

477
00:41:20,764 --> 00:41:25,764
那麼，請從今天開始，試著使用 FormatStyle 吧

478
00:41:26,197 --> 00:41:28,197
以上就是全部內容。感謝各位聆聽

479
00:41:38,563 --> 00:41:40,563
(主持) 感謝您的發表

480
00:41:40,831 --> 00:41:43,431
那麼現在進入問答時間

481
00:41:43,431 --> 00:41:47,233
有意見或問題的朋友，請舉手讓我們知道

482
00:41:49,831 --> 00:41:52,000
我們會將麥克風拿過去

483
00:41:59,532 --> 00:42:01,166
(Q) 感謝您的分享

484
00:42:01,831 --> 00:42:07,197
根據我過去的經驗，一直以來都在使用 DateFormatter

485
00:42:08,630 --> 00:42:10,630
從單元測試的角度來看

486
00:42:12,197 --> 00:42:17,697
經常需要從外部指定語系 (Locale) 或時區 (Time Zone)，而不是使用當前設定

487
00:42:18,831 --> 00:42:21,831
來使用格式化功能

488
00:42:21,831 --> 00:42:24,831
請問使用 FormatStyle 的情況下，也能做到這樣的事情嗎？

489
00:42:26,130 --> 00:42:28,130
(treastrain) 好的。感謝您的提問

490
00:42:28,563 --> 00:42:33,000
在日期相關的 FormatStyle 的修飾子中

491
00:42:33,000 --> 00:42:34,764
我介紹了各種不同的選項

492
00:42:34,764 --> 00:42:38,233
其中也有指定語系的修飾子存在

493
00:42:38,233 --> 00:42:44,465
所以使用那個修飾子，就可以注入語系設定

494
00:42:44,465 --> 00:42:47,063
如果是測試用的話

495
00:42:47,063 --> 00:42:51,630
可以用能夠注入語系的自訂 FormatStyle

496
00:42:51,630 --> 00:42:52,898
包裝一層

497
00:42:52,898 --> 00:42:59,166
然後對包裝後的版本從測試程式碼端進行注入的設計

498
00:42:59,166 --> 00:43:02,697
從外部來看會比較簡潔

499
00:43:03,166 --> 00:43:05,500
不過如果不在團隊中告知大家正在這樣做的話

500
00:43:05,500 --> 00:43:08,166
可能會產生「這到底是什麼型別」之類的問題

501
00:43:08,166 --> 00:43:11,532
所以在那方面需要找到一個好的平衡點

502
00:43:11,831 --> 00:43:12,831
(Q) 謝謝您

503
00:43:16,063 --> 00:43:17,364
(主持) 感謝您

504
00:43:17,831 --> 00:43:21,831
其他有意見或問題的朋友，請舉手

505
00:43:31,233 --> 00:43:32,233
(Q) 謝謝

506
00:43:34,130 --> 00:43:37,130
這是個純粹出於興趣的問題

507
00:43:37,130 --> 00:43:42,831
我記得有 Double 型別或浮點數的 FormatStyle

508
00:43:42,831 --> 00:43:46,831
這種浮點數常見的情況是

509
00:43:46,831 --> 00:43:51,831
需要考慮捨入精度的問題對吧

510
00:43:51,831 --> 00:43:55,831
例如常見的例子，0.1 加 0.2 不是 0.3 而是 0.30000...

511
00:43:55,831 --> 00:43:57,666
這樣的情況

512
00:43:57,666 --> 00:44:02,166
例如將 0.1 加 0.2 的結果進行格式化

513
00:44:02,166 --> 00:44:08,697
單純用 formatted 輸出的話會變成什麼樣子，我有點好奇

514
00:44:09,532 --> 00:44:11,000
(treastrain) 謝謝您的提問

515
00:44:11,000 --> 00:44:15,331
如果要格式化 Double 相加的結果

516
00:44:15,331 --> 00:44:20,099
會以 0.33333 這樣的字串形式輸出

517
00:44:20,099 --> 00:44:23,630
所以會在包含誤差的狀態下進行格式化

518
00:44:23,630 --> 00:44:28,532
雖然無誤差的計算本來就不可能

519
00:44:28,532 --> 00:44:38,864
但我認為 FormatStyle 的設計理念是，這個問題應該在格式化之前就解決

520
00:44:42,831 --> 00:44:43,831
(主持) 感謝您

521
00:44:44,630 --> 00:44:48,130
其他有意見或問題的朋友請舉手

522
00:44:58,465 --> 00:45:00,233
(Q) 感謝您的發表

523
00:45:01,197 --> 00:45:05,431
我想您提到了幾個關於本地化的部分

524
00:45:05,431 --> 00:45:10,431
一般在業務上進行時，會使用 Localized String 或 String Catalogs

525
00:45:10,431 --> 00:45:15,063
我想在執行的部分與角色上有相當多重疊的地方

526
00:45:15,063 --> 00:45:17,864
請問要如何區分使用

527
00:45:17,864 --> 00:45:21,800
或者是否應該在某種程度上將本地化靠攏到格式樣式

528
00:45:21,800 --> 00:45:25,099
如果您對這方面有什麼想法，我想聽聽看

529
00:45:25,563 --> 00:45:28,099
(treastrain) 好的，謝謝您

530
00:45:28,099 --> 00:45:30,563
我在中途介紹了不是用 VStack 的兩個 Text

531
00:45:30,563 --> 00:45:33,864
而是用一個 Text 的形式

532
00:45:33,864 --> 00:45:40,364
當想要使用本地化鍵 (Localized Key) 的時候

533
00:45:40,364 --> 00:45:44,099
使用那種寫法

534
00:45:44,099 --> 00:45:47,831
我認為這就是 FormatStyle 的使用方式

535
00:45:47,831 --> 00:45:54,697
我覺得用格式樣式講 40 分鐘對我來說還蠻硬核的

536
00:45:54,697 --> 00:45:57,465
不過因為我喜歡 FormatStyle

537
00:45:57,465 --> 00:46:01,364
以我個人的見解來說，在可本地化 (Localizable) 的部分

538
00:46:01,364 --> 00:46:04,965
不包含格式這一塊

539
00:46:04,965 --> 00:46:09,764
例如單位的處理或是配合地區的符號顯示

540
00:46:09,764 --> 00:46:12,666
交給格式樣式這邊來處理

541
00:46:12,666 --> 00:46:15,965
不寫在可本地化字串 (Localizable Strings) 裡

542
00:46:15,965 --> 00:46:17,364
我是這樣建議的

543
00:46:17,364 --> 00:46:20,063
平常在個人開發時也是這樣做的

544
00:46:20,500 --> 00:46:22,300
(Q) 謝謝您

545
00:46:23,733 --> 00:46:25,599
(主持) 謝謝

546
00:46:25,599 --> 00:46:28,300
時間上看來下一個會是最後一個問題

547
00:46:28,300 --> 00:46:31,599
有意見或問題的人請舉手

548
00:46:37,831 --> 00:46:40,465
那麼時間到了

549
00:46:40,465 --> 00:46:45,000
問答時間到此結束

550
00:46:45,000 --> 00:46:47,666
接下來是一分鐘回饋時間

551
00:46:47,666 --> 00:46:57,666
翻譯：Lihsuan Chen
校對：Hokila

