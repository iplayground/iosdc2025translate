1
00:00:00,000 --> 00:00:03,360
差不多該開始了，格式樣式

2
00:00:03,360 --> 00:00:08,960
田中良我

3
00:00:16,200 --> 00:00:23,520
好的，那麼接下來我將以「差不多該開始了，格式樣式」為題進行發表，請多多指教。

4
00:00:23,520 --> 00:00:26,720
本次發表由我田中良我擔任。

5
00:00:26,720 --> 00:00:30,720
平常我是以這個橘色圖示進行活動。

6
00:00:30,720 --> 00:00:34,020
跟新款 iPhone 的顏色是一樣的橘色呢。

7
00:00:34,020 --> 00:00:37,120
個人開發方面，我使用 Swift 開發應用程式，

8
00:00:37,120 --> 00:00:43,520
另外在 DeNA 股份有限公司也擔任 iOS 應用程式開發者。

9
00:00:43,520 --> 00:00:49,120
過去在 iOSDC Japan 曾經進行過 3 次演講，都是 40 分鐘的常規演講，

10
00:00:49,120 --> 00:00:53,320
這次是第 4 次。

11
00:00:53,520 --> 00:00:58,520
我第一次登台演講是在 2021 年，

12
00:00:58,520 --> 00:01:00,120
當時的題目是

13
00:01:00,120 --> 00:01:06,320
「輕鬆正確地將各種資訊格式化為字串」。

14
00:01:06,320 --> 00:01:08,520
回顧當時的存檔，

15
00:01:08,520 --> 00:01:15,720
內容是使用格式化器 (Formatter) 將各種資料轉換為字串。

16
00:01:15,720 --> 00:01:21,520
當時的設計就像是那年在日本舉辦的國際體育賽事開幕式的一幕，

17
00:01:21,520 --> 00:01:24,720
我就是用那樣的設計發表的。

18
00:01:24,720 --> 00:01:29,720
其中對於 2021 年當時最新的 iOS 版本

19
00:01:29,720 --> 00:01:35,120
iOS 15 的新功能稍微提到了一些。

20
00:01:35,120 --> 00:01:36,720
當時的螢幕截圖是這樣的。

21
00:01:36,720 --> 00:01:39,720
坐在後面的朋友可能看不太清楚，

22
00:01:39,720 --> 00:01:42,720
在 Apple 關於新功能的文件中，

23
00:01:42,720 --> 00:01:44,720
經常會出現「No overview available」，

24
00:01:44,720 --> 00:01:47,720
也就是什麼都沒寫的文件，

25
00:01:47,720 --> 00:01:54,720
當時就是這樣的狀況，而這就是今天的主題——格式樣式 (Format Style)。

26
00:01:54,720 --> 00:01:58,720
格式樣式是 iOS 15 以後可以使用的機制。

27
00:01:58,720 --> 00:02:01,720
在 2021 年剛發布的當時，

28
00:02:01,720 --> 00:02:05,720
例如因為最低部署目標 (Minimum Deployment Target) 等關係，

29
00:02:05,720 --> 00:02:09,720
要導入實際產品可能有些困難，

30
00:02:09,720 --> 00:02:11,720
但從那時起已經過了 4 年，

31
00:02:11,720 --> 00:02:16,720
而且前陣子 iOS 18 也發布了，

32
00:02:16,720 --> 00:02:19,720
根據 Apple 的資料，許多使用者的裝置

33
00:02:19,720 --> 00:02:22,720
已經支援格式樣式，

34
00:02:22,720 --> 00:02:25,720
環境已經成熟了。

35
00:02:25,720 --> 00:02:27,720
正是探討格式樣式

36
00:02:27,720 --> 00:02:32,720
最合適的時機，所以這次我決定進行發表。

37
00:02:32,720 --> 00:02:36,720
本次演講的對象是在 Swift 或 iOS 應用程式開發中

38
00:02:36,720 --> 00:02:42,720
準備學習資料格式化的朋友，

39
00:02:42,720 --> 00:02:45,720
雖然使用過傳統的格式化器 (Formatter)，

40
00:02:45,720 --> 00:02:50,720
但對這個新的格式樣式還不太熟悉的朋友，

41
00:02:50,720 --> 00:02:52,720
以及標準函式庫中沒有提供的

42
00:02:52,720 --> 00:02:55,720
自訂格式樣式的製作範例

43
00:02:55,720 --> 00:03:00,720
想要了解的朋友。

44
00:03:00,720 --> 00:03:06,720
那麼，讓我們重新思考一下，什麼是資料格式化呢？

45
00:03:06,720 --> 00:03:09,720
這裡有一張螢幕截圖。

46
00:03:09,720 --> 00:03:12,720
畫面中央顯示著本次演講的標題

47
00:03:12,720 --> 00:03:17,720
以及開始日期時間。

48
00:03:17,720 --> 00:03:21,720
用 SwiftUI 的程式碼表示就是這樣。

49
00:03:21,720 --> 00:03:29,720
現在演講開始日期時間的部分是直接在 Text 中寫入字串。

50
00:03:29,720 --> 00:03:34,720
讓這個標題和開始日期時間從 View 外部傳入。

51
00:03:34,720 --> 00:03:38,720
而且 Swift 有可以處理日期時間的

52
00:03:38,720 --> 00:03:40,720
Date 型別，

53
00:03:40,720 --> 00:03:45,720
所以將這個 date 屬性的型別從現在的 String 型別

54
00:03:45,720 --> 00:03:48,720
改為以 Date 型別傳入。

55
00:03:48,720 --> 00:03:51,720
但是如果程式碼維持這樣的話，

56
00:03:51,720 --> 00:03:53,720
SwiftUI 的 Text 初始化器

57
00:03:53,720 --> 00:03:57,720
無法傳入這個 Date 型別，會發生錯誤，

58
00:03:57,720 --> 00:04:02,720
導致無法建置。

59
00:04:02,720 --> 00:04:04,720
要解決這個建置錯誤，

60
00:04:04,720 --> 00:04:09,720
就型別而言，需要使用某種方法從這個 Date 型別

61
00:04:09,720 --> 00:04:12,720
轉換為 String 型別，

62
00:04:12,720 --> 00:04:16,720
抱歉，然後傳給 SwiftUI 的 Text 就可以了。

63
00:04:16,720 --> 00:04:18,720
就是這樣。

64
00:04:18,720 --> 00:04:25,720
那麼，讓我們來思考一下如何進行這個轉換。

65
00:04:25,720 --> 00:04:27,720
Swift 的 Date 型別有

66
00:04:27,720 --> 00:04:32,720
timeIntervalSinceReferenceDate 這個屬性。

67
00:04:32,720 --> 00:04:37,720
這是從世界標準時間 2001 年 1 月 1 日 0 時 0 分開始

68
00:04:37,720 --> 00:04:43,720
有多少秒差異的值。

69
00:04:43,720 --> 00:04:46,720
以日本時間今天 13 點來說，

70
00:04:46,720 --> 00:04:54,720
會是 7 億 8033 萬 3600 秒這個數字。

71
00:04:54,720 --> 00:04:59,720
然後進一步從年、月、日、時、分

72
00:05:00,000 --> 00:05:04,800
數字要透過指則運算來推算，這樣做比較好嗎？

73
00:05:06,800 --> 00:05:10,000
不過，就算能夠計算出西曆年份，

74
00:05:10,000 --> 00:05:14,200
在 iOS 中使用者也可以將其設定為和曆。

75
00:05:14,600 --> 00:05:17,200
這種情況下該如何因應才好呢？

76
00:05:19,400 --> 00:05:26,600
此外在英語環境中，月份本來就不是數字而是固定的英文單字，

77
00:05:26,800 --> 00:05:30,800
而且可能會偏好使用 12 小時制而非 24 小時制。

78
00:05:33,000 --> 00:05:37,800
當有某些資料需要轉換成字串時，

79
00:05:38,200 --> 00:05:42,400
考慮使用者的語言、地區、文化等因素，

80
00:05:42,400 --> 00:05:47,800
能以對該使用者來說最熟悉的格式來傳達資訊，我認為這是最理想的。

81
00:05:48,600 --> 00:05:51,600
這就稱為資料的格式化 (Format)。

82
00:05:52,600 --> 00:06:01,600
對於我們這些開發 iOS 應用程式、為世界各地多元使用者打造資訊傳遞介面的人來說，

83
00:06:01,600 --> 00:06:07,600
將資料格式化成適當的形式，是無法迴避且非常重要的課題。

84
00:06:08,200 --> 00:06:14,200
在一個應用程式中，可能會在各種地方反覆進行資料格式化。

85
00:06:15,200 --> 00:06:21,200
另一方面，關於資料格式化有無數需要考慮的事項，

86
00:06:21,200 --> 00:06:27,200
要讓它在任何時候都能如預期運作是非常困難的。

87
00:06:28,200 --> 00:06:34,200
因此，對於常用的資料類型，為了不需要自己撰寫格式化處理，

88
00:06:34,200 --> 00:06:41,200
Swift 和 OS 的框架中已經預先準備好資料格式化的 API。

89
00:06:41,200 --> 00:06:47,200
那麼，讓我們來試試資料格式化吧。

90
00:06:47,200 --> 00:06:55,200
難得在 iOS 應用程式開發現場，也逐漸能看到編碼智慧 (Coding Intelligence) 的應用案例，

91
00:06:55,200 --> 00:07:00,200
這裡就來問問某個大型語言模型 (LLM) 吧。

92
00:07:00,200 --> 00:07:08,200
選擇 Xcode 中出現錯誤的地方，按下「Generate Fix for Issue」按鈕。

93
00:07:09,200 --> 00:07:13,200
結果，LLM 給出了某種回應。

94
00:07:13,200 --> 00:07:18,200
看起來它幫我們修改了程式碼。

95
00:07:18,200 --> 00:07:23,200
這裡使用了 DateFormatter。

96
00:07:23,200 --> 00:07:30,200
DateFormatter 的父類別 NSFormatter，在 Swift 出現之前，

97
00:07:30,200 --> 00:07:36,200
從 Objective-C 時代就已經存在的資料格式化 API。

98
00:07:36,200 --> 00:07:42,200
Foundation 中有 13 種繼承 NSFormatter 的格式化器，

99
00:07:42,200 --> 00:07:49,200
除了日期時間之外，還支援數值、人名、重量和長度等測量值，

100
00:07:49,200 --> 00:07:53,200
對應各種類型的資料格式化。

101
00:07:53,200 --> 00:08:02,200
從 2016 年 9 月發布的 Swift 3 開始，呼叫時不再需要 NS 前綴，變成了這樣的外觀。

102
00:08:02,200 --> 00:08:08,200
LLM 寫的就是使用這個 DateFormatter 的程式碼。

103
00:08:08,200 --> 00:08:12,200
這個格式化器是非常強大且靈活的 API，

104
00:08:12,200 --> 00:08:18,200
但從 Swift 現代開發典範以及重視安全性的觀點來看，

105
00:08:18,200 --> 00:08:23,200
有幾個必須注意的地方。

106
00:08:23,200 --> 00:08:28,200
那麼，讓我們繼續以 DateFormatter 為例來說明。

107
00:08:28,200 --> 00:08:34,200
這裡準備了去年年底，也就是跨年前的時刻作為 Date 屬性，

108
00:08:34,200 --> 00:08:38,200
讓我們來格式化這個資料。

109
00:08:38,200 --> 00:08:47,200
建立 DateFormatter 類別的實例，指定日期時間格式化的形式。

110
00:08:47,200 --> 00:08:52,200
完成後，使用實例方法 stringFrom，

111
00:08:52,200 --> 00:08:55,200
取得格式化為 String 型別的結果。

112
00:08:55,200 --> 00:09:01,200
如果熟悉命令式程式設計，我認為這是非常易讀的程式碼。

113
00:09:01,200 --> 00:09:07,200
如果格式化結果中不需要時刻的部分，

114
00:09:07,200 --> 00:09:13,200
可以在 TimeStyle 的部分指定 None 來進行客製化。

115
00:09:13,200 --> 00:09:22,200
那麼，如果只想要年和月的部分，不需要日期的話，該怎麼做呢？

116
00:09:22,200 --> 00:09:29,200
DateFormatter 有一個可以更靈活指定格式化形式的 DateFormat 屬性。

117
00:09:29,200 --> 00:09:37,200
這次因為只想要年和月，所以使用大寫的 Y 和大寫的 M，

118
00:09:37,200 --> 00:09:43,200
然後因為希望在後面也顯示「年」和「月」的漢字，所以加上去。

119
00:09:43,200 --> 00:09:47,200
那麼用實例方法 stringFrom 來格式化的話，

120
00:09:47,200 --> 00:09:53,200
年份的數字變成了 2025 而不是 2024。

121
00:09:53,200 --> 00:09:59,200
這是哪裡出錯了呢？

122
00:10:00,000 --> 00:10:03,400
DateFormatter 屬性所接受的字串，

123
00:10:03,400 --> 00:10:07,600
必須使用 Unicode 技術標準的規範。

124
00:10:07,600 --> 00:10:12,400
必須根據 Unicode 規範中的表格，

125
00:10:12,400 --> 00:10:15,400
來組建 DateFormatter 的字串。

126
00:10:15,400 --> 00:10:18,600
那是一個非常龐大的表格，

127
00:10:18,600 --> 00:10:21,600
螢幕上已經看不清楚寫了什麼，

128
00:10:21,600 --> 00:10:24,800
剛才 DateFormatter 的這個錯誤，

129
00:10:24,800 --> 00:10:27,800
是表示年份的 Y 這個字元，

130
00:10:27,800 --> 00:10:32,800
應該要用小寫而不是大寫。

131
00:10:32,800 --> 00:10:35,800
本來想說這樣就解決了，

132
00:10:35,800 --> 00:10:38,800
但之後如果在英語環境中，

133
00:10:38,800 --> 00:10:43,800
也要支援像 December 2024 這樣的表記方式，

134
00:10:43,800 --> 00:10:46,800
這時候該怎麼辦呢？

135
00:10:46,800 --> 00:10:52,800
目前的狀況是 DateFormatter 中直接包含了年、月等漢字，

136
00:10:52,800 --> 00:10:56,800
而且日語是年在前、月在後，

137
00:10:56,800 --> 00:11:01,800
但英語的情況是月在前、年在後，有這樣的差異。

138
00:11:01,800 --> 00:11:05,800
像這樣即使只是日期時間的格式，

139
00:11:05,800 --> 00:11:08,800
需要考慮的模式就有無數種，

140
00:11:08,800 --> 00:11:12,800
而且即使格式字串的指定有錯誤，

141
00:11:12,800 --> 00:11:15,800
在執行程式之前也無法知道結果。

142
00:11:15,800 --> 00:11:20,800
因此不應該直接在 DateFormatter 中指定字串。

143
00:11:20,800 --> 00:11:24,800
在 Apple 的 WWDC 講座中，

144
00:11:25,800 --> 00:11:29,800
也明確指出這幾乎必定會產生非預期的結果，

145
00:11:29,800 --> 00:11:35,800
清楚說明了不要直接在 DateFormatter 中指定字串。

146
00:11:35,800 --> 00:11:38,800
因為很重要所以再說一次，

147
00:11:38,800 --> 00:11:41,800
在非常舊的資料中可能會說只有這個方法，

148
00:11:41,800 --> 00:11:45,800
而介紹直接在 DateFormatter 中指定的方法，

149
00:11:45,800 --> 00:11:49,800
或是程式碼智慧工具的 LLM 可能會建議這個方法，

150
00:11:49,800 --> 00:11:51,800
但請不要使用。

151
00:11:51,800 --> 00:11:57,800
我想這應該寫在 Agent2 Markdown 之類的地方會比較好。

152
00:11:57,800 --> 00:11:59,800
話題有點偏離了，

153
00:11:59,800 --> 00:12:02,800
讓我們回到最初的程式碼。

154
00:12:02,800 --> 00:12:04,800
重新閱讀這段程式碼，

155
00:12:04,800 --> 00:12:08,800
在 SwiftUI 的 View Protocol 的 body 中，

156
00:12:08,800 --> 00:12:12,800
呼叫了 FormattedDate，

157
00:12:12,800 --> 00:12:17,800
這個 FormattedDate 是 Computed Property，每次被呼叫時，

158
00:12:17,800 --> 00:12:20,800
都會生成 DateFormatter 的實例，

159
00:12:20,800 --> 00:12:26,800
並指定 dateStyle、timeStyle 來進行格式化。

160
00:12:26,800 --> 00:12:33,800
SwiftUI 的 View 的 body 可能會被框架多次呼叫。

161
00:12:33,800 --> 00:12:39,800
每次被呼叫時都會重新生成 formatter 的實例。

162
00:12:39,800 --> 00:12:46,800
眾所周知，生成 formatter 實例的成本非常高。

163
00:12:46,800 --> 00:12:52,800
關於這個高成本的問題，已經有許多人提及，

164
00:12:52,800 --> 00:12:57,800
例如我們來看看 Apple 今年 WWDC 的講座。

165
00:12:57,800 --> 00:13:03,800
使用 Instruments 測量效能不佳的 SwiftUI 應用程式，

166
00:13:03,800 --> 00:13:06,800
發現了像剛才展示的程式碼那樣，

167
00:13:06,800 --> 00:13:10,800
從 View 的 body 中多次

168
00:13:10,800 --> 00:13:15,800
生成 formatter 實例的地方。

169
00:13:16,800 --> 00:13:22,800
作為對應策略，使用 formatter 來生成格式化字串，

170
00:13:22,800 --> 00:13:28,800
將 string(from:) 的呼叫改為在其他地方事先統一執行，

171
00:13:28,800 --> 00:13:33,800
或是將 formatter 實例的生成次數降到最低

172
00:13:33,800 --> 00:13:37,800
透過快取的方式，講座中介紹了這些方法。

173
00:13:40,800 --> 00:13:43,800
那麼讓我們總結一下到目前為止的內容。

174
00:13:44,800 --> 00:13:50,800
傳統的 formatter 是功能非常強大且可高度客製化的。

175
00:13:50,800 --> 00:13:55,800
但在某些模式下，即使客製化有錯誤，

176
00:13:55,800 --> 00:14:00,800
在編譯時也無法察覺，必須實際執行才能確認。

177
00:14:01,800 --> 00:14:05,800
此外，生成 formatter 實例的成本，

178
00:14:05,800 --> 00:14:11,800
以及雖然省略說明，但屬性變更的成本也很高。

179
00:14:12,800 --> 00:14:20,800
因此最佳實踐是自行實作快取機制來減少這些操作的次數。

180
00:14:21,800 --> 00:14:27,800
另外，Swift 常使用值型別，但這個 formatter 是參考型別。

181
00:14:27,800 --> 00:14:32,800
在共享快取時也需要注意這一點。

182
00:14:33,800 --> 00:14:40,800
還有在現今 Swift Concurrency 的時代，是否執行緒安全也需要特別注意。

183
00:14:41,800 --> 00:14:47,800
而且它不是 SwiftUI 等流行的宣告式，而是命令式的 API 設計。

184
00:14:50,800 --> 00:14:57,800
到目前為止，我並不打算深入探討 formatter 的好壞，

185
00:14:57,800 --> 00:14:59,800
只是這些特性

186
00:15:00,000 --> 00:15:09,840
活用這樣的思維方式，作為符合現今 Swift 時代的全新介面而登場的，就是格式樣式（Format Style）。

187
00:15:10,840 --> 00:15:21,080
這個格式樣式，正確來說是一個協定（Protocol）的名稱。可在 iOS 15 以後使用，用於定義將特定資料型別轉換為另一種型別，

188
00:15:21,080 --> 00:15:28,960
例如字串（String）型別的介面。

189
00:15:28,960 --> 00:15:40,920
系統預設準備了各種用途的格式樣式，截至 iOS 26 為止，共有 46 種格式樣式存在。

190
00:15:41,400 --> 00:15:51,080
這是使用傳統格式器（Formatter）撰寫的程式碼，如果改用格式樣式來撰寫的話，會變成這樣。

191
00:15:51,080 --> 00:15:55,320
程式碼變得非常精簡了呢。

192
00:15:55,440 --> 00:16:03,440
讓我們比較一下使用者的程式碼。過去存在的 DateFormatter 的描述本身就消失了。

193
00:16:03,440 --> 00:16:14,120
而且過去是將資料傳遞給格式器端存在的方法的參數，

194
00:16:14,120 --> 00:16:22,600
但使用格式樣式的方法則改為對資料加上 formatted 這個方法。

195
00:16:23,480 --> 00:16:35,040
不需要自己建立對應資料的格式器實例，只需簡單地對資料加上 formatted，就能輕鬆進行格式化。

196
00:16:35,480 --> 00:16:46,120
也可以在這個 formatted 方法中指定詳細的樣式。如果不指定的話，會使用預設的實作。

197
00:16:46,520 --> 00:16:57,920
關於彈性的樣式指定，也不需要記住剛才提到的羅馬字小寫 Y 怎樣、大寫 M 怎樣之類複雜的字串樣式規則，

198
00:16:57,920 --> 00:17:06,880
想要年份就加上 year，想要月份就加上 month，可以一邊使用程式碼補全功能一邊安全地撰寫。

199
00:17:06,880 --> 00:17:12,440
而且之後閱讀時的可讀性也非常高。

200
00:17:13,360 --> 00:17:22,240
格式樣式是為 Swift 而設計的，外部介面的部分是 100% 用 Swift 撰寫的。

201
00:17:22,240 --> 00:17:31,760
而且相對於格式器是類別（Class）、參考型別，格式樣式基本上是用結構（Struct）、值型別來建立，

202
00:17:31,760 --> 00:17:39,520
具有容易受到堆疊上的配置、寫入時複製（Copy-on-Write）、編譯器最佳化等好處的優點。

203
00:17:39,640 --> 00:17:43,400
樣式的指定可以以型別安全的方式進行，

204
00:17:43,400 --> 00:17:50,520
格式樣式內部使用的格式器實例會由框架端自動快取。

205
00:17:50,520 --> 00:18:01,320
從剛才必須考慮手動快取之類的事情中解放出來，在效能上的優點似乎也能在一定程度上享受到。

206
00:18:01,320 --> 00:18:10,600
還有，搭配流行的宣告式介面，對現代的人們來說變得更容易使用，這就是格式樣式。

207
00:18:11,680 --> 00:18:18,440
了解了傳統的格式器與格式樣式在介面等方面的差異之後，

208
00:18:18,440 --> 00:18:24,920
接下來要介紹協定中定義的格式樣式規則。

209
00:18:25,200 --> 00:18:41,640
符合格式樣式協定的型別，需要以主要關聯型別（Primary Associated Type）的形式，指定格式的輸入端型別與輸出端型別分別是什麼。

210
00:18:41,640 --> 00:18:50,120
然後需要實作使用實際輸入的值進行格式化，並輸出結果的方法。

211
00:18:50,640 --> 00:18:57,680
在今天一開始展示的，從 Date 型別到 String 型別的格式化的情況下，

212
00:18:57,680 --> 00:19:07,520
FormatInput 會是 Date 型別，FormatOutput 會是 String 型別。

213
00:19:08,320 --> 00:19:18,400
接下來，我想列舉 iOS 26 之前包含的所有可立即使用的格式樣式種類。

214
00:19:18,400 --> 00:19:25,360
不過，到目前為止我們都在討論日期時間的格式化，

215
00:19:25,360 --> 00:19:30,360
現在的 iOS 也存在對應其他資料的格式樣式。

216
00:19:30,360 --> 00:19:38,480
不過，要一次記住這些全部是很困難的，而且從這裡開始不斷列舉的話可能會讓人想睡覺，

217
00:19:38,480 --> 00:19:44,800
如果方便的話，希望大家可以在之後公開的資料或是封存影片中回來複習。

218
00:19:45,800 --> 00:19:49,800
那麼首先，讓我們來看看日期與時間。

219
00:19:49,800 --> 00:19:57,800
Date.FormatStyle 是進行日期與時刻格式化的最基本樣式。

220
00:19:57,800 --> 00:19:59,800
Date 型別的屬性。

221
00:20:00,000 --> 00:20:13,000
加上格式化後，就會使用這個格式樣式。可以透過 date 引數和 time 引數來細緻地指定樣式，能夠實現各種不同的表現方式。

222
00:20:13,000 --> 00:20:22,200
此外，使用方法鏈 (method chain) 可以詳細設定年、月、日、時、分、秒，以及時區等資訊。

223
00:20:22,200 --> 00:20:31,040
欄位的順序不會影響最終的輸出結果。作業系統會根據地區設定 (locale) 適當地進行配置。

224
00:20:31,040 --> 00:20:45,080
例如，上面的例子是按照美式英語的月、日、年順序來指定的，但在日本的日語環境下執行時，就會正確地顯示為年、月、日。

225
00:20:45,080 --> 00:20:55,600
此外，還可以進行月份或星期的縮寫顯示，以及當數字為一位數時用零填補 (padding) 等處理。

226
00:20:56,400 --> 00:21:09,160
接下來，有一個 Date ISO 8601 格式樣式。在格式化的地方寫上 ISO 8601，這在與伺服器進行資料通訊等情況下

227
00:21:09,160 --> 00:21:17,240
有 ISO 8601 這個規範，當需要該日期時間格式時，可以非常方便地使用。

228
00:21:18,360 --> 00:21:29,920
可以加上時區資訊，或者像剛才的 date format 一樣，用方法鏈寫出想要的元素，細緻地指定要輸出的元素。

229
00:21:30,280 --> 00:21:38,240
在 iOS 16 中，DateComponents 也準備了 ISO 8601 格式的樣式。

230
00:21:40,960 --> 00:21:50,240
這也是新導入的功能，還有符合 HTTP 的 RFC 9110 規範的格式樣式。

231
00:21:50,720 --> 00:21:58,360
在網頁通訊中處理日期時間標頭 (header) 等時，我認為會變得格外容易。

232
00:22:00,320 --> 00:22:03,440
這個同樣也有 DateComponents 版本。

233
00:22:05,960 --> 00:22:12,400
如果想要更進一步自訂輸出格式，可以使用 Date.VerbatimFormatStyle。

234
00:22:13,920 --> 00:22:18,280
就像前面提到的傳統 DateFormatter 的 dateFormat 屬性一樣，

235
00:22:18,720 --> 00:22:22,320
這是一個可以用字串直接指定自訂格式的樣式。

236
00:22:23,120 --> 00:22:28,320
不過，透過這個 Date.FormatString 所提供的字串插值 (string interpolation)，

237
00:22:28,320 --> 00:22:33,640
藉由字串補完項群，可以以型別安全 (type-safe) 的方式進行格式化。

238
00:22:34,640 --> 00:22:45,040
例如，像這裡這樣，有一種需要用年號和年、月、日、星期，用句點連接的和曆格式，

239
00:22:45,520 --> 00:22:50,120
如果在格式化時與地區設定和時區一起指定的話，

240
00:22:50,120 --> 00:23:02,920
無論 iOS 裝置的日曆是西曆還是和曆，都能確實地得到像這個例子 R07.09.20 這樣符合和曆規格的輸出。

241
00:23:06,320 --> 00:23:13,720
接下來，這個 Date.IntervalFormatStyle 是用來格式化兩個日期之間期間的樣式。

242
00:23:14,720 --> 00:23:22,720
它接收日期的範圍型別作為輸入，以符合使用者地區設定的自然形式來格式化期間。

243
00:23:23,720 --> 00:23:36,720
例如，省略時刻只輸出日期期間時，在日本的日語環境下會輸出「19日〜21日」用波浪線、波浪破折號，

244
00:23:37,720 --> 00:23:44,720
在美式英語環境下則會輸出「September 19–21」這樣的形式。

245
00:23:46,720 --> 00:23:53,720
還有 Date.ComponentsFormatStyle，這個會格式化日期元件之間的差異。

246
00:23:54,720 --> 00:24:01,720
將兩個日期之間的差異以「2 天」或「2 天 2 小時」等人類易讀的形式顯示。

247
00:24:02,720 --> 00:24:06,720
這個也可以透過 style 引數來自訂輸出樣式。

248
00:24:10,720 --> 00:24:14,720
類似的還有 Date.RelativeFormatStyle。

249
00:24:15,720 --> 00:24:21,720
這是用來格式化以現在時刻為基準的相對日期時間的樣式。

250
00:24:23,720 --> 00:24:29,720
使用 named 樣式的話，可以得到「上個月」、「這個月」、「下個月」等自然語言的表達。

251
00:24:31,720 --> 00:24:36,720
改用 numeric 樣式的話，可以進行「1 個月後」這樣的數值相對表達。

252
00:24:38,720 --> 00:24:45,720
也能進行非單位的相對表達，像是「前天」、「昨天」、「今天」、「明天」、「後天」這樣的表達，

253
00:24:45,720 --> 00:24:48,720
會根據地區設定自動套用。

254
00:24:49,720 --> 00:24:56,720
這個格式樣式會以現在時刻為基準輸出相對的內容，

255
00:24:56,720 --> 00:25:00,720
而這個基準是使用現在的時刻作為基準。

256
00:25:00,000 --> 00:25:07,120
如果想要指定任意時刻的話，就使用這個 DateAnchoredRelativeFormatStyle。

257
00:25:07,120 --> 00:25:18,440
將特定的日期時間指定為錨點，然後以該基準對輸入的日期時間進行相對格式化。

258
00:25:18,440 --> 00:25:30,600
關於日期時間的格式化已經講了很多，但我想數值的格式化也是同樣常用的功能。

259
00:25:30,600 --> 00:25:43,760
整數、浮點數、Decimal 型別都各自準備了格式化樣式，預設會根據地區設定進行三位數分隔等顯示。

260
00:25:43,760 --> 00:25:49,800
在日本的日語環境下，就是每三位數會出現逗號的感覺。

261
00:25:49,800 --> 00:26:00,040
此外使用 rounded 修飾詞的話，可以指定四捨五入、無條件捨去、無條件進位等數字的進位規則。

262
00:26:00,040 --> 00:26:09,280
還可以指定有效位數、使用指數表示法等，有很多修飾詞可以用來自訂。

263
00:26:10,200 --> 00:26:17,680
各個數值型別也都準備了以百分率、百分比形式格式化的樣式。

264
00:26:17,680 --> 00:26:35,720
數值會自動乘以 100 倍，並根據地區設定加上百分比符號。百分比符號要放在哪裡、百分比符號本身是什麼，這些都會因地區設定而不同，系統會自動調整。

265
00:26:36,360 --> 00:26:48,960
同樣地也準備了以貨幣形式格式化的樣式。透過指定貨幣代碼，可以支援根據地區設定的貨幣符號以及小數點以下的位數。

266
00:26:48,960 --> 00:26:58,800
即使在同一個國家或地區，如果語言不同，貨幣符號顯示的位置也會改變，這點也有支援。

267
00:26:59,760 --> 00:27:09,160
接下來介紹 iOS 16 導入的 Duration 型別所使用的格式化樣式。

268
00:27:09,160 --> 00:27:19,680
有一個叫做 Duration.TimeFormatStyle 的樣式，它會將 Duration 的值以時、分、秒的形式格式化。

269
00:27:19,760 --> 00:27:31,480
有一個叫做 pattern 的參數，在這裡指定 hourMinute 或 hourMinuteSecond 等，就可以細緻地控制時、分、秒的顯示格式。

270
00:27:31,480 --> 00:27:39,400
使用 padHourToLength 等方法，也可以對齊位數。

271
00:27:39,520 --> 00:27:48,200
還有一個叫做 UnitsFormatStyle 的樣式，它會自動使用最適合的單位來格式化 Duration 的值。

272
00:27:48,200 --> 00:27:56,440
可以從這邊指定要使用的單位，也可以用零來填補位數。

273
00:27:57,120 --> 00:28:05,640
接下來是關於測量值的格式化樣式。大家知道 Swift 中的測量值嗎？

274
00:28:05,640 --> 00:28:12,960
Swift 的 Foundation 中有一個可以表示各種值的單位，叫做 Measurement。

275
00:28:13,360 --> 00:28:23,760
例如當有表示面積的資料時，可能會首先想到簡單地使用 Int 型別或 Double 型別，

276
00:28:23,760 --> 00:28:33,320
但如果使用 UnitArea 的 Measurement 型別，就可以透過型別系統明確地表示這個資料是面積。

277
00:28:33,320 --> 00:28:44,600
同時也可以持有該資料的單位。這裡用平方公里表示東北三個縣的面積。

278
00:28:44,600 --> 00:28:49,560
所以後面寫著 squareKilometers。

279
00:28:49,880 --> 00:29:00,960
對這些加上格式化後，就會一起輸出資料的數值和單位。可以將單位的輸出樣式從這個「平方公里」

280
00:29:00,960 --> 00:29:13,680
轉換成漢字和片假名的形式，如果針對美式英語格式化的話，平方公里就會轉換成平方英里輸出。

281
00:29:14,840 --> 00:29:23,000
也準備了適合表示記憶體或檔案大小的格式化樣式。

282
00:29:23,000 --> 00:29:36,520
會自動轉換成 KB、MB、GB 等最適合的單位並輸出。這個也可以用 style 參數和 unit 參數來控制顯示格式和單位。

283
00:29:37,800 --> 00:29:49,440
接下來也有用來格式化人名的格式化樣式。有一個關於人名的型別叫做 PersonNameComponents，

284
00:29:49,440 --> 00:29:59,680
可以從這裡格式化人名。用 style 參數可以選擇 short、medium、long 等顯示格式，

285
00:30:00,000 --> 00:30:04,000
會根據地區設定自動套用姓名的順序。

286
00:30:06,500 --> 00:30:12,500
像這樣用羅馬拼音指定姓名、暱稱的話

287
00:30:12,500 --> 00:30:20,300
在縮寫形式中會產生縮寫字母，在日本地區設定中會是姓名的順序

288
00:30:20,300 --> 00:30:25,300
但在英語地區設定中則會以名、姓的順序顯示縮寫字母，有這樣的差異。

289
00:30:25,300 --> 00:30:31,300
馬上就要介紹完全部了。

290
00:30:31,300 --> 00:30:36,300
關於 URL 的格式樣式也有預設存在。

291
00:30:36,300 --> 00:30:43,300
可以將 URL 的主機、路徑、查詢等特定元件進行格式化。

292
00:30:43,300 --> 00:30:48,300
例如像這樣只取出查詢的部分

293
00:30:48,300 --> 00:30:54,300
或是像瀏覽器應用程式那樣，只想向使用者顯示 URL 的網域部分時

294
00:30:55,300 --> 00:31:00,300
應該會很有用。

295
00:31:00,300 --> 00:31:06,300
最後要介紹其他一些比較特殊的格式樣式。

296
00:31:06,300 --> 00:31:12,300
有準備將陣列等序列的元素連結起來，格式化為一個字串的樣式。

297
00:31:12,300 --> 00:31:18,300
這個樣式會根據地區設定，自動套用逗號或頓號等

298
00:31:18,300 --> 00:31:26,300
適當的分隔符號，以及連接詞。

299
00:31:26,300 --> 00:31:33,300
例如在日文中會變成「蘋果、頓號、香蕉、頓號、橘子」這樣

300
00:31:33,300 --> 00:31:38,300
在英文中則會是「apple、逗號、banana、逗號、and、orange」這樣

301
00:31:38,300 --> 00:31:43,300
變成人類閱讀時非常自然的樣式。

302
00:31:43,300 --> 00:31:47,300
這個列表格式樣式的成員樣式 (member style) 參數

303
00:31:47,300 --> 00:31:50,300
也可以傳入其他的格式樣式

304
00:31:50,300 --> 00:31:57,300
對列表的各個元素個別進行格式化，最終連結成的字串

305
00:31:57,300 --> 00:32:01,300
也可以用這個列表格式樣式來處理。

306
00:32:01,300 --> 00:32:05,300
先將數字格式化，最後再將它格式化為一個字串

307
00:32:05,300 --> 00:32:10,300
這就是這個範例的做法。

308
00:32:10,300 --> 00:32:13,300
這個我們幾乎不會直接使用

309
00:32:13,300 --> 00:32:17,300
但也有將字串格式化為字串的方式。

310
00:32:17,300 --> 00:32:20,300
是一種輸入和輸出不變的樣式

311
00:32:20,300 --> 00:32:24,300
例如在泛型 (generic) 的情境中，一定需要格式樣式

312
00:32:24,300 --> 00:32:30,300
這種時候作為預設的佔位符 (placeholder) 使用的就是這個字串樣式。

313
00:32:31,300 --> 00:32:35,300
就是這樣。

314
00:32:35,300 --> 00:32:41,300
StoreKit 框架中也有格式樣式存在。

315
00:32:41,300 --> 00:32:51,300
這裡準備了用來將訂閱期間以日、月、年為單位進行格式化的樣式。

316
00:32:51,300 --> 00:32:55,300
例如在 App Store Connect 中指定的訂閱期間

317
00:32:55,300 --> 00:33:02,300
就可以在應用程式內適當地進行本地化。

318
00:33:02,300 --> 00:33:03,300
非常辛苦了。

319
00:33:03,300 --> 00:33:09,300
以上就是 iOS 26 之前搭載的所有基本格式樣式。

320
00:33:09,300 --> 00:33:13,300
希望將來在各位平常的開發中，能成為想起

321
00:33:13,300 --> 00:33:18,300
「或許有那個格式樣式」的契機。

322
00:33:18,300 --> 00:33:25,300
那麼接下來想稍微回到格式樣式外部介面的話題。

323
00:33:25,300 --> 00:33:32,300
在剛才提到的格式樣式中，有可以輕鬆對輸出的字串進行裝飾的類型

324
00:33:32,300 --> 00:33:35,300
格式樣式存在。

325
00:33:35,300 --> 00:33:44,300
這個格式的輸出型別是可以加上屬性的字串，也就是 AttributedString。

326
00:33:44,300 --> 00:33:49,300
那麼來看看它是如何運作的。

327
00:33:49,300 --> 00:33:55,300
用格式樣式改寫的最初螢幕截圖是這個

328
00:33:55,300 --> 00:34:00,300
我取出了這裡格式化日期時間的部分。

329
00:34:00,300 --> 00:34:04,300
如果是支援屬性 (attribute) 的格式樣式

330
00:34:04,300 --> 00:34:10,300
可以像這樣在格式樣式的末尾加上 attributed 或 attributedStyle

331
00:34:10,300 --> 00:34:13,300
兩者都可以

332
00:34:13,300 --> 00:34:19,300
例如像這樣只對年份的部分指定前景色為紅色

333
00:34:19,300 --> 00:34:23,300
就會反映在視圖 (view) 上。

334
00:34:23,300 --> 00:34:25,300
其他常見的例子

335
00:34:25,300 --> 00:34:33,300
例如格式化貨幣時，只想讓貨幣符號的部分字體大小比數字小

336
00:34:33,300 --> 00:34:35,300
這樣的需求有時會出現

337
00:34:35,300 --> 00:34:39,300
這也可以用帶屬性的格式樣式來實現。

338
00:34:39,300 --> 00:34:48,300
這是圓符號的部分比數字稍微小一點的感覺。

339
00:34:48,300 --> 00:34:51,300
因為時間關係省略說明

340
00:34:51,300 --> 00:34:54,300
從 iOS 18 開始的 SwiftUI 碼表

341
00:34:54,300 --> 00:34:59,300
也有專門用於計時器等顯示的帶屬性格式樣式存在。

342
00:35:00,000 --> 00:35:09,000
那麼，既然提到了 SwiftUI 的話題，我們也來稍微看一下從 SwiftUI 使用格式樣式 (Format Style) 的方法。

343
00:35:09,000 --> 00:35:19,000
在這場演講的開頭，我說明了 SwiftUI 的 Text 初始化器無法傳入 Date 型別。

344
00:35:19,000 --> 00:35:26,000
所以我提到可以使用 formatted 方法轉換成 String 型別來解決這個問題，

345
00:35:26,000 --> 00:35:33,000
但實際上，Text 還有另一個可以接收 Date 型別的初始化器存在。

346
00:35:33,000 --> 00:35:35,000
就是這個形式。

347
00:35:35,000 --> 00:35:43,000
在 Text 的第一個參數放入某種資料，在第二個參數的 format 部分傳入格式樣式，

348
00:35:43,000 --> 00:35:47,000
就可以作為 SwiftUI 的 Text 來處理。

349
00:35:47,000 --> 00:35:50,000
我認為這是最佳的方法。

350
00:35:50,000 --> 00:35:55,000
特別是在建構運作限制嚴格的 Widget、Live Activity，

351
00:35:55,000 --> 00:36:01,000
或是 Complication 這類功能時，尤其應該使用這個方法。

352
00:36:01,000 --> 00:36:10,000
雖然在這個範例程式碼中不太明顯，但根據資料型別的不同，還存在效能更好的 DiscreteFormatStyle，

353
00:36:10,000 --> 00:36:13,000
也有可能受惠於此。

354
00:36:13,000 --> 00:36:18,000
如果可以的話，很希望能在 Schmooze Speaker 等場合聊聊天。

355
00:36:18,000 --> 00:36:22,000
此外，這裡雖然使用了 VStack，

356
00:36:22,000 --> 00:36:27,000
但如果想要將它作為一個 Text 來處理的話，

357
00:36:27,000 --> 00:36:37,000
也可以使用 String Interpolation 中帶有 format 參數的寫法。

358
00:36:37,000 --> 00:36:42,000
到目前為止，我們都是使用 SwiftUI 的 Text 來展示

359
00:36:42,000 --> 00:36:44,000
從這邊向使用者顯示內容的格式範例，

360
00:36:45,000 --> 00:36:50,000
但這個格式也可以用在 TextField 上。

361
00:36:50,000 --> 00:36:55,000
我們一直在看如何將某種資料格式化為字串，

362
00:36:55,000 --> 00:36:58,000
但反過來，從使用者接收字串，

363
00:36:58,000 --> 00:37:03,000
再用某種方法解析並轉換成這邊的資料型別。

364
00:37:03,000 --> 00:37:05,000
也就是 Parse 的處理。

365
00:37:05,000 --> 00:37:12,000
有時候會需要這樣的處理。

366
00:37:12,000 --> 00:37:18,000
這時就有 ParseableFormatStyle 存在。

367
00:37:18,000 --> 00:37:23,000
這個 ParseableFormatStyle 的 Parse 處理

368
00:37:23,000 --> 00:37:27,000
是在 ParseStrategy 這邊定義的。

369
00:37:27,000 --> 00:37:34,000
這裡有 ParseInput 和 ParseOutput 這兩個型別，請注意看。

370
00:37:34,000 --> 00:37:37,000
這個 ParseInput 和 ParseOutput

371
00:37:37,000 --> 00:37:44,000
被定義為與原本格式樣式的 Input 和 Output 分別形成對應關係，

372
00:37:44,000 --> 00:37:48,000
藉此表現出資料的格式化 (Format) 與解析 (Parse)

373
00:37:48,000 --> 00:37:52,000
分別是相反方向的關係。

374
00:37:52,000 --> 00:37:56,000
我超喜歡這種表現方式。

375
00:37:56,000 --> 00:38:03,000
以日期時間、數值或 URL 這類規則明確的格式樣式為中心，

376
00:38:03,000 --> 00:38:07,000
它們也都符合 ParseableFormatStyle。

377
00:38:07,000 --> 00:38:12,000
連人名也可以 Parse，真是令人驚訝呢。

378
00:38:12,000 --> 00:38:15,000
那麼關於這個 ParseableFormatStyle，

379
00:38:15,000 --> 00:38:20,000
我們來看看自己製作的方法，同時加深理解吧。

380
00:38:20,000 --> 00:38:23,000
如果想用作業系統沒有包含的樣式來格式化，

381
00:38:23,000 --> 00:38:28,000
可以選擇自己製作格式樣式。

382
00:38:28,000 --> 00:38:34,000
這是我以開源軟體 (OSS) 開發的工具，可以讓 Xcode 的程式碼智慧功能

383
00:38:34,000 --> 00:38:39,000
也能用 ChatGPT 或 Claude 以外的模型來使用，

384
00:38:39,000 --> 00:38:44,000
其中有一個畫面，讓使用者可以設定任意的連接埠號碼，

385
00:38:44,000 --> 00:38:49,000
使用了 SwiftUI 的 TextField。

386
00:38:49,000 --> 00:38:55,000
這個連接埠號碼是 NWEndpointPort 這個型別，

387
00:38:56,000 --> 00:39:00,000
但用來格式化它與字串的格式樣式

388
00:39:00,000 --> 00:39:03,000
目前在標準函式庫中並不存在。

389
00:39:03,000 --> 00:39:07,000
所以我們要自己製作。

390
00:39:07,000 --> 00:39:12,000
那麼首先從符合 FormatStyle 開始吧。

391
00:39:12,000 --> 00:39:15,000
接收 NWEndpointPort 型別，

392
00:39:15,000 --> 00:39:21,000
實作回傳字串的 format 方法。

393
00:39:21,000 --> 00:39:27,000
這個型別取得 rawValue 可以得到 UInt16，

394
00:39:27,000 --> 00:39:33,000
再將它作為數值格式化成字串。

395
00:39:33,000 --> 00:39:36,000
然後跟標準的格式樣式一樣

396
00:39:36,000 --> 00:39:41,000
提供捷徑 (shortcut)，就順利完成了。

397
00:39:41,000 --> 00:39:45,000
在 NWEndpointPort 後面加上 .formatted

398
00:39:45,000 --> 00:39:49,000
就可以格式化了。

399
00:39:49,000 --> 00:39:53,000
接著我們也來讓它符合 ParseableFormatStyle

400
00:39:53,000 --> 00:39:56,000
試試看。

401
00:39:56,000 --> 00:40:00,000
要符合這個協定，需要定義對應的 ParseStrategy。

402
00:40:00,000 --> 00:40:11,000
在 ParseStrategy 的這個 parse 方法中，我們會撰寫將輸入字串轉換為目標 NWEndpointPort 型別的邏輯。

403
00:40:13,000 --> 00:40:17,000
這邊也會寫一個用於存取的捷徑，這樣就完成了。

404
00:40:18,000 --> 00:40:24,000
這樣一來，不僅可以進行格式化的正向處理，反向的解析也能輕鬆完成了。

405
00:40:24,000 --> 00:40:35,000
今天我們確認了資料格式化在日常開發中是經常進行的作業，

406
00:40:35,000 --> 00:40:39,000
並且觀察了進行格式化的手段、API 的演變過程。

407
00:40:40,000 --> 00:40:45,000
標準搭載的格式化樣式有非常多種類，

408
00:40:45,000 --> 00:40:52,000
而且每一種都具備 Swift 特有的安全性，並能透過流行的機制以現代化的方式使用。

409
00:40:53,000 --> 00:41:01,000
此外，我們也了解到可以自己建立格式化樣式，具備可擴充的彈性。

410
00:41:02,000 --> 00:41:08,000
如果您目前參與的專案中，有使用傳統方法進行資料格式化的地方，

411
00:41:08,000 --> 00:41:12,000
請務必考慮遷移到這個格式化樣式。

412
00:41:15,000 --> 00:41:21,000
本次演講的製作參考了許多 Apple 的官方文件以及 WWDC 的議程。

413
00:41:21,000 --> 00:41:26,000
這些資源對於深入理解格式化樣式非常有幫助，在此推薦給大家。

414
00:41:28,000 --> 00:41:33,000
那麼，請從今天開始，試著使用格式化樣式吧。

415
00:41:34,000 --> 00:41:36,000
以上就是全部內容。感謝各位聆聽。

416
00:41:46,000 --> 00:41:48,000
感謝您的發表。

417
00:41:49,000 --> 00:41:51,000
那麼現在進入問答時間。

418
00:41:52,000 --> 00:41:55,000
有意見或問題的朋友，請舉手讓我們知道。

419
00:41:58,000 --> 00:42:00,000
我們會將麥克風送過去。請拿著麥克風。

420
00:42:08,000 --> 00:42:09,000
感謝您的分享。

421
00:42:10,000 --> 00:42:15,000
根據我過去的經驗，一直以來都在使用資料格式化，

422
00:42:16,000 --> 00:42:18,000
從單元測試的角度來看，

423
00:42:20,000 --> 00:42:25,000
經常需要從外部指定語系 (Locale) 或時區 (Time Zone)，而不是使用當前設定，

424
00:42:27,000 --> 00:42:29,000
來使用格式化功能，

425
00:42:30,000 --> 00:42:33,000
請問使用格式化樣式的情況下，也能做到這樣的事情嗎？

426
00:42:34,000 --> 00:42:36,000
好的。感謝您的提問。

427
00:42:38,000 --> 00:42:42,000
在日期相關的格式化樣式修飾子中，我介紹了各種不同的選項，

428
00:42:42,000 --> 00:42:45,000
其中也有指定語系的修飾子存在。

429
00:42:46,000 --> 00:42:51,000
所以使用那個修飾子，就可以注入語系設定，

430
00:42:52,000 --> 00:42:54,000
如果是測試用途的話，

431
00:42:55,000 --> 00:42:59,000
可以用能夠注入語系的自訂格式化樣式，

432
00:43:00,000 --> 00:43:06,000
包裝一層，然後對包裝後的版本從測試程式碼端進行注入 (Injection) 的設計，

433
00:43:07,000 --> 00:43:09,000
從外部來看會比較簡潔，

434
00:43:09,000 --> 00:43:13,000
不過如果不在團隊中告知大家正在這樣做的話，

435
00:43:14,000 --> 00:43:16,000
可能會產生「這是什麼方法」之類的問題，

436
00:43:17,000 --> 00:43:19,000
所以在那方面需要找到一個好的平衡點。

437
00:43:20,000 --> 00:43:21,000
謝謝您。

438
00:43:24,000 --> 00:43:25,000
感謝您。

439
00:43:26,000 --> 00:43:29,000
其他有意見或問題的朋友，請舉手。

440
00:43:39,000 --> 00:43:40,000
謝謝。

441
00:43:41,000 --> 00:43:44,000
這是個純粹出於興趣的問題，

442
00:43:45,000 --> 00:43:50,000
我記得有 Double 型別或浮點數的格式化樣式，

443
00:43:51,000 --> 00:43:54,000
這種浮點數常見的情況是，

444
00:43:55,000 --> 00:43:59,000
需要考慮捨入精度的問題對吧。

445
00:44:00,000 --> 00:44:03,000
例如常見的例子，0.1 加 0.2 不是 0.3 而是 0.3...

446
00:44:04,000 --> 00:44:05,000
這樣的情況，

447
00:44:05,000 --> 00:44:16,000
例如將 0.1 加 0.2 的結果進行格式化...單純用格式化輸出的話會變成什麼樣子，我有點好奇。

448
00:44:17,000 --> 00:44:18,000
謝謝您的提問。

449
00:44:19,000 --> 00:44:22,000
如果要格式化 Double 相加的結果，

450
00:44:23,000 --> 00:44:27,000
會以 0.33333 這樣的字串形式輸出。

451
00:44:28,000 --> 00:44:31,000
所以會在包含誤差的狀態下進行格式化，

452
00:44:31,000 --> 00:44:36,000
雖然無誤差的計算本來就不可能，

453
00:44:37,000 --> 00:44:46,000
但我認為格式化樣式的設計理念是，這個問題應該在格式化之前就解決。

454
00:44:51,000 --> 00:44:52,000
感謝您。

455
00:44:53,000 --> 00:44:56,000
其他有意見或問題的朋友請舉手。

456
00:45:00,000 --> 00:45:09,360
感謝您的發表

457
00:45:09,360 --> 00:45:13,600
我想您提到了幾個關於本地化的部分

458
00:45:13,600 --> 00:45:18,600
一般在業務上進行時，會使用本地化字串或字串目錄

459
00:45:18,600 --> 00:45:23,240
我想在執行的部分與角色上有相當多重疊的地方

460
00:45:23,240 --> 00:45:26,040
請問要如何區分使用

461
00:45:26,040 --> 00:45:29,960
或者是否應該在某種程度上將本地化靠攏到格式樣式

462
00:45:29,960 --> 00:45:33,720
如果您對這方面有什麼想法，我想聽聽看

463
00:45:33,720 --> 00:45:36,280
好的，謝謝您

464
00:45:36,280 --> 00:45:42,040
我在中途介紹了不是用 VStack 的兩個文字，而是用一個文字的形式

465
00:45:42,040 --> 00:45:48,520
當想要使用本地化鍵 (Localized Key) 的時候

466
00:45:48,520 --> 00:45:52,280
使用那種寫法

467
00:45:52,280 --> 00:45:56,000
我認為這就是格式樣式 (Format Style) 的使用方式

468
00:45:56,000 --> 00:46:02,880
我覺得用格式樣式講 40 分鐘對我來說還蠻硬核的

469
00:46:02,880 --> 00:46:05,640
不過因為我喜歡格式樣式

470
00:46:05,640 --> 00:46:09,520
以我個人的見解來說，在可本地化 (Localizable) 的部分

471
00:46:09,520 --> 00:46:13,120
不包含格式這一側

472
00:46:13,120 --> 00:46:17,920
例如單位的處理或是配合地區的符號顯示

473
00:46:17,920 --> 00:46:20,840
交給格式樣式這一側來處理

474
00:46:20,840 --> 00:46:24,120
不寫在可本地化字串 (Localizable Strings) 裡

475
00:46:24,640 --> 00:46:25,760
我是這樣建議的

476
00:46:25,760 --> 00:46:28,920
平常在個人開發時也是這樣做的

477
00:46:28,920 --> 00:46:32,200
謝謝您

478
00:46:32,200 --> 00:46:33,760
謝謝

479
00:46:33,760 --> 00:46:36,480
時間上看來下一個會是最後一個問題

480
00:46:36,480 --> 00:46:46,240
有意見或問題的人請舉手

481
00:46:46,240 --> 00:46:48,640
那麼時間到了

482
00:46:48,640 --> 00:46:53,160
問答環節到此結束

483
00:46:53,160 --> 00:46:57,240
接下來是一分鐘回饋時間

484
00:46:57,240 --> 00:47:00,200
一分鐘回饋時間

485
00:47:00,200 --> 00:47:02,720
請掃描螢幕上的 QR 碼

486
00:47:02,720 --> 00:47:04,720
傳送回饋

487
00:47:23,160 --> 00:47:34,080
感謝大家在午餐後這個很容易想睡的時間聆聽

488
00:47:34,080 --> 00:47:38,560
看到會議室座位坐滿了，真的很感動
