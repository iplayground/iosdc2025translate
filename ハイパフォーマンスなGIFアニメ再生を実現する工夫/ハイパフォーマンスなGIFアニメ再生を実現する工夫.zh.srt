1
00:00:06,433 --> 00:00:09,933
好的。那麼感謝各位今天的蒞臨

2
00:00:09,933 --> 00:00:13,933
今天我要以「實現高效能字幕動畫播放的技巧」

3
00:00:13,933 --> 00:00:16,933
這個主題來進行分享

4
00:00:16,933 --> 00:00:20,933
投影片為了讓大家更容易閱讀，是用英文標示的

5
00:00:20,933 --> 00:00:22,933
但演講會用日文進行

6
00:00:22,933 --> 00:00:28,399
這次的發表會介紹在實際的 iOS 應用程式開發中所面臨的效能課題

7
00:00:28,399 --> 00:00:33,433
以及其解決方案，並搭配具體的案例來說明

8
00:00:34,133 --> 00:00:35,700
首先請讓我自我介紹

9
00:00:35,700 --> 00:00:37,100
我叫 Noppe

10
00:00:37,100 --> 00:00:39,799
我以這個狐狸大頭貼在社群活動

11
00:00:39,799 --> 00:00:46,233
真沒想到，從2018年開始，我每年都在 iOSDC 上台演講

12
00:00:46,233 --> 00:00:49,866
我想這都是託各位前來聆聽的福

13
00:00:49,866 --> 00:00:53,166
今年已經是連續第 8 年上台了

14
00:00:53,166 --> 00:00:57,433
平常我在 DeNA 這家公司開發 iOS 應用程式

15
00:00:57,433 --> 00:01:00,566
作為我個人興趣，自己也有在做些App

16
00:01:00,566 --> 00:01:03,233
今天要介紹的App

17
00:01:03,233 --> 00:01:06,099
叫做 DAWN for Mastodon

18
00:01:06,099 --> 00:01:11,333
這個DAWN for Mastodon也是我個人開發的應用程式專案之一

19
00:01:11,333 --> 00:01:16,933
希望能透過這個應用程式的開發，與各位分享我所獲得的知識

20
00:01:18,400 --> 00:01:25,400
我在 2023 年開發的應用程式叫做 DAWN for Mastodon

21
00:01:25,400 --> 00:01:30,933
如同其名，這是一個為 Mastodon 這個社群網站所開發的 app

22
00:01:30,933 --> 00:01:34,933
Mastodon 可能還沒有廣泛普及

23
00:01:34,933 --> 00:01:38,933
但這個 app 的目標是讓任何人都能舒適地使用 Mastodon

24
00:01:38,933 --> 00:01:44,933
所以我想盡可能地開發一個相對普通好用的App給大家使用

25
00:01:44,933 --> 00:01:47,933
也就是說，Mastodon 的特殊性

26
00:01:47,933 --> 00:01:51,933
要透過 UI 設計與工程技術來一般化

27
00:01:51,933 --> 00:01:54,299
這就是這個應用程式的目標

28
00:01:54,299 --> 00:01:59,133
特別重視的是反應 (Reaction) 等溝通功能

29
00:01:59,133 --> 00:02:03,133
以及流暢的時間軸 (Timeline) 捲動體驗

30
00:02:04,466 --> 00:02:09,466
題外話，前陣子為了支持 iOS 26

31
00:02:09,466 --> 00:02:12,466
以及導入 Image Playground 的關係

32
00:02:12,466 --> 00:02:15,166
上了 AppStore 的 Feature

33
00:02:15,166 --> 00:02:17,466
真的很開心

34
00:02:17,466 --> 00:02:20,466
謝謝大家

35
00:02:20,866 --> 00:02:27,866
為了提供新穎設計體驗的充滿魅力的 app ，作為開發者，我今後也將如此努力

36
00:02:28,533 --> 00:02:33,533
順帶一問，使用 Mastodon 的人有多少呢？

37
00:02:33,533 --> 00:02:34,533
有一些

38
00:02:34,533 --> 00:02:36,533
聽過的人有嗎？

39
00:02:36,533 --> 00:02:38,533
有超過一半的人

40
00:02:38,533 --> 00:02:42,000
為了不認識 Mastodon 的人，我簡單說明一下

41
00:02:42,000 --> 00:02:49,066
Mastodon 是 2016 年由德國的 Eugen 先生所開發的 SNS 開源軟體

42
00:02:49,066 --> 00:02:53,333
是用 Ruby on Rails 寫的

43
00:02:53,333 --> 00:02:58,533
但這個 Mastodon 並不是指特定的服務

44
00:02:58,533 --> 00:03:02,733
企業或個人將 Mastodon 部署到自己的伺服器後

45
00:03:02,733 --> 00:03:07,833
Mastodon 就會在那個伺服器中啟動

46
00:03:07,833 --> 00:03:11,199
然後在那個伺服器中註冊帳號等等

47
00:03:11,199 --> 00:03:15,199
也就是說，能在自己的伺服器中運營 SNS

48
00:03:15,199 --> 00:03:18,199
這就是 Mastodon 能做到的事

49
00:03:18,199 --> 00:03:23,533
這就是所謂的分散式社群網路平台 (Decentralized Social Network Platform)

50
00:03:23,533 --> 00:03:29,533
特色在於個人架設的伺服器之間可以交換貼文

51
00:03:29,533 --> 00:03:34,533
其他伺服器的貼文也會顯示在時間軸上，我覺得這點很有趣

52
00:03:34,533 --> 00:03:38,066
所以使用者只要在任何一個伺服器建立帳號

53
00:03:38,066 --> 00:03:42,099
就能從那裡看到多個伺服器的貼文

54
00:03:42,099 --> 00:03:45,033
DAWN for Mastodon會連接到 Mastodon 伺服器

55
00:03:45,033 --> 00:03:49,833
提供能在 iPhone 上舒適使用的 UI

56
00:03:49,833 --> 00:03:53,133
目前像是 Instagram 的 Threads

57
00:03:53,133 --> 00:03:55,800
以及 Misskey 這個 SNS 也採用了相同的協定

58
00:03:55,800 --> 00:03:59,566
所以這些貼文也能從 Mastodon 看到

59
00:04:00,533 --> 00:04:03,566
接下來要進入正題了

60
00:04:03,566 --> 00:04:08,433
Mastodon 的特色功能之一是自訂表情符號

61
00:04:08,433 --> 00:04:12,533
Slack 和 Discord 也有類似的功能

62
00:04:12,533 --> 00:04:15,966
就是使用者可以註冊的表情符號集

63
00:04:15,966 --> 00:04:18,766
每個伺服器都有自己獨特的表情符號集

64
00:04:18,766 --> 00:04:21,100
檔案格式可能是 GIF

65
00:04:21,100 --> 00:04:24,533
或是 APNG、WebP、PNG 等等

66
00:04:24,533 --> 00:04:29,933
各種不同格式的表情符號都在流通

67
00:04:29,933 --> 00:04:34,533
這些表情符號可以包含在時間軸的貼文中

68
00:04:34,533 --> 00:04:36,533
來使用

69
00:04:36,533 --> 00:04:39,933
在部分伺服器中也能用來對貼文做出反應

70
00:04:39,933 --> 00:04:43,633
就像 Slack 那樣使用

71
00:04:43,633 --> 00:04:47,866
這意味著時間軸上可能會出現數十個表情符號

72
00:04:47,866 --> 00:04:51,533
而且還是 GIF 動畫滿溢的狀況

73
00:04:51,533 --> 00:04:54,500
這會閃爍，請小心觀看

74
00:04:54,500 --> 00:04:58,966
實際上同時播放數十個 GIF 動畫的情況

75
00:04:58,966 --> 00:05:01,533
在 Mastodon 中並不罕見

76
00:05:01,533 --> 00:05:05,366
這就是我所面臨的課題本質

77
00:05:06,733 --> 00:05:10,933
實際播放這麼大量的動畫表情符號時

78
00:05:10,933 --> 00:05:14,433
就會像這樣捲動變得相當卡頓

79
00:05:14,433 --> 00:05:19,833
上方也會出現記憶體不足的警告之類的

80
00:05:21,399 --> 00:05:22,433
捲動變得很卡

81
00:05:22,433 --> 00:05:26,933
而且記憶體使用率和 CPU 使用率都變得非常高

82
00:05:26,933 --> 00:05:28,833
裝置會變得非常燙

83
00:05:28,833 --> 00:05:32,800
一旦變燙，結果就是電池也會很快沒電

84
00:05:32,800 --> 00:05:38,133
變成了一個很難說是舒適體驗的狀況

85
00:05:38,133 --> 00:05:41,933
但是，在 DAWN 中我們已經解決了這個問題

86
00:05:41,933 --> 00:05:47,033
現在即使顯示大量的自訂表情符號，也不會大幅損失效能

87
00:05:47,033 --> 00:05:50,133
可以像這樣順暢地捲動

88
00:05:50,133 --> 00:05:55,166
今天我要介紹的是如何實現這些功能

89
00:05:57,133 --> 00:06:00,199
今天的內容大致分為兩個主題

90
00:06:00,199 --> 00:06:06,333
首先會簡單介紹一般方法如何播放 GIF 的方式

91
00:06:06,333 --> 00:06:10,966
第二個是 DAWN 所使用的邏輯

92
00:06:10,966 --> 00:06:17,133
以及如何應對在那裡發生的效能問題

93
00:06:17,133 --> 00:06:21,233
那麼我們依序來看吧

94
00:06:21,233 --> 00:06:28,466
首先讓我們回顧一下使用 UIKit 播放 GIF 的一般方法

95
00:06:31,333 --> 00:06:34,866
我想應該有很多人看過這段程式碼

96
00:06:34,866 --> 00:06:40,633
就像這樣，像平常一樣從檔案建立 UIImage 並放入 UIImageView 中

97
00:06:40,633 --> 00:06:45,733
簡單說明一下，這裡讀取了一個叫 sample.gif 的檔案

98
00:06:45,733 --> 00:06:49,633
將它轉換成 UIImage 並用 UIImageView 顯示，就是這樣

99
00:06:49,633 --> 00:06:54,333
執行這段程式碼會變成這樣

100
00:06:54,333 --> 00:07:00,166
雖然圖片有顯示出來，但並不會播放動畫

101
00:07:00,166 --> 00:07:05,366
所以為了讓它動起來，讓我們回顧一下 GIF 檔案的結構

102
00:07:07,699 --> 00:07:11,199
這裡有一隻大象在走路

103
00:07:11,199 --> 00:07:17,866
GIF 就像這張投影片所示，是一個包含多個影格圖片的檔案

104
00:07:17,866 --> 00:07:24,266
也就是說，可以把它想成是一個包含多個影格圖片的檔案

105
00:07:24,266 --> 00:07:34,266
也就是說，透過取出 GIF 所擁有的所有影格圖片並依序顯示，就能實現動畫效果

106
00:07:34,266 --> 00:07:39,366
就是翻頁動畫的概念

107
00:07:39,366 --> 00:07:44,366
要實現這個機制，首先需要取出影格圖片

108
00:07:44,366 --> 00:07:49,833
實際上是透過使用 Core Graphics 框架中的 CGImageSource

109
00:07:49,833 --> 00:07:59,100
就可以輕鬆存取圖片資料的中繼資料 (metadata) 以及其他圖片資料

110
00:07:59,100 --> 00:08:03,199
透過這個方式，可以取得 GIF 所擁有的影格圖片數量

111
00:08:03,199 --> 00:08:11,833
以及每個影格圖片的顯示時間等資訊

112
00:08:11,833 --> 00:08:18,699
與 GIF 結構類似的檔案格式，還有剛才提到的 APNG 或 WebP 等格式

113
00:08:18,699 --> 00:08:22,166
CGImageSource 其實也支援這些格式

114
00:08:22,166 --> 00:08:29,066
所以幾乎不需要在意檔案類型，就能用相同的程式碼從中取出影格圖片

115
00:08:29,066 --> 00:08:33,833
這樣就能將所有影格圖片轉換成 UIImage 了

116
00:08:40,033 --> 00:08:44,233
接著將建立好的 UIImage 陣列設定到 UIImageView 中

117
00:08:44,233 --> 00:08:50,233
其實從很久以前UIImageView 就有一個叫 animationImages 的屬性

118
00:08:50,233 --> 00:08:56,266
只要將 UIImage 的陣列設定到這裡，就可以開始播放動畫

119
00:08:56,766 --> 00:09:03,533
實際上設定好之後，呼叫 startAnimating 這個方法，就會有以下的行為

120
00:09:05,233 --> 00:09:08,833
這樣 GIF 動畫就播放了

121
00:09:09,666 --> 00:09:11,899
如果只是要播放的話，這樣就可以了

122
00:09:11,899 --> 00:09:14,833
但這次的主題是效能調校 (performance tuning)

123
00:09:14,833 --> 00:09:18,833
也就是說，這個方法其實有一個相當大的問題

124
00:09:21,433 --> 00:09:27,233
記憶體使用量會呈指數性增加，導致應用程式當機的問題

125
00:09:27,233 --> 00:09:36,366
實際測量後發現，剛才那個大象走路的 GIF 圖片，一個檔案大約是 340 KB

126
00:09:37,033 --> 00:09:41,966
但播放一個 GIF 大約會消耗 25 MB 的記憶體

127
00:09:41,966 --> 00:09:49,733
25 MB 是多少呢？大約是一張 8K 高解析度 JPEG 圖片的大小

128
00:09:49,733 --> 00:09:52,799
所以佔用了相當大量的記憶體

129
00:09:52,799 --> 00:10:00,166
像剛才 Mastodon 那樣顯示大量GIF的話，可以想像結果當然不會好

130
00:10:00,166 --> 00:10:05,333
25MB 這個記憶體使用量是從哪裡來的呢？

131
00:10:07,333 --> 00:10:12,433
記憶體使用量在一般 8 位元 ARGB 圖片的情況下

132
00:10:12,433 --> 00:10:19,533
可以用 m = w × h × c × n 這個公式來計算

133
00:10:19,533 --> 00:10:21,733
這完全不是什麼困難的公式

134
00:10:21,733 --> 00:10:26,033
w 是橫向像素數，h 是縱向像素數

135
00:10:26,033 --> 00:10:28,933
c 是每個像素的色彩成分數量

136
00:10:28,933 --> 00:10:33,466
如果是 ARGB 的話就是 4。也就是 4 個 8 位元排列在一起

137
00:10:33,466 --> 00:10:37,566
n 就是 GIF 的影格數

138
00:10:37,566 --> 00:10:41,566
這個例子是 34 影格的 GIF

139
00:10:41,566 --> 00:10:44,533
大概計算一下就是 25MB 左右

140
00:10:44,833 --> 00:10:49,700
所以，剛才的實作方式顯示 34 影格的 GIF 就意味著

141
00:10:49,700 --> 00:10:54,799
要把 34 張未壓縮的圖片全部展開在記憶體中

142
00:10:54,799 --> 00:10:59,100
所以，影格數越多、解析度越高

143
00:10:59,100 --> 00:11:01,533
記憶體使用量就會增加

144
00:11:03,933 --> 00:11:08,266
這樣下去如果有多個 GIF 就會馬上記憶體不足

145
00:11:08,266 --> 00:11:14,933
效能調校的必要性就變得很明確了

146
00:11:14,933 --> 00:11:17,633
不過話雖如此說到效能調校

147
00:11:17,633 --> 00:11:19,933
到底該做什麼呢？

148
00:11:19,933 --> 00:11:22,933
例如這次的情況，減少記憶體使用量

149
00:11:22,933 --> 00:11:27,600
是不是真正的目的？我想再思考一次

150
00:11:27,600 --> 00:11:30,033
我在進行效能調校時

151
00:11:30,033 --> 00:11:35,200
認為首先思考什麼是重要的這件事很重要

152
00:11:35,200 --> 00:11:40,533
今天我想介紹一下我平常使用的效能調校方法

153
00:11:42,666 --> 00:11:47,666
首先最重要的是從使用者體驗來思考

154
00:11:47,666 --> 00:11:50,666
思考使用者感到什麼不便

155
00:11:50,666 --> 00:11:52,666
也有去聽取使用者的意見

156
00:11:52,666 --> 00:11:57,666
比起技術指標，例如剛才說的記憶體用了很多這種事

157
00:11:57,666 --> 00:12:00,666
從實際上使用者困擾的是什麼這個角度

158
00:12:00,666 --> 00:12:03,366
開始思考是很重要的

159
00:12:04,666 --> 00:12:09,466
其次重要的是明確定義 app 提供的核心價值

160
00:12:09,466 --> 00:12:14,033
例如天氣 app 的話，能快速確認天氣很重要

161
00:12:14,033 --> 00:12:16,666
購物 App 的話，能輕鬆找到想要的商品

162
00:12:16,666 --> 00:12:18,666
這點就很重要

163
00:12:19,666 --> 00:12:22,566
像這樣定義應用程式的核心價值

164
00:12:22,566 --> 00:12:26,866
在效能調校時就容易設定優先順序

165
00:12:28,333 --> 00:12:31,933
第三點是盡可能用數值來測量

166
00:12:31,933 --> 00:12:35,933
例如記憶體使用量、CPU 使用率、影格率等

167
00:12:35,933 --> 00:12:40,333
測量這些與應用程式效能相關的指標

168
00:12:40,333 --> 00:12:43,766
這樣一來就能更容易找出問題所在

169
00:12:43,766 --> 00:12:47,799
當做了某些變更時，也能判斷那是好的變更還是壞的變更

170
00:12:47,799 --> 00:12:51,366
能夠定量地評估這些地方

171
00:12:52,766 --> 00:12:58,399
跟這個有關，這裡我要介紹一個 Instruments 的便利用法

172
00:12:58,399 --> 00:13:02,933
在做效能調校時如果執行整個應用程式

173
00:13:02,933 --> 00:13:04,333
會出現整個應用程式的處理程序

174
00:13:04,333 --> 00:13:08,333
分析會變得非常困難

175
00:13:08,333 --> 00:13:11,366
但有方法可以只分析特定的測試

176
00:13:11,366 --> 00:13:15,933
在測試的地方像這樣對菱形標記按右鍵

177
00:13:15,933 --> 00:13:20,933
就可以只執行該測試的分析 (Profile)

178
00:13:20,933 --> 00:13:23,500
使用這個方法就能輕鬆測量

179
00:13:23,500 --> 00:13:26,366
特定功能的效能

180
00:13:28,733 --> 00:13:32,433
最後重要的是，效能調校

181
00:13:32,433 --> 00:13:36,399
最終往往會變成取捨 (trade-off) 的難題

182
00:13:36,399 --> 00:13:40,066
當然如果能無條件讓處理變快就很好

183
00:13:40,066 --> 00:13:43,933
但深入探討下去，往往會變成降低不重要事物的品質

184
00:13:43,933 --> 00:13:48,933
來提升重要事物品質的討論

185
00:13:48,933 --> 00:13:51,933
這時候以剛才說的使用者體驗

186
00:13:51,933 --> 00:13:55,933
或應用程式的核心價值是什麼為軸心

187
00:13:55,933 --> 00:13:59,299
就能比較容易做出取捨選擇

188
00:13:59,299 --> 00:14:02,933
所以結論是，不管記憶體或 CPU 用了多少

189
00:14:02,933 --> 00:14:06,299
如果使用者完全不會感到不滿的話就沒有問題

190
00:14:06,299 --> 00:14:09,933
這樣的取捨方式也是可以的

191
00:14:09,933 --> 00:14:14,266
雖然會想解決看得見的效能問題

192
00:14:14,266 --> 00:14:17,466
但如果思考修正後誰會高興這個問題

193
00:14:17,466 --> 00:14:20,600
就比較容易設定優先順序

194
00:14:21,399 --> 00:14:24,233
那麼在 DAWN 中什麼是重要的呢？

195
00:14:24,233 --> 00:14:26,799
DAWN 作為一個社交 app

196
00:14:26,799 --> 00:14:28,933
透過 emoji 反應進行溝通

197
00:14:28,933 --> 00:14:31,399
是其重要的價值

198
00:14:31,399 --> 00:14:35,766
而且使用者大部分時間都在滑動頁面

199
00:14:35,766 --> 00:14:37,933
這時候如果時間軸的滑動卡頓

200
00:14:37,933 --> 00:14:40,200
就會變成很糟的體驗

201
00:14:40,200 --> 00:14:42,933
因此即使顯示大量的 emoji

202
00:14:42,933 --> 00:14:46,933
不影響滑動是最重要的

203
00:14:47,399 --> 00:14:50,366
另一方面，在能理解脈絡的地方

204
00:14:50,366 --> 00:14:52,633
emoji 每個影格的畫質

205
00:14:52,633 --> 00:14:56,700
或影格率可以稍微犧牲也沒關係

206
00:14:56,700 --> 00:14:58,933
幸運的是犧牲這些的話

207
00:14:58,933 --> 00:15:00,633
記憶體使用量和 CPU 使用率

208
00:15:00,633 --> 00:15:06,133
安定的大幅減少，應用程式也能更加穩定，當然發熱和電池續航也都會改善

209
00:15:08,533 --> 00:15:10,100
關於捲動時的卡頓

210
00:15:10,100 --> 00:15:13,500
用 Instruments 的 Animation Hitches 來確認會比較清楚

211
00:15:13,733 --> 00:15:17,299
Animation Hitch 可以從發生卡頓的位置的主執行緒處理

212
00:15:17,299 --> 00:15:20,100
找出是什麼原因造成的卡頓

213
00:15:20,100 --> 00:15:24,100
這次不會在這個演講中詳細說明 Instruments 的使用方法

214
00:15:24,100 --> 00:15:28,700
如果對這部分有興趣的話，可以在演講結束後詢問

215
00:15:29,366 --> 00:15:33,700
而且在 WWDC 也有很多場演講介紹，請務必活用看看

216
00:15:34,700 --> 00:15:36,700
感覺時間有點不妙呢

217
00:15:36,700 --> 00:15:38,700
還沒進入正題

218
00:15:40,700 --> 00:15:45,700
這次要談的是以 AnimatedImage 這個開源專案公開發布的

219
00:15:45,700 --> 00:15:47,700
來看看這裡的實作吧

220
00:15:48,333 --> 00:15:53,266
從 AnimatedImage 整體的大流程來看

221
00:15:53,266 --> 00:15:58,000
它分成了 View 和 ImageProvider，也就是左邊這個和右邊這個

222
00:15:58,000 --> 00:16:02,066
ImageProvider 擁有用於圖像最佳化的 ImageProcessor

223
00:16:02,066 --> 00:16:06,233
以及儲存最佳化後圖像的快取

224
00:16:07,700 --> 00:16:11,899
View 和 ImageProvider 大致上有兩個任務

225
00:16:11,899 --> 00:16:15,966
第一個是確認目前要顯示的圖像是否存在於快取中

226
00:16:15,966 --> 00:16:18,233
如果存在就顯示它

227
00:16:18,233 --> 00:16:20,700
第二個是當 View 的大小等改變時

228
00:16:20,700 --> 00:16:25,700
要求 ImageProvider 產生最佳化後的圖像

229
00:16:26,700 --> 00:16:30,700
透過這樣做，View 就能一直顯示最佳化後的圖像

230
00:16:30,700 --> 00:16:35,000
使用快取是因為 GIF 有重複播放的特性

231
00:16:35,000 --> 00:16:40,700
為了因應這個性質，必須多次顯示相同的圖像，所以才使用快取

232
00:16:42,533 --> 00:16:44,133
詳細來說

233
00:16:44,133 --> 00:16:48,266
首先是確認目前要顯示的圖像是否存在於快取中

234
00:16:48,266 --> 00:16:52,000
如果存在就顯示這部分的處理

235
00:16:52,000 --> 00:16:54,700
View 使用 UpdateLink 這個計時器

236
00:16:54,700 --> 00:16:59,399
以 60fps 配合畫面更新時機來檢查快取

237
00:16:59,399 --> 00:17:02,700
如果快取中有影格圖像，就將圖像回傳給 View

238
00:17:02,700 --> 00:17:04,400
並在 View 上繪製

239
00:17:04,400 --> 00:17:07,833
乍看之下感覺每一影格都在處理，很浪費

240
00:17:07,833 --> 00:17:11,700
但這個機制的好處是可以根據 ImageProvider 是否回傳圖像

241
00:17:11,700 --> 00:17:15,200
來控制 View 的繪製，這是很好的優點

242
00:17:15,200 --> 00:17:19,700
因此可以跳過重複的影格圖像

243
00:17:19,700 --> 00:17:23,566
或是降低影格率，這些都能輕易做到

244
00:17:23,566 --> 00:17:26,400
所以當沒有影格圖像時，就只需要做

245
00:17:26,400 --> 00:17:29,500
將時間戳記轉換為索引這種程度的處理，因此很輕量

246
00:17:32,166 --> 00:17:33,700
跳過這部分

247
00:17:33,700 --> 00:17:36,700
剛才說的 UpdateLink

248
00:17:36,700 --> 00:17:40,966
內部實作是使用 UI UpdateLink 這個類別

249
00:17:40,966 --> 00:17:43,933
UI UpdateLink 能夠配合圖像的顯示時機

250
00:17:43,933 --> 00:17:46,866
執行動作，這是 iOS 17 的功能

251
00:17:46,866 --> 00:17:49,700
與基於時間經過的計時器不同

252
00:17:49,700 --> 00:17:52,533
它能與繪製時機同步

253
00:17:52,533 --> 00:17:55,900
因此每次處理的有效時間都能穩定確保

254
00:17:58,400 --> 00:18:01,799
接著來看看 ImageProvider 的內部結構

255
00:18:01,799 --> 00:18:03,700
如同剛才介紹的，ImageProvider 擁有

256
00:18:03,700 --> 00:18:06,700
ImageProcessor 和快取

257
00:18:06,700 --> 00:18:09,700
ImageProcessor 會最佳化影格圖像

258
00:18:09,700 --> 00:18:11,466
並存入快取

259
00:18:11,466 --> 00:18:15,666
快取是以 NSCache 實作的，利用它是執行緒安全的特性

260
00:18:15,666 --> 00:18:25,700
來支援 ImageProcessor 的儲存處理以及取出來給 View 等這兩個執行緒的處理

261
00:18:25,700 --> 00:18:29,133
來看看 ImageProcessor 的實作吧

262
00:18:29,700 --> 00:18:32,700
ImageProcessor 做了四件事

263
00:18:32,700 --> 00:18:35,000
第一件是從圖像中取出影格圖像

264
00:18:35,000 --> 00:18:37,400
以及調整影格圖像的大小

265
00:18:37,400 --> 00:18:40,700
以及對影格進行抽樣

266
00:18:40,700 --> 00:18:44,233
最後是進行渲染這些作業

267
00:18:45,566 --> 00:18:47,533
首先是調整大小

268
00:18:47,533 --> 00:18:50,700
調整大小是因為如果影格圖像的尺寸太大

269
00:18:50,700 --> 00:18:52,266
記憶體使用量會增加

270
00:18:52,266 --> 00:18:56,000
所以要配合 View 顯示的大小來調整圖像尺寸

271
00:18:56,700 --> 00:18:59,700
因此，將超過顯示所需的大小的圖像

272
00:18:59,700 --> 00:19:01,366
存在記憶體中是很浪費的

273
00:19:01,366 --> 00:19:03,700
所以要調整到實際圖像渲染的大小

274
00:19:03,700 --> 00:19:05,900
縮小到合適尺寸

275
00:19:05,900 --> 00:19:08,700
調整大小的處理成本很高

276
00:19:08,700 --> 00:19:11,700
所以這裡只決定調整後的尺寸

277
00:19:11,700 --> 00:19:13,533
然後進入下一個流程

278
00:19:14,700 --> 00:19:19,166
接下來是抽樣繪製影格的作業

279
00:19:19,166 --> 00:19:24,500
此時已經可以計算解碼所有影格所需的記憶體使用量

280
00:19:24,500 --> 00:19:27,566
如果太大，就會抽樣影格來調整

281
00:19:27,566 --> 00:19:33,266
例如每秒 10 影格的 GIF 需要 10MB 記憶體來快取的情況下

282
00:19:33,266 --> 00:19:35,500
如果想要壓到 5MB

283
00:19:35,500 --> 00:19:38,166
把影格數減半就可以了

284
00:19:39,299 --> 00:19:42,700
不過即使把相同的影格數減半

285
00:19:42,700 --> 00:19:43,700
保留哪些影格

286
00:19:43,700 --> 00:19:45,766
會影響動畫的流暢度

287
00:19:45,766 --> 00:19:49,466
這兩個影片都是把影格數減半的版本

288
00:19:49,466 --> 00:19:51,700
但抽樣方式不同

289
00:19:51,700 --> 00:19:57,200
左邊是簡單地跳過後半的影格

290
00:19:57,200 --> 00:20:00,700
右邊是均勻抽樣的版本

291
00:20:00,700 --> 00:20:06,133
透過這樣做，動畫的卡頓現象就能被有效抑制

292
00:20:07,299 --> 00:20:10,366
雖然在測量上的效能數據並沒有改變

293
00:20:10,366 --> 00:20:15,599
但改善這種體感上的效能也是很重要的工夫

294
00:20:16,966 --> 00:20:22,799
實際調整的樣子就是這樣，畫面下方的滑桿是 Integrity 這個參數

295
00:20:22,799 --> 00:20:27,533
1 是原始的影格數，0 是最低限度的影格數

296
00:20:28,266 --> 00:20:33,733
即使調整 Integrity，也只是影格率在變化而已

297
00:20:33,733 --> 00:20:39,200
無論取什麼值，都能維持動畫的連續性

298
00:20:40,733 --> 00:20:42,733
最後是渲染 (Rendering)

299
00:20:42,733 --> 00:20:46,733
在前面的工程中已經決定了影格圖像的大小和影格數

300
00:20:46,733 --> 00:20:50,733
接下來就實際渲染影格圖像

301
00:20:51,733 --> 00:20:54,233
這裡有一個問題

302
00:20:54,500 --> 00:20:59,333
對於比原本顯示尺寸還小、不需要調整大小的影格圖像

303
00:20:59,333 --> 00:21:03,333
是否也必須渲染每一個影格呢？

304
00:21:03,333 --> 00:21:06,333
答案其實是肯定的

305
00:21:06,333 --> 00:21:08,333
原因如下

306
00:21:08,333 --> 00:21:13,333
當從 CGImageSource 取出的影格圖像以 UIImage 顯示時

307
00:21:14,033 --> 00:21:18,200
實際上會發生 DGifDecompress (解壓縮) 的處理

308
00:21:18,200 --> 00:21:24,433
這是因為從 CGImageSource 取出的 GIF 的 CGImage 其實一開始是被壓縮的

309
00:21:24,666 --> 00:21:27,433
無法直接進行繪製

310
00:21:27,433 --> 00:21:34,433
在預設的行為下，UIImage 會將還原影格的處理延遲到繪製的前一刻

311
00:21:34,433 --> 00:21:39,433
這樣一來，這個繁重的還原處理就會在主執行緒上執行

312
00:21:39,433 --> 00:21:43,433
這麼做會導致捲動時的卡頓

313
00:21:44,666 --> 00:21:50,400
為了解決這個問題，需要事先在背景執行緒還原影格

314
00:21:50,400 --> 00:21:57,433
UIImage 的情況下，可以使用 byPreparingForDisplay 方法在任意時機還原影格

315
00:21:57,433 --> 00:22:00,433
CGImage 的情況下，只要繪製到 CGContext

316
00:22:00,433 --> 00:22:04,833
就能在那個時間點取得已還原影格的 CGImage

317
00:22:04,833 --> 00:22:08,433
兩者都可以非同步呼叫

318
00:22:09,133 --> 00:22:13,266
在背景執行緒上執行並事先處理好

319
00:22:13,266 --> 00:22:19,299
就能防止在顯示到畫面的瞬間執行繁重處理而導致捲動卡頓

320
00:22:20,433 --> 00:22:23,066
實施這些最佳化之後

321
00:22:23,066 --> 00:22:26,666
即使在一個畫面上顯示超過 50 個動畫圖像也不會閃退

322
00:22:26,666 --> 00:22:30,866
記憶體使用量也能控制在 100MB 以下

323
00:22:30,866 --> 00:22:34,433
而且最重要的捲動流暢度也能維持

324
00:22:34,433 --> 00:22:38,933
另一方面，View 的顯示和動畫顯示之間會產生些微延遲

325
00:22:38,933 --> 00:22:41,799
影格率和解析度也會降低

326
00:22:41,799 --> 00:22:44,766
這些都是取捨 (Trade-off) 的結果

327
00:22:44,766 --> 00:22:50,433
在 AnimatedImage 中可以調整取捨的參數

328
00:22:50,433 --> 00:22:53,700
讓 GIF 描繪品質能夠被控制

329
00:22:55,066 --> 00:22:58,633
以上就是全部內容，今天介紹的 AnimatedImage

330
00:22:58,633 --> 00:23:03,433
以及 DAWN for Mastodon 主要功能超過 30 個，都以開源軟體的形式公開

331
00:23:03,433 --> 00:23:07,500
如果可以的話，也請看看這些其他的開源軟體

332
00:23:07,500 --> 00:23:12,733
在製作這次演講的過程中，也發現了還有很多最佳化的空間

333
00:23:12,733 --> 00:23:15,566
今後也會持續改善

334
00:23:15,566 --> 00:23:19,633
請務必用AnimatedImage看看，如果能給我些回饋的話我會很開心

335
00:23:19,633 --> 00:23:24,133
關於這次登場的 WebP 本身的詳細規格

336
00:23:24,133 --> 00:23:28,133
請觀看下午岸川先生的「製作並學習 WebP 入門」

337
00:23:28,133 --> 00:23:30,766
應該能加深各位的理解

338
00:23:30,766 --> 00:23:34,433
今天的演講就到這裡。感謝聆聽

339
00:23:42,066 --> 00:23:43,433
(主持) 感謝您的發表

340
00:23:43,433 --> 00:23:45,900
接下來進入問答時間

341
00:23:45,900 --> 00:23:49,433
有意見或問題的人請舉手告知

342
00:23:54,500 --> 00:23:58,333
因為沒有人有問題

343
00:24:00,400 --> 00:24:03,666
時間到了就結束問答環節

344
00:24:03,666 --> 00:24:06,433
接下來是一分鐘回饋時間

345
00:24:06,933 --> 00:24:23,033
翻譯：Lihsuan Chen
校稿：dsxsxsxs

