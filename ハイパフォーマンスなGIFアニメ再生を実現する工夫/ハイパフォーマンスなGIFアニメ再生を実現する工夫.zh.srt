1
00:00:06,500 --> 00:00:10,000
好的。那麼感謝各位今天的蒞臨

2
00:00:10,000 --> 00:00:14,000
今天我要以「實現高效能字幕動畫播放的技巧」

3
00:00:14,000 --> 00:00:17,000
這個主題來進行分享

4
00:00:17,000 --> 00:00:21,000
投影片為了讓大家更容易閱讀，是用英文標示的

5
00:00:21,000 --> 00:00:23,000
但演講會用日文進行

6
00:00:23,000 --> 00:00:28,000
這次的發表會介紹在實際的 iOS 應用程式開發中所面臨的效能課題

7
00:00:28,000 --> 00:00:33,503
以及其解決方案，並搭配具體的案例來說明

8
00:00:34,216 --> 00:00:36,054
首先請讓我自我介紹

9
00:00:36,256 --> 00:00:37,179
我叫 Noppe

10
00:00:37,182 --> 00:00:39,655
我以這個狐狸大頭貼在社群活動

11
00:00:39,871 --> 00:00:46,295
真沒想到，從2018年開始，我每年都在 iOSDC 上台演講

12
00:00:46,298 --> 00:00:49,000
我想這都是託各位前來聆聽的福

13
00:00:50,140 --> 00:00:53,015
今年已經是連續第 8 年上台了

14
00:00:53,231 --> 00:00:57,000
平常我在 DeNA 這家公司開發 iOS 應用程式

15
00:00:58,000 --> 00:01:01,000
作為我個人興趣，自己也有在做些App

16
00:01:01,000 --> 00:01:04,000
今天要介紹的App

17
00:01:04,000 --> 00:01:07,000
叫做 DAWN for Mastodon

18
00:01:07,000 --> 00:01:12,000
這個DAWN for Mastodon也是我個人開發的應用程式專案之一

19
00:01:12,000 --> 00:01:17,000
希望能透過這個應用程式的開發，與各位分享我所獲得的知識

20
00:01:19,000 --> 00:01:26,000
我在 2023 年開發的應用程式叫做DAWN for Mastodon

21
00:01:26,000 --> 00:01:31,000
如同其名，這是一個為 Mastodon 這個社群網站 (SNS) 設計的App

22
00:01:31,000 --> 00:01:35,000
Mastodon 可能還沒有廣泛普及

23
00:01:35,000 --> 00:01:39,000
但這個App的目標是讓任何人都能舒適地使用 Mastodon

24
00:01:39,000 --> 00:01:45,000
所以我想盡可能地開發一個相對普通好用的App給大家使用

25
00:01:45,000 --> 00:01:48,000
也就是說，Mastodon 的特殊性

26
00:01:48,000 --> 00:01:52,000
要透過 UI 設計與工程技術來一般化

27
00:01:52,000 --> 00:01:55,000
這就是這個應用程式的目標

28
00:01:55,000 --> 00:02:00,000
特別重視的是反應 (Reaction) 等溝通功能

29
00:02:00,000 --> 00:02:05,000
以及流暢的時間軸 (Timeline) 捲動體驗

30
00:02:05,000 --> 00:02:10,000
題外話，前陣子為了支持 iOS 26

31
00:02:10,000 --> 00:02:13,000
以及導入 Image Playground 的關係

32
00:02:13,000 --> 00:02:16,000
在 App Store 上獲得了推薦 (Feature)

33
00:02:16,000 --> 00:02:18,000
真的很開心

34
00:02:18,000 --> 00:02:21,000
謝謝大家

35
00:02:21,110 --> 00:02:28,360
為了提供新穎設計體驗的充滿魅力的App，我作為開發者今後也將如此努力

36
00:02:29,000 --> 00:02:34,000
順帶一問，使用 Mastodon 的人有多少呢？

37
00:02:34,000 --> 00:02:35,000
有一些

38
00:02:35,000 --> 00:02:37,000
聽過的人有嗎？

39
00:02:37,000 --> 00:02:39,000
有超過一半的人

40
00:02:39,000 --> 00:02:43,000
為了不認識 Mastodon 的人，我簡單說明一下

41
00:02:43,000 --> 00:02:50,000
Mastodon 是 2016 年由德國的 Eugen 先生所開發的 SNS 開源軟體

42
00:02:50,000 --> 00:02:54,000
是用 Ruby on Rails 寫的

43
00:02:54,000 --> 00:02:59,000
但這個 Mastodon 並不是指特定的服務

44
00:02:59,000 --> 00:03:03,000
企業或個人將 Mastodon 部署到自己的伺服器後

45
00:03:03,000 --> 00:03:08,000
Mastodon 就會在那個伺服器中啟動

46
00:03:08,000 --> 00:03:11,419
然後在那個伺服器中註冊帳號等等

47
00:03:11,419 --> 00:03:16,000
也就是說，能在自己的伺服器中運營 SNS

48
00:03:16,000 --> 00:03:19,000
這就是 Mastodon 能做到的事

49
00:03:19,000 --> 00:03:24,000
這就是所謂的分散式社群網路平台 (Decentralized Social Network Platform)

50
00:03:24,000 --> 00:03:30,000
特色在於個人架設的伺服器之間可以交換貼文

51
00:03:30,000 --> 00:03:35,000
其他伺服器的貼文也會顯示在時間軸上，我覺得這點很有趣

52
00:03:35,000 --> 00:03:39,000
所以使用者只要在任何一個伺服器建立帳號

53
00:03:39,000 --> 00:03:43,000
就能從那裡看到多個伺服器的貼文

54
00:03:43,000 --> 00:03:46,000
DAWN for Mastodon會連接到 Mastodon 伺服器

55
00:03:46,000 --> 00:03:50,000
提供能在 iPhone 上舒適使用的 UI

56
00:03:50,000 --> 00:03:54,000
目前像是 Instagram 的 Threads

57
00:03:54,000 --> 00:03:57,000
以及 Misskey 這個 SNS 也採用了相同的協定

58
00:03:57,000 --> 00:04:01,000
所以這些貼文也能從 Mastodon 看到

59
00:04:01,000 --> 00:04:03,840
接下來要進入正題了

60
00:04:04,024 --> 00:04:10,000
Mastodon 的特色功能之一是自訂表情符號 (Custom Emoji)

61
00:04:10,000 --> 00:04:13,000
Discord 也有類似的功能

62
00:04:13,000 --> 00:04:17,000
就是使用者可以註冊的表情符號集

63
00:04:17,000 --> 00:04:20,000
每個伺服器都有自己獨特的表情符號集

64
00:04:20,000 --> 00:04:22,000
檔案格式可能是 GIF

65
00:04:22,000 --> 00:04:25,000
或是 APNG、WebP、PNG 等等

66
00:04:25,000 --> 00:04:30,000
各種不同格式的表情符號都在流通

67
00:04:30,000 --> 00:04:35,000
這些表情符號可以包含在時間軸的貼文中

68
00:04:35,000 --> 00:04:37,000
來使用

69
00:04:37,000 --> 00:04:41,000
在部分伺服器中也能用來對貼文做出反應

70
00:04:41,000 --> 00:04:45,000
就像 Slack 那樣使用

71
00:04:45,000 --> 00:04:49,000
這意味著時間軸上可能會出現數十個表情符號

72
00:04:49,000 --> 00:04:52,000
而且還是 GIF 動畫滿溢的狀況

73
00:04:52,000 --> 00:04:56,000
這會閃爍，請小心觀看

74
00:04:56,000 --> 00:05:00,000
實際上同時播放數十個 GIF 動畫的情況

75
00:05:00,000 --> 00:05:01,000
在 Mastodon 中並不罕見

76
00:05:02,000 --> 00:05:05,199
這就是我所面臨的課題本質

77
00:05:07,199 --> 00:05:11,399
實際播放這麼大量的動畫表情符號時

78
00:05:11,399 --> 00:05:14,899
就會像這樣捲動變得相當卡頓

79
00:05:14,899 --> 00:05:20,300
上方也會出現記憶體不足的警告之類的

80
00:05:20,300 --> 00:05:22,899
捲動變得很卡

81
00:05:22,899 --> 00:05:27,199
而且記憶體使用率和 CPU 使用率都變得非常高

82
00:05:27,199 --> 00:05:29,300
裝置會變得非常燙

83
00:05:29,300 --> 00:05:33,100
一旦變燙，結果就是電池也會很快沒電

84
00:05:33,100 --> 00:05:38,600
變成了一個很難說是舒適體驗的狀況

85
00:05:38,600 --> 00:05:42,399
但是，在 Dawn 中我們已經解決了這個問題

86
00:05:42,399 --> 00:05:47,500
現在即使顯示大量的自訂表情符號，也不會大幅損失效能

87
00:05:47,500 --> 00:05:50,600
可以像這樣順暢地捲動

88
00:05:50,600 --> 00:05:57,000
今天我要介紹的是如何實現這些功能

89
00:05:58,000 --> 00:06:01,399
今天的內容大致分為兩個主題

90
00:06:01,399 --> 00:06:07,399
首先會簡單介紹一般方法如何播放 GIF 的方式

91
00:06:07,399 --> 00:06:11,899
第二個是 Mastodon 所使用的邏輯

92
00:06:11,899 --> 00:06:17,899
以及如何應對在那裡發生的效能問題

93
00:06:17,899 --> 00:06:22,100
那麼我們依序來看吧

94
00:06:22,199 --> 00:06:31,800
首先讓我們回顧一下使用 UIKit 播放 GIF 的一般方法

95
00:06:31,800 --> 00:06:35,800
我想應該有很多人看過這段程式碼

96
00:06:35,800 --> 00:06:41,600
就像這樣，像平常一樣從檔案建立 UIImage 並放入 UIImageView 中

97
00:06:41,600 --> 00:06:46,199
簡單說明一下，這裡讀取了一個叫 sample.gif 的檔案

98
00:06:46,199 --> 00:06:50,500
將它轉換成 UIImage 並用 UIImageView 顯示，就是這樣

99
00:06:50,500 --> 00:06:55,500
執行這段程式碼會變成這樣

100
00:06:55,500 --> 00:07:01,100
雖然圖片有顯示出來，但並不會播放動畫

101
00:07:01,100 --> 00:07:08,800
所以為了讓它動起來，讓我們回顧一下 GIF 檔案的結構

102
00:07:08,800 --> 00:07:11,899
這裡有一隻大象在走路

103
00:07:11,899 --> 00:07:19,000
GIF 就像這張投影片所示，是一個包含多個影格圖片的檔案

104
00:07:19,000 --> 00:07:25,399
也就是說，可以把它想成是一個包含多個影格圖片的檔案

105
00:07:25,399 --> 00:07:35,399
也就是說，透過取出 GIF 所擁有的所有影格圖片並依序顯示，就能實現動畫效果

106
00:07:35,399 --> 00:07:40,399
就是翻頁動畫的概念

107
00:07:40,399 --> 00:07:45,100
要實現這個機制，首先需要取出影格圖片

108
00:07:45,300 --> 00:07:50,699
使用 Core Graphics 框架中的 CGImageSource

109
00:07:50,699 --> 00:08:00,100
就可以輕鬆存取圖片資料的中繼資料 (metadata) 以及其他圖片資料

110
00:08:00,100 --> 00:08:04,100
透過這個方式，可以取得 GIF 所擁有的影格圖片數量

111
00:08:04,100 --> 00:08:12,300
以及每個影格圖片的顯示時間等資訊

112
00:08:12,300 --> 00:08:19,500
與 GIF 結構類似的檔案格式，還有剛才提到的 APNG 或 WebP 等格式

113
00:08:19,500 --> 00:08:23,300
CGImageSource 其實也支援這些格式

114
00:08:23,300 --> 00:08:29,899
所以幾乎不需要在意檔案類型，就能用相同的程式碼從中取出影格圖片

115
00:08:29,899 --> 00:08:40,500
這樣就能將所有影格圖片轉換成 UIImage 了

116
00:08:40,700 --> 00:08:45,100
接著將建立好的 UIImage 陣列設定到 UIImageView 中

117
00:08:45,100 --> 00:08:50,899
其實從很久以前UIImageView 就有一個叫 animationImages 的屬性

118
00:08:50,899 --> 00:08:57,500
只要將 UIImage 的陣列設定到這裡，就可以開始播放動畫

119
00:08:57,500 --> 00:09:05,899
實際上設定好之後，呼叫 startAnimating 這個方法，就會有以下的行為

120
00:09:05,899 --> 00:09:09,500
這樣 GIF 動畫就播放了

121
00:09:10,100 --> 00:09:12,500
如果只是要播放的話，這樣就可以了

122
00:09:12,500 --> 00:09:15,500
但這次的主題是效能調校 (performance tuning)

123
00:09:15,500 --> 00:09:19,500
也就是說，這個方法其實有一個相當大的問題

124
00:09:21,899 --> 00:09:27,700
記憶體使用量會呈指數性增加，導致應用程式當機的問題

125
00:09:27,700 --> 00:09:37,298
實際測量後發現，剛才那個大象走路的 GIF 圖片，一個檔案大約是 340 KB

126
00:09:37,500 --> 00:09:43,298
但播放一個 GIF 大約會消耗 25 MB 的記憶體

127
00:09:43,298 --> 00:09:50,500
25 MB 是多少呢？大約是一張 8K 高解析度 JPEG 圖片的大小

128
00:09:50,500 --> 00:09:52,759
所以佔用了相當大量的記憶體

129
00:09:52,759 --> 00:10:00,500
像剛才 Mastodon 那樣顯示大量GIF的話，可以想像結果當然不會好

130
00:10:01,000 --> 00:10:05,798
25MB 這個記憶體使用量是從哪裡來的呢？

131
00:10:07,798 --> 00:10:12,899
記憶體使用量在一般 8 位元 ARGB 圖片的情況下

132
00:10:12,899 --> 00:10:20,000
可以用 m = w × h × c × n 這個公式來計算

133
00:10:20,000 --> 00:10:22,200
這完全不是什麼困難的公式

134
00:10:22,200 --> 00:10:26,500
w 是橫向像素數，h 是縱向像素數

135
00:10:26,500 --> 00:10:29,399
c 是每個像素的色彩成分數量

136
00:10:29,399 --> 00:10:34,399
如果是 ARGB 的話就是 4。也就是 4 個 8 位元排列在一起

137
00:10:34,399 --> 00:10:38,399
n 就是 GIF 的影格數

138
00:10:38,399 --> 00:10:42,399
這個例子是 34 影格的 GIF

139
00:10:42,399 --> 00:10:45,399
大概計算一下就是 25MB 左右

140
00:10:45,399 --> 00:10:50,399
所以，剛才的實作方式顯示 34 影格的 GIF 就意味著

141
00:10:50,399 --> 00:10:55,399
要把 34 張未壓縮的圖片全部展開在記憶體中

142
00:10:55,399 --> 00:10:59,399
所以，影格數越多、解析度越高

143
00:10:59,399 --> 00:11:04,399
記憶體使用量就會增加

144
00:11:04,399 --> 00:11:08,399
這樣下去如果有多個 GIF 就會馬上記憶體不足

145
00:11:08,399 --> 00:11:15,399
效能調校的必要性就變得很明確了

146
00:11:15,399 --> 00:11:18,399
不過話雖如此說到效能調校

147
00:11:18,399 --> 00:11:20,399
到底該做什麼呢？

148
00:11:20,399 --> 00:11:23,399
例如這次的情況，減少記憶體使用量

149
00:11:23,399 --> 00:11:28,399
是不是真正的目的？我想再思考一次

150
00:11:28,399 --> 00:11:30,399
我在進行效能調校時

151
00:11:30,399 --> 00:11:35,399
認為首先思考什麼是重要的這件事很重要

152
00:11:35,399 --> 00:11:43,399
今天我想介紹一下我平常使用的效能調校方法

153
00:11:43,399 --> 00:11:48,399
首先最重要的是從使用者體驗來思考

154
00:11:48,399 --> 00:11:51,399
思考使用者感到什麼不便

155
00:11:51,399 --> 00:11:53,399
也有去聽取使用者的意見

156
00:11:53,399 --> 00:11:58,399
比起技術指標，例如剛才說的記憶體用了很多這種事

157
00:11:58,399 --> 00:12:01,399
從實際上使用者困擾的是什麼這個角度

158
00:12:01,399 --> 00:12:05,399
開始思考是很重要的

159
00:12:05,399 --> 00:12:10,399
其次重要的是明確定義App提供的核心價值

160
00:12:10,399 --> 00:12:14,399
例如天氣 App 的話，能快速確認天氣很重要

161
00:12:14,399 --> 00:12:17,399
購物 App 的話，能輕鬆找到想要的商品

162
00:12:17,399 --> 00:12:19,399
這點就很重要

163
00:12:20,399 --> 00:12:23,399
像這樣定義應用程式的核心價值

164
00:12:23,399 --> 00:12:28,399
在效能調校時就容易設定優先順序

165
00:12:28,399 --> 00:12:32,399
第三點是盡可能用數值來測量

166
00:12:32,399 --> 00:12:36,399
例如記憶體使用量、CPU 使用率、影格率等

167
00:12:36,399 --> 00:12:40,399
測量這些與應用程式效能相關的指標

168
00:12:40,399 --> 00:12:44,399
這樣一來就能更容易找出問題所在

169
00:12:44,399 --> 00:12:48,399
當做了某些變更時，也能判斷那是好的變更還是壞的變更

170
00:12:48,399 --> 00:12:53,399
能夠定量地評估這些地方

171
00:12:53,399 --> 00:12:59,399
跟這個有關，這裡我要介紹一個 Instruments 的便利用法

172
00:12:59,399 --> 00:13:03,399
在做效能調校時如果執行整個應用程式

173
00:13:03,399 --> 00:13:05,399
會出現整個應用程式的處理程序

174
00:13:05,399 --> 00:13:08,399
分析會變得非常困難

175
00:13:08,399 --> 00:13:12,399
但有方法可以只分析特定的測試

176
00:13:12,399 --> 00:13:16,399
在測試的地方像這樣對菱形標記按右鍵

177
00:13:16,399 --> 00:13:21,399
就可以只執行該測試的分析 (Profile)

178
00:13:21,399 --> 00:13:24,399
使用這個方法就能輕鬆測量

179
00:13:24,399 --> 00:13:29,399
特定功能的效能

180
00:13:29,399 --> 00:13:33,399
最後重要的是，效能調校

181
00:13:33,399 --> 00:13:36,464
最終往往會變成取捨 (trade-off) 的難題

182
00:13:36,677 --> 00:13:40,399
當然如果能無條件讓處理變快就很好

183
00:13:40,399 --> 00:13:44,399
但深入探討下去，往往會變成降低不重要事物的品質

184
00:13:44,399 --> 00:13:49,399
來提升重要事物品質的討論

185
00:13:49,399 --> 00:13:52,399
這時候以剛才說的使用者體驗

186
00:13:52,399 --> 00:13:56,399
或應用程式的核心價值是什麼為軸心

187
00:13:56,399 --> 00:14:00,399
就能比較容易做出取捨選擇

188
00:14:00,399 --> 00:14:03,399
所以結論是，不管記憶體或 CPU 用了多少

189
00:14:03,399 --> 00:14:07,399
如果使用者完全不會感到不滿的話就沒有問題

190
00:14:07,399 --> 00:14:10,399
這樣的取捨方式也是可以的

191
00:14:10,399 --> 00:14:15,399
雖然會想解決看得見的效能問題

192
00:14:15,399 --> 00:14:18,399
但如果思考修正後誰會高興這個問題

193
00:14:18,399 --> 00:14:21,072
就比較容易設定優先順序

194
00:14:21,701 --> 00:14:25,399
那麼在 Dawn 中什麼是重要的呢？

195
00:14:25,399 --> 00:14:27,399
Dawn作為一個社群網站 (SNS) App

196
00:14:27,399 --> 00:14:29,399
透過 emoji 反應進行溝通

197
00:14:29,399 --> 00:14:32,399
是其重要的價值

198
00:14:32,399 --> 00:14:36,399
而且使用者大部分時間都在滑動頁面

199
00:14:36,399 --> 00:14:38,399
這時候如果時間軸的滑動卡頓

200
00:14:38,399 --> 00:14:40,399
就會變成很糟的體驗

201
00:14:40,399 --> 00:14:43,399
因此即使顯示大量的 emoji

202
00:14:43,399 --> 00:14:47,399
不影響滑動是最重要的

203
00:14:47,399 --> 00:14:50,399
另一方面，在能理解脈絡的地方

204
00:14:50,399 --> 00:14:53,399
emoji 每個影格的畫質

205
00:14:53,399 --> 00:14:57,399
或影格率可以稍微犧牲也沒關係

206
00:14:57,399 --> 00:14:59,399
幸運的是犧牲這些的話

207
00:14:59,399 --> 00:15:01,000
記憶體使用量和 CPU 使用率

208
00:15:01,000 --> 00:15:01,399
記憶體使用量大幅減少，應用程式也能更加穩定，當然發熱和電池續航也都會改善
記憶體使用量和 CPU 使用率

209
00:15:01,399 --> 00:15:06,600
記憶體使用量大幅減少，應用程式也能更加穩定，當然發熱和電池續航也都會改善

210
00:15:09,000 --> 00:15:10,557
關於捲動時的卡頓

211
00:15:10,557 --> 00:15:13,960
用 Instruments 的 Animation Hitches 來確認會比較清楚

212
00:15:13,960 --> 00:15:17,759
Animation Hitch 可以從發生卡頓的位置的主執行緒處理

213
00:15:17,759 --> 00:15:20,557
找出是什麼原因造成的卡頓

214
00:15:20,557 --> 00:15:24,557
這次不會在這個演講中詳細說明 Instruments 的使用方法

215
00:15:24,557 --> 00:15:29,158
如果對這部分有興趣的話，可以在演講結束後詢問

216
00:15:29,918 --> 00:15:34,158
而且在 WWDC 也有很多場演講介紹，請務必活用看看

217
00:15:35,158 --> 00:15:37,158
感覺時間有點不妙呢

218
00:15:37,158 --> 00:15:39,158
還沒進入正題

219
00:15:41,158 --> 00:15:46,158
這次要談的是以 AnimatedImage 這個開源專案公開發布的

220
00:15:46,158 --> 00:15:48,158
來看看這裡的實作吧

221
00:15:48,158 --> 00:15:53,158
從 AnimatedImage 整體的大流程來看

222
00:15:53,158 --> 00:15:58,158
它分成了 View 和 ImageProvider，也就是左邊這個和右邊這個

223
00:15:58,158 --> 00:16:02,158
ImageProvider 擁有用於圖像最佳化的 ImageProcessor

224
00:16:02,158 --> 00:16:06,158
以及儲存最佳化後圖像的快取

225
00:16:08,158 --> 00:16:12,158
View 和 ImageProvider 大致上有兩個任務

226
00:16:12,158 --> 00:16:16,158
第一個是確認目前要顯示的圖像是否存在於快取中

227
00:16:16,158 --> 00:16:18,158
如果存在就顯示它

228
00:16:18,158 --> 00:16:21,158
第二個是當 View 的大小等改變時

229
00:16:21,158 --> 00:16:26,158
要求 ImageProvider 產生最佳化後的圖像

230
00:16:27,158 --> 00:16:31,158
透過這樣做，View 就能一直顯示最佳化後的圖像

231
00:16:31,158 --> 00:16:35,158
使用快取是因為 GIF 有重複播放的特性

232
00:16:35,158 --> 00:16:41,158
為了因應這個性質，必須多次顯示相同的圖像，所以才使用快取

233
00:16:43,158 --> 00:16:45,158
詳細來說

234
00:16:45,158 --> 00:16:48,580
首先是確認目前要顯示的圖像是否存在於快取中

235
00:16:48,580 --> 00:16:52,158
如果存在就顯示這部分的處理

236
00:16:52,158 --> 00:16:55,158
View 使用 UpdateLink 這個計時器

237
00:16:55,158 --> 00:17:00,158
以 60fps 配合畫面更新時機來檢查快取

238
00:17:00,158 --> 00:17:03,159
如果快取中有影格圖像，就將圖像回傳給 View

239
00:17:03,159 --> 00:17:05,160
並在 View 上繪製

240
00:17:05,160 --> 00:17:08,160
乍看之下感覺每一影格都在處理，很浪費

241
00:17:08,160 --> 00:17:12,160
但這個機制的好處是可以根據 ImageProvider 是否回傳圖像

242
00:17:12,160 --> 00:17:16,160
來控制 View 的繪製，這是很好的優點

243
00:17:16,160 --> 00:17:20,160
因此可以跳過重複的影格圖像

244
00:17:20,160 --> 00:17:24,160
或是降低影格率，這些都能輕易做到

245
00:17:24,160 --> 00:17:27,160
所以當沒有影格圖像時，就只需要做

246
00:17:27,160 --> 00:17:32,160
將時間戳記轉換為索引這種程度的處理，因此很輕量

247
00:17:32,160 --> 00:17:34,160
跳過這部分

248
00:17:34,160 --> 00:17:37,160
剛才說的 UpdateLink

249
00:17:37,160 --> 00:17:41,160
內部實作是使用 UI UpdateLink 這個類別

250
00:17:41,160 --> 00:17:44,160
UI UpdateLink 能夠配合圖像的顯示時機

251
00:17:44,160 --> 00:17:47,160
執行動作，這是 iOS 17 的功能

252
00:17:47,160 --> 00:17:50,160
與基於時間經過的計時器不同

253
00:17:50,160 --> 00:17:53,160
它能與繪製時機同步

254
00:17:53,160 --> 00:17:58,160
因此每次處理的有效時間都能穩定確保

255
00:17:58,160 --> 00:18:02,160
接著來看看 ImageProvider 的內部結構

256
00:18:02,160 --> 00:18:04,160
如同剛才介紹的，ImageProvider 擁有

257
00:18:04,160 --> 00:18:07,160
ImageProcessor 和快取

258
00:18:07,160 --> 00:18:10,160
ImageProcessor 會最佳化影格圖像

259
00:18:10,160 --> 00:18:11,430
並存入快取

260
00:18:11,430 --> 00:18:16,125
快取是以 NSCache 實作的，利用它是執行緒安全的特性

261
00:18:16,130 --> 00:18:25,326
來支援ImageProcessor的儲存處理以及取出來給View的這兩個來自兩條執行緒的處理

262
00:18:26,160 --> 00:18:30,160
來看看 ImageProcessor 的實作吧

263
00:18:30,160 --> 00:18:33,160
ImageProcessor 做了四件事

264
00:18:33,160 --> 00:18:36,160
第一件是從圖像中取出影格圖像

265
00:18:36,160 --> 00:18:38,160
以及調整影格圖像的大小

266
00:18:38,160 --> 00:18:41,160
以及對影格進行抽樣

267
00:18:41,160 --> 00:18:46,160
最後是進行渲染這些作業

268
00:18:46,160 --> 00:18:48,160
首先是調整大小

269
00:18:48,160 --> 00:18:51,160
調整大小是因為如果影格圖像的尺寸太大

270
00:18:51,160 --> 00:18:53,160
記憶體使用量會增加

271
00:18:53,160 --> 00:18:57,160
所以要配合 View 顯示的大小來調整圖像尺寸

272
00:18:57,160 --> 00:19:00,160
因此，將超過顯示所需的大小的圖像

273
00:19:00,160 --> 00:19:02,160
存在記憶體中是很浪費的

274
00:19:02,160 --> 00:19:04,160
所以要調整到實際圖像渲染的大小

275
00:19:04,160 --> 00:19:07,160
縮小到合適尺寸

276
00:19:07,160 --> 00:19:09,160
調整大小的處理成本很高

277
00:19:09,160 --> 00:19:12,160
所以這裡只決定調整後的尺寸

278
00:19:12,160 --> 00:19:15,160
然後進入下一個流程

279
00:19:15,160 --> 00:19:20,160
接下來是抽樣繪製影格的作業

280
00:19:20,160 --> 00:19:25,160
此時已經可以計算解碼所有影格所需的記憶體使用量

281
00:19:25,160 --> 00:19:28,160
如果太大，就會抽樣影格來調整

282
00:19:28,160 --> 00:19:32,160
例如每秒 10 影格的 GIF 需要 10MB 記憶體來快取

283
00:19:32,160 --> 00:19:34,160
的情況下

284
00:19:34,160 --> 00:19:36,160
如果想要壓到 5MB

285
00:19:36,160 --> 00:19:40,160
把影格數減半就可以了

286
00:19:40,160 --> 00:19:43,160
不過即使把相同的影格數減半

287
00:19:43,160 --> 00:19:44,160
保留哪些影格

288
00:19:44,160 --> 00:19:47,160
會影響動畫的流暢度

289
00:19:47,160 --> 00:19:50,160
這兩個影片都是把影格數減半的版本

290
00:19:50,160 --> 00:19:52,160
但抽樣方式不同

291
00:19:52,160 --> 00:19:58,160
左邊是簡單地跳過後半的影格

292
00:19:58,160 --> 00:20:01,000
右邊是均勻抽樣的版本

293
00:20:01,160 --> 00:20:06,597
透過這樣做，動畫的卡頓現象就能被有效抑制

294
00:20:06,597 --> 00:20:10,597
雖然在測量上的效能數據並沒有改變

295
00:20:10,597 --> 00:20:15,597
但改善這種體感上的效能也是很重要的工夫

296
00:20:15,597 --> 00:20:23,097
實際調整的樣子就是這樣，畫面下方的滑桿是 Integrity 這個參數

297
00:20:23,097 --> 00:20:27,597
1 是原始的影格數，0 是最低限度的影格數

298
00:20:28,200 --> 00:20:34,200
即使調整 Integrity，也只是影格率在變化而已

299
00:20:34,200 --> 00:20:39,200
無論取什麼值，都能維持動畫的連續性

300
00:20:41,200 --> 00:20:43,200
最後是渲染 (Rendering)

301
00:20:43,200 --> 00:20:47,200
在前面的工程中已經決定了影格圖像的大小和影格數

302
00:20:47,200 --> 00:20:51,200
接下來就實際渲染影格圖像

303
00:20:52,200 --> 00:20:54,700
這裡有一個問題

304
00:20:55,298 --> 00:20:59,798
對於比原本顯示尺寸還小、不需要調整大小的影格圖像

305
00:20:59,798 --> 00:21:03,798
是否也必須渲染每一個影格呢？

306
00:21:03,798 --> 00:21:06,798
答案其實是肯定的

307
00:21:06,798 --> 00:21:08,798
原因如下

308
00:21:08,798 --> 00:21:13,798
當從 CGImageSource 取出的影格圖像以 UIImage 顯示時

309
00:21:13,798 --> 00:21:18,798
實際上會發生 DGIF 解壓縮 (Decompress) 的處理

310
00:21:18,900 --> 00:21:24,900
這是因為從 CGImageSource 取出的 DGIF 的 CGImage 其實一開始是被壓縮的

311
00:21:24,900 --> 00:21:27,900
無法直接進行繪製

312
00:21:27,900 --> 00:21:34,900
在預設的行為下，UIImage 會將還原影格的處理延遲到繪製的前一刻

313
00:21:34,900 --> 00:21:39,900
這樣一來，這個繁重的還原處理就會在主執行緒上執行

314
00:21:39,900 --> 00:21:43,900
這麼做會導致捲動時的卡頓

315
00:21:44,900 --> 00:21:49,900
為了解決這個問題，需要事先在背景執行緒還原影格

316
00:21:49,900 --> 00:21:57,900
UIImage 的情況下，可以使用 byPreparingForDisplay 方法在任意時機還原影格

317
00:21:57,900 --> 00:22:00,900
CGImage 的情況下，只要繪製到 CGContext

318
00:22:00,900 --> 00:22:04,900
就能在那個時間點取得已還原影格的 CGImage

319
00:22:04,900 --> 00:22:08,900
兩者都可以非同步呼叫

320
00:22:09,900 --> 00:22:13,900
在背景執行緒上執行並事先處理好

321
00:22:13,900 --> 00:22:20,900
就能防止在顯示到畫面的瞬間執行繁重處理而導致捲動卡頓

322
00:22:20,900 --> 00:22:23,900
實施這些最佳化之後

323
00:22:23,900 --> 00:22:27,117
即使在一個畫面上顯示超過 50 個動畫圖像也不會閃退

324
00:22:27,117 --> 00:22:31,900
記憶體使用量也能控制在 100MB 以下

325
00:22:31,900 --> 00:22:34,900
而且最重要的捲動流暢度也能維持

326
00:22:34,900 --> 00:22:39,900
另一方面，視圖顯示和動畫顯示之間會產生些微延遲

327
00:22:39,900 --> 00:22:42,140
影格率和解析度也會降低

328
00:22:42,140 --> 00:22:45,900
這些都是取捨 (Trade-off) 的結果

329
00:22:45,900 --> 00:22:50,900
在 AnimatedImage 中可以調整取捨的參數

330
00:22:50,900 --> 00:22:55,900
讓品質能夠控制

331
00:22:55,900 --> 00:22:58,900
以上就是全部內容，今天介紹的 AnimatedImage

332
00:22:58,900 --> 00:23:03,900
以及DAWN for Mastodon主要功能超過 30 個，都以開源軟體 (OSS) 的形式公開

333
00:23:03,900 --> 00:23:08,900
如果可以的話，也請看看這些其他的開源軟體

334
00:23:08,900 --> 00:23:12,900
在製作這次演講的過程中，也發現了還有很多最佳化的空間

335
00:23:12,900 --> 00:23:15,900
今後也會持續改善

336
00:23:15,900 --> 00:23:19,900
請務必用AnimatedImage看看，如果能給我些回饋的話我會很開心

337
00:23:19,900 --> 00:23:24,900
關於這次登場的 WebP 本身的詳細規格

338
00:23:24,900 --> 00:23:28,900
請觀看下午岸川先生的「製作並學習 WebP 入門」

339
00:23:28,900 --> 00:23:31,900
應該能加深各位的理解

340
00:23:31,900 --> 00:23:34,900
今天的演講就到這裡。感謝聆聽

341
00:23:41,900 --> 00:23:43,900
感謝您的發表

342
00:23:43,900 --> 00:23:46,900
接下來進入問答時間

343
00:23:46,900 --> 00:23:49,900
有意見或問題的人請舉手告知

344
00:23:55,900 --> 00:23:58,900
因為沒有人有問題

345
00:23:59,900 --> 00:24:03,900
時間到了就結束問答環節

346
00:24:03,900 --> 00:24:06,900
接下來是一分鐘回饋時間

347  
00:24:06,900  --> 00:24:23,000
翻譯：Vincent
校稿：dsxsxsxs
