1
00:00:00,000 --> 00:00:09,000
好的。那麼感謝各位今天的蒞臨。

2
00:00:09,000 --> 00:00:13,000
今天我要以「實現高效能字幕動畫播放的技巧」

3
00:00:13,000 --> 00:00:16,000
這個主題來進行分享。

4
00:00:16,000 --> 00:00:20,000
投影片為了讓大家更容易閱讀，是用英文標示的，

5
00:00:20,000 --> 00:00:22,000
但演講會用日文進行。

6
00:00:22,000 --> 00:00:27,000
這次的發表會介紹在實際的 iOS 應用程式開發中所面臨的效能課題，

7
00:00:27,000 --> 00:00:32,504
以及其解決方案，並搭配具體的案例來說明。

8
00:00:33,216 --> 00:00:35,056
首先請讓我自我介紹。

9
00:00:35,256 --> 00:00:36,180
我叫 Noppe。

10
00:00:36,184 --> 00:00:38,656
我以這個狐狸大頭貼在社群活動。

11
00:00:38,872 --> 00:00:45,296
真沒想到，從2018年開始，我每年都在 iOSDC 上台演講，

12
00:00:45,300 --> 00:00:48,000
我想這都是託各位前來聆聽的福，

13
00:00:49,140 --> 00:00:52,016
今年已經是連續第 8 年上台了。

14
00:00:52,232 --> 00:00:56,000
平常我在 DeNA 這家公司開發 iOS 應用程式，

15
00:00:57,000 --> 00:01:00,000
作為我個人興趣，自己也有在做些App。

16
00:01:00,000 --> 00:01:03,000
今天要介紹的App

17
00:01:03,000 --> 00:01:06,000
叫做 DAWN for Mastodon

18
00:01:06,000 --> 00:01:11,000
這個DAWN for Mastodon也是我個人開發的應用程式專案之一。

19
00:01:11,000 --> 00:01:16,000
希望能透過這個應用程式的開發，與各位分享我所獲得的知識。

20
00:01:18,000 --> 00:01:25,000
我在 2023 年開發的應用程式叫做DAWN for Mastodon

21
00:01:25,000 --> 00:01:30,000
如同其名，這是一個為 Mastodon 這個社群網站 (SNS) 設計的App。

22
00:01:30,000 --> 00:01:34,000
Mastodon 可能還沒有廣泛普及，

23
00:01:34,000 --> 00:01:38,000
但這個App的目標是讓任何人都能舒適地使用 Mastodon，

24
00:01:38,000 --> 00:01:44,000
所以我想盡可能地開發一個相對普通好用的App給大家使用。

25
00:01:44,000 --> 00:01:47,000
也就是說，Mastodon 的特殊性

26
00:01:47,000 --> 00:01:51,000
要透過 UI 設計與工程技術來一般化，

27
00:01:51,000 --> 00:01:54,000
這就是這個應用程式的目標。

28
00:01:54,000 --> 00:01:59,000
特別重視的是反應 (Reaction) 等溝通功能，

29
00:01:59,000 --> 00:02:04,000
以及流暢的時間軸 (Timeline) 捲動體驗。

30
00:02:04,000 --> 00:02:09,000
題外話，前陣子為了支持 iOS 26

31
00:02:09,000 --> 00:02:12,000
以及導入 Image Playground 的關係，

32
00:02:12,000 --> 00:02:15,000
在 App Store 上獲得了推薦 (Feature)。

33
00:02:15,000 --> 00:02:17,000
真的很開心。

34
00:02:17,000 --> 00:02:20,000
謝謝大家。

35
00:02:20,112 --> 00:02:27,360
為了提供新穎設計體驗的充滿魅力的App，我作為開發者今後也將如此努力。

36
00:02:28,000 --> 00:02:33,000
順帶一問，使用 Mastodon 的人有多少呢？

37
00:02:33,000 --> 00:02:34,000
有一些

38
00:02:34,000 --> 00:02:36,000
聽過的人有嗎？

39
00:02:36,000 --> 00:02:38,000
有超過一半的人。

40
00:02:38,000 --> 00:02:42,000
為了不認識 Mastodon 的人，我簡單說明一下，

41
00:02:42,000 --> 00:02:49,000
Mastodon 是 2016 年由德國的 Eugen 先生所開發的 SNS 開源軟體。

42
00:02:49,000 --> 00:02:53,000
是用 Ruby on Rails 寫的，

43
00:02:53,000 --> 00:02:58,000
但這個 Mastodon 並不是指特定的服務。

44
00:02:58,000 --> 00:03:02,000
企業或個人將 Mastodon 部署到自己的伺服器後，

45
00:03:02,000 --> 00:03:07,000
Mastodon 就會在那個伺服器中啟動，

46
00:03:07,000 --> 00:03:10,420
然後在那個伺服器中註冊帳號等等，

47
00:03:10,416 --> 00:03:15,000
也就是說，能在自己的伺服器中運營 SNS，

48
00:03:15,000 --> 00:03:18,000
這就是 Mastodon 能做到的事。

49
00:03:18,000 --> 00:03:23,000
這就是所謂的分散式社群網路平台 (Decentralized Social Network Platform)。

50
00:03:23,000 --> 00:03:29,000
特色在於個人架設的伺服器之間可以交換貼文，

51
00:03:29,000 --> 00:03:34,000
其他伺服器的貼文也會顯示在時間軸上，我覺得這點很有趣。

52
00:03:34,000 --> 00:03:38,000
所以使用者只要在任何一個伺服器建立帳號，

53
00:03:38,000 --> 00:03:42,000
就能從那裡看到多個伺服器的貼文。

54
00:03:42,000 --> 00:03:45,000
DAWN for Mastodon會連接到 Mastodon 伺服器，

55
00:03:45,000 --> 00:03:49,000
提供能在 iPhone 上舒適使用的 UI。

56
00:03:49,000 --> 00:03:53,000
目前像是 Instagram 的 Threads

57
00:03:53,000 --> 00:03:56,000
以及 Misskey 這個 SNS 也採用了相同的協定，

58
00:03:56,000 --> 00:04:00,000
所以這些貼文也能從 Mastodon 看到。

59
00:04:00,000 --> 00:04:02,840
接下來要進入正題了，

60
00:04:03,024 --> 00:04:09,000
Mastodon 的特色功能之一是自訂表情符號 (Custom Emoji)。

61
00:04:09,000 --> 00:04:12,000
Discord 也有類似的功能，

62
00:04:12,000 --> 00:04:16,000
就是使用者可以註冊的表情符號集。

63
00:04:16,000 --> 00:04:19,000
每個伺服器都有自己獨特的表情符號集，

64
00:04:19,000 --> 00:04:21,000
檔案格式可能是 GIF，

65
00:04:21,000 --> 00:04:24,000
或是 APNG、WebP、PNG 等等，

66
00:04:24,000 --> 00:04:29,000
各種不同格式的表情符號都在流通。

67
00:04:29,000 --> 00:04:34,000
這些表情符號可以包含在時間軸的貼文中

68
00:04:34,000 --> 00:04:36,000
來使用，

69
00:04:36,000 --> 00:04:40,000
在部分伺服器中也能用來對貼文做出反應，

70
00:04:40,000 --> 00:04:44,000
就像 Slack 那樣使用。

71
00:04:44,000 --> 00:04:48,000
這意味著時間軸上可能會出現數十個表情符號，

72
00:04:48,000 --> 00:04:51,000
而且還是 GIF 動畫滿溢的狀況。

73
00:04:51,000 --> 00:04:55,000
這會閃爍，請小心觀看，

74
00:04:55,000 --> 00:04:59,000
實際上同時播放數十個 GIF 動畫的情況

75
00:04:59,000 --> 00:05:00,000
在 Mastodon 中並不罕見。

76
00:05:01,000 --> 00:05:04,200
這就是我所面臨的課題本質。

77
00:05:06,200 --> 00:05:10,400
實際播放這麼大量的動畫表情符號時，

78
00:05:10,400 --> 00:05:13,900
就會像這樣捲動變得相當卡頓。

79
00:05:13,900 --> 00:05:19,300
上方也會出現記憶體不足的警告之類的，

80
00:05:19,300 --> 00:05:21,900
捲動變得很卡。

81
00:05:21,900 --> 00:05:26,200
而且記憶體使用率和 CPU 使用率都變得非常高，

82
00:05:26,200 --> 00:05:28,300
裝置會變得非常燙，

83
00:05:28,300 --> 00:05:32,100
一旦變燙，結果就是電池也會很快沒電，

84
00:05:32,100 --> 00:05:37,600
變成了一個很難說是舒適體驗的狀況。

85
00:05:37,600 --> 00:05:41,400
但是，在 Dawn 中我們已經解決了這個問題，

86
00:05:41,400 --> 00:05:46,500
現在即使顯示大量的自訂表情符號，也不會大幅損失效能，

87
00:05:46,500 --> 00:05:49,600
可以像這樣順暢地捲動。

88
00:05:49,600 --> 00:05:56,000
今天我要介紹的是如何實現這些功能。

89
00:05:57,000 --> 00:06:00,400
今天的內容大致分為兩個主題，

90
00:06:00,400 --> 00:06:06,400
首先會簡單介紹一般方法如何播放 GIF 的方式。

91
00:06:06,400 --> 00:06:10,900
第二個是 Mastodon 所使用的邏輯，

92
00:06:10,900 --> 00:06:16,900
以及如何應對在那裡發生的效能問題。

93
00:06:16,900 --> 00:06:21,100
那麼我們依序來看吧。

94
00:06:21,200 --> 00:06:30,800
首先讓我們回顧一下使用 UIKit 播放 GIF 的一般方法。

95
00:06:30,800 --> 00:06:34,800
我想應該有很多人看過這段程式碼，

96
00:06:34,800 --> 00:06:40,600
就像這樣，像平常一樣從檔案建立 UIImage 並放入 UIImageView 中。

97
00:06:40,600 --> 00:06:45,200
簡單說明一下，這裡讀取了一個叫 sample.gif 的檔案，

98
00:06:45,200 --> 00:06:49,500
將它轉換成 UIImage 並用 UIImageView 顯示，就是這樣。

99
00:06:49,500 --> 00:06:54,500
執行這段程式碼會變成這樣，

100
00:06:54,500 --> 00:07:00,100
雖然圖片有顯示出來，但並不會播放動畫。

101
00:07:00,100 --> 00:07:07,800
所以為了讓它動起來，讓我們回顧一下 GIF 檔案的結構。

102
00:07:07,800 --> 00:07:10,900
這裡有一隻大象在走路，

103
00:07:10,900 --> 00:07:18,000
GIF 就像這張投影片所示，是一個包含多個影格圖片的檔案。

104
00:07:18,000 --> 00:07:24,400
也就是說，可以把它想成是一個包含多個影格圖片的檔案。

105
00:07:24,400 --> 00:07:34,400
也就是說，透過取出 GIF 所擁有的所有影格圖片並依序顯示，就能實現動畫效果。

106
00:07:34,400 --> 00:07:39,400
就是翻頁動畫的概念。

107
00:07:39,400 --> 00:07:44,100
要實現這個機制，首先需要取出影格圖片，

108
00:07:44,300 --> 00:07:49,700
使用 Core Graphics 框架中的 CGImageSource，

109
00:07:49,700 --> 00:07:59,100
就可以輕鬆存取圖片資料的中繼資料 (metadata) 以及其他圖片資料。

110
00:07:59,100 --> 00:08:03,100
透過這個方式，可以取得 GIF 所擁有的影格圖片數量，

111
00:08:03,100 --> 00:08:11,300
以及每個影格圖片的顯示時間等資訊。

112
00:08:11,300 --> 00:08:18,500
與 GIF 結構類似的檔案格式，還有剛才提到的 APNG 或 WebP 等格式，

113
00:08:18,500 --> 00:08:22,300
CGImageSource 其實也支援這些格式，

114
00:08:22,300 --> 00:08:28,900
所以幾乎不需要在意檔案類型，就能用相同的程式碼從中取出影格圖片。

115
00:08:28,900 --> 00:08:39,500
這樣就能將所有影格圖片轉換成 UIImage 了。

116
00:08:39,700 --> 00:08:44,100
接著將建立好的 UIImage 陣列設定到 UIImageView 中。

117
00:08:44,100 --> 00:08:49,900
其實從很久以前UIImageView 就有一個叫 animationImages 的屬性，

118
00:08:49,900 --> 00:08:56,500
只要將 UIImage 的陣列設定到這裡，就可以開始播放動畫。

119
00:08:56,500 --> 00:09:04,900
實際上設定好之後，呼叫 startAnimating 這個方法，就會有以下的行為。

120
00:09:04,900 --> 00:09:08,500
這樣 GIF 動畫就播放了。

121
00:09:09,100 --> 00:09:11,500
如果只是要播放的話，這樣就可以了，

122
00:09:11,500 --> 00:09:14,500
但這次的主題是效能調校 (performance tuning)。

123
00:09:14,500 --> 00:09:18,500
也就是說，這個方法其實有一個相當大的問題。

124
00:09:20,900 --> 00:09:26,700
記憶體使用量會呈指數性增加，導致應用程式當機的問題。

125
00:09:26,700 --> 00:09:36,300
實際測量後發現，剛才那個大象走路的 GIF 圖片，一個檔案大約是 340 KB，

126
00:09:36,500 --> 00:09:42,300
但播放一個 GIF 大約會消耗 25 MB 的記憶體。

127
00:09:42,300 --> 00:09:49,500
25 MB 是多少呢？大約是一張 8K 高解析度 JPEG 圖片的大小。

128
00:09:49,500 --> 00:09:51,760
所以佔用了相當大量的記憶體。

129
00:09:51,760 --> 00:09:59,500
像剛才 Mastodon 那樣顯示大量GIF的話，可以想像結果當然不會好。

130
00:10:00,000 --> 00:10:04,800
25MB 這個記憶體使用量是從哪裡來的呢？

131
00:10:06,800 --> 00:10:11,900
記憶體使用量在一般 8 位元 ARGB 圖片的情況下

132
00:10:11,900 --> 00:10:19,000
可以用 m = w × h × c × n 這個公式來計算。

133
00:10:19,000 --> 00:10:21,200
這完全不是什麼困難的公式，

134
00:10:21,200 --> 00:10:25,500
w 是橫向像素數，h 是縱向像素數，

135
00:10:25,500 --> 00:10:28,400
c 是每個像素的色彩成分數量，

136
00:10:28,400 --> 00:10:33,400
如果是 ARGB 的話就是 4。也就是 4 個 8 位元排列在一起。

137
00:10:33,400 --> 00:10:37,400
n 就是 GIF 的影格數。

138
00:10:37,400 --> 00:10:41,400
這個例子是 34 影格的 GIF，

139
00:10:41,400 --> 00:10:44,400
大概計算一下就是 25MB 左右。

140
00:10:44,400 --> 00:10:49,400
所以，剛才的實作方式顯示 34 影格的 GIF 就意味著

141
00:10:49,400 --> 00:10:54,400
要把 34 張未壓縮的圖片全部展開在記憶體中。

142
00:10:54,400 --> 00:10:58,400
所以，影格數越多、解析度越高

143
00:10:58,400 --> 00:11:03,400
記憶體使用量就會增加。

144
00:11:03,400 --> 00:11:07,400
這樣下去如果有多個 GIF 就會馬上記憶體不足，

145
00:11:07,400 --> 00:11:14,400
效能調校的必要性就變得很明確了。

146
00:11:14,400 --> 00:11:17,400
不過話雖如此說到效能調校

147
00:11:17,400 --> 00:11:19,400
到底該做什麼呢？

148
00:11:19,400 --> 00:11:22,400
例如這次的情況，減少記憶體使用量

149
00:11:22,400 --> 00:11:27,400
是不是真正的目的？我想再思考一次。

150
00:11:27,400 --> 00:11:29,400
我在進行效能調校時

151
00:11:29,400 --> 00:11:34,400
認為首先思考什麼是重要的這件事很重要。

152
00:11:34,400 --> 00:11:42,400
今天我想介紹一下我平常使用的效能調校方法。

153
00:11:42,400 --> 00:11:47,400
首先最重要的是從使用者體驗來思考。

154
00:11:47,400 --> 00:11:50,400
思考使用者感到什麼不便

155
00:11:50,400 --> 00:11:52,400
也有去聽取使用者的意見

156
00:11:52,400 --> 00:11:57,400
比起技術指標，例如剛才說的記憶體用了很多這種事，

157
00:11:57,400 --> 00:12:00,400
從實際上使用者困擾的是什麼這個角度

158
00:12:00,400 --> 00:12:04,400
開始思考是很重要的。

159
00:12:04,400 --> 00:12:09,400
其次重要的是明確定義App提供的核心價值。

160
00:12:09,400 --> 00:12:13,400
例如天氣 App 的話，能快速確認天氣很重要，

161
00:12:13,400 --> 00:12:16,400
購物 App 的話，能輕鬆找到想要的商品

162
00:12:16,400 --> 00:12:18,400
這點就很重要。

163
00:12:19,400 --> 00:12:22,400
像這樣定義應用程式的核心價值，

164
00:12:22,400 --> 00:12:27,400
在效能調校時就容易設定優先順序。

165
00:12:27,400 --> 00:12:31,400
第三點是盡可能用數值來測量。

166
00:12:31,400 --> 00:12:35,400
例如記憶體使用量、CPU 使用率、影格率等

167
00:12:35,400 --> 00:12:39,400
測量這些與應用程式效能相關的指標。

168
00:12:39,400 --> 00:12:43,400
這樣一來就能更容易找出問題所在，

169
00:12:43,400 --> 00:12:47,400
當做了某些變更時，也能判斷那是好的變更還是壞的變更，

170
00:12:47,400 --> 00:12:52,400
能夠定量地評估這些地方。

171
00:12:52,400 --> 00:12:58,400
跟這個有關，這裡我要介紹一個 Instruments 的便利用法，

172
00:12:58,400 --> 00:13:02,400
在做效能調校時如果執行整個應用程式，

173
00:13:02,400 --> 00:13:04,400
會出現整個應用程式的處理程序，

174
00:13:04,400 --> 00:13:07,400
分析會變得非常困難，

175
00:13:07,400 --> 00:13:11,400
但有方法可以只分析特定的測試。

176
00:13:11,400 --> 00:13:15,400
在測試的地方像這樣對菱形標記按右鍵，

177
00:13:15,400 --> 00:13:20,400
就可以只執行該測試的分析 (Profile)，

178
00:13:20,400 --> 00:13:23,400
使用這個方法就能輕鬆測量

179
00:13:23,400 --> 00:13:28,400
特定功能的效能。

180
00:13:28,400 --> 00:13:32,400
最後重要的是，效能調校

181
00:13:32,400 --> 00:13:35,464
最終往往會變成取捨 (trade-off) 的難題。

182
00:13:35,680 --> 00:13:39,400
當然如果能無條件讓處理變快就很好，

183
00:13:39,400 --> 00:13:43,400
但深入探討下去，往往會變成降低不重要事物的品質

184
00:13:43,400 --> 00:13:48,400
來提升重要事物品質的討論。

185
00:13:48,400 --> 00:13:51,400
這時候以剛才說的使用者體驗

186
00:13:51,400 --> 00:13:55,400
或應用程式的核心價值是什麼為軸心，

187
00:13:55,400 --> 00:13:59,400
就能比較容易做出取捨選擇。

188
00:13:59,400 --> 00:14:02,400
所以結論是，不管記憶體或 CPU 用了多少，

189
00:14:02,400 --> 00:14:06,400
如果使用者完全不會感到不滿的話就沒有問題，

190
00:14:06,400 --> 00:14:09,400
這樣的取捨方式也是可以的。

191
00:14:09,400 --> 00:14:14,400
雖然會想解決看得見的效能問題，

192
00:14:14,400 --> 00:14:17,400
但如果思考修正後誰會高興這個問題，

193
00:14:17,400 --> 00:14:20,072
就比較容易設定優先順序。

194
00:14:20,704 --> 00:14:24,400
那麼在 Dawn 中什麼是重要的呢？

195
00:14:24,400 --> 00:14:26,400
Dawn作為一個社群網站 (SNS) App

196
00:14:26,400 --> 00:14:28,400
透過 emoji 反應進行溝通

197
00:14:28,400 --> 00:14:31,400
是其重要的價值。

198
00:14:31,400 --> 00:14:35,400
而且使用者大部分時間都在滑動頁面，

199
00:14:35,400 --> 00:14:37,400
這時候如果時間軸的滑動卡頓，

200
00:14:37,400 --> 00:14:39,400
就會變成很糟的體驗。

201
00:14:39,400 --> 00:14:42,400
因此即使顯示大量的 emoji，

202
00:14:42,400 --> 00:14:46,400
不影響滑動是最重要的。

203
00:14:46,400 --> 00:14:49,400
另一方面，在能理解脈絡的地方，

204
00:14:49,400 --> 00:14:52,400
emoji 每個影格的畫質

205
00:14:52,400 --> 00:14:56,400
或影格率可以稍微犧牲也沒關係。

206
00:14:56,400 --> 00:14:58,400
幸運的是犧牲這些的話，

207
00:14:58,400 --> 00:15:00,000
記憶體使用量和 CPU 使用率

208
00:15:00,000 --> 00:15:00,400
記憶體使用量大幅減少，應用程式也能更加穩定，當然發熱和電池續航也都會改善。
記憶體使用量和 CPU 使用率

209
00:15:00,400 --> 00:15:05,600
記憶體使用量大幅減少，應用程式也能更加穩定，當然發熱和電池續航也都會改善。

210
00:15:08,000 --> 00:15:09,560
關於捲動時的卡頓

211
00:15:09,560 --> 00:15:12,960
用 Instruments 的 Animation Hitches 來確認會比較清楚。

212
00:15:12,960 --> 00:15:16,760
Animation Hitch 可以從發生卡頓的位置的主執行緒處理

213
00:15:16,760 --> 00:15:19,560
找出是什麼原因造成的卡頓。

214
00:15:19,560 --> 00:15:23,560
這次不會在這個演講中詳細說明 Instruments 的使用方法

215
00:15:23,560 --> 00:15:28,160
如果對這部分有興趣的話，可以在演講結束後詢問。

216
00:15:28,920 --> 00:15:33,160
而且在 WWDC 也有很多場演講介紹，請務必活用看看。

217
00:15:34,160 --> 00:15:36,160
感覺時間有點不妙呢。

218
00:15:36,160 --> 00:15:38,160
還沒進入正題。

219
00:15:40,160 --> 00:15:45,160
這次要談的是以 AnimatedImage 這個開源專案公開發布的。

220
00:15:45,160 --> 00:15:47,160
來看看這裡的實作吧。

221
00:15:47,160 --> 00:15:52,160
從 AnimatedImage 整體的大流程來看

222
00:15:52,160 --> 00:15:57,160
它分成了 View 和 ImageProvider，也就是左邊這個和右邊這個。

223
00:15:57,160 --> 00:16:01,160
ImageProvider 擁有用於圖像最佳化的 ImageProcessor

224
00:16:01,160 --> 00:16:05,160
以及儲存最佳化後圖像的快取。

225
00:16:07,160 --> 00:16:11,160
View 和 ImageProvider 大致上有兩個任務

226
00:16:11,160 --> 00:16:15,160
第一個是確認目前要顯示的圖像是否存在於快取中

227
00:16:15,160 --> 00:16:17,160
如果存在就顯示它。

228
00:16:17,160 --> 00:16:20,160
第二個是當 View 的大小等改變時

229
00:16:20,160 --> 00:16:25,160
要求 ImageProvider 產生最佳化後的圖像。

230
00:16:26,160 --> 00:16:30,160
透過這樣做，View 就能一直顯示最佳化後的圖像。

231
00:16:30,160 --> 00:16:34,160
使用快取是因為 GIF 有重複播放的特性

232
00:16:34,160 --> 00:16:40,160
為了因應這個性質，必須多次顯示相同的圖像，所以才使用快取。

233
00:16:42,160 --> 00:16:44,160
詳細來說

234
00:16:44,160 --> 00:16:47,584
首先是確認目前要顯示的圖像是否存在於快取中

235
00:16:47,580 --> 00:16:51,160
如果存在就顯示這部分的處理。

236
00:16:51,160 --> 00:16:54,160
View 使用 UpdateLink 這個計時器

237
00:16:54,160 --> 00:16:59,160
以 60fps 配合畫面更新時機來檢查快取。

238
00:16:59,160 --> 00:17:02,160
如果快取中有影格圖像，就將圖像回傳給 View

239
00:17:02,160 --> 00:17:04,160
並在 View 上繪製。

240
00:17:04,160 --> 00:17:07,160
乍看之下感覺每一影格都在處理，很浪費

241
00:17:07,160 --> 00:17:11,160
但這個機制的好處是可以根據 ImageProvider 是否回傳圖像

242
00:17:11,160 --> 00:17:15,160
來控制 View 的繪製，這是很好的優點。

243
00:17:15,160 --> 00:17:19,160
因此可以跳過重複的影格圖像

244
00:17:19,160 --> 00:17:23,160
或是降低影格率，這些都能輕易做到。

245
00:17:23,160 --> 00:17:26,160
所以當沒有影格圖像時，就只需要做

246
00:17:26,160 --> 00:17:31,160
將時間戳記轉換為索引這種程度的處理，因此很輕量。

247
00:17:31,160 --> 00:17:33,160
跳過這部分。

248
00:17:33,160 --> 00:17:36,160
剛才說的 UpdateLink

249
00:17:36,160 --> 00:17:40,160
內部實作是使用 UI UpdateLink 這個類別。

250
00:17:40,160 --> 00:17:43,160
UI UpdateLink 能夠配合圖像的顯示時機

251
00:17:43,160 --> 00:17:46,160
執行動作，這是 iOS 17 的功能。

252
00:17:46,160 --> 00:17:49,160
與基於時間經過的計時器不同

253
00:17:49,160 --> 00:17:52,160
它能與繪製時機同步

254
00:17:52,160 --> 00:17:57,160
因此每次處理的有效時間都能穩定確保。

255
00:17:57,160 --> 00:18:01,160
接著來看看 ImageProvider 的內部結構。

256
00:18:01,160 --> 00:18:03,160
如同剛才介紹的，ImageProvider 擁有

257
00:18:03,160 --> 00:18:06,160
ImageProcessor 和快取

258
00:18:06,160 --> 00:18:09,160
ImageProcessor 會最佳化影格圖像

259
00:18:09,160 --> 00:18:10,432
並存入快取。

260
00:18:10,430 --> 00:18:15,128
快取是以 NSCache 實作的，利用它是執行緒安全的特性

261
00:18:15,130 --> 00:18:24,328
來支援ImageProcessor的儲存處理以及取出來給View的這兩個來自兩條執行緒的處理

262
00:18:25,160 --> 00:18:29,160
來看看 ImageProcessor 的實作吧。

263
00:18:29,160 --> 00:18:32,160
ImageProcessor 做了四件事

264
00:18:32,160 --> 00:18:35,160
第一件是從圖像中取出影格圖像

265
00:18:35,160 --> 00:18:37,160
以及調整影格圖像的大小

266
00:18:37,160 --> 00:18:40,160
以及對影格進行抽樣

267
00:18:40,160 --> 00:18:45,160
最後是進行渲染這些作業。

268
00:18:45,160 --> 00:18:47,160
首先是調整大小。

269
00:18:47,160 --> 00:18:50,160
調整大小是因為如果影格圖像的尺寸太大

270
00:18:50,160 --> 00:18:52,160
記憶體使用量會增加

271
00:18:52,160 --> 00:18:56,160
所以要配合 View 顯示的大小來調整圖像尺寸。

272
00:18:56,160 --> 00:18:59,160
因此，將超過顯示所需的大小的圖像

273
00:18:59,160 --> 00:19:01,160
存在記憶體中是很浪費的

274
00:19:01,160 --> 00:19:03,160
所以要調整到實際圖像渲染的大小

275
00:19:03,160 --> 00:19:06,160
縮小到合適尺寸。

276
00:19:06,160 --> 00:19:08,160
調整大小的處理成本很高

277
00:19:08,160 --> 00:19:11,160
所以這裡只決定調整後的尺寸

278
00:19:11,160 --> 00:19:14,160
然後進入下一個流程。

279
00:19:14,160 --> 00:19:19,160
接下來是抽樣繪製影格的作業。

280
00:19:19,160 --> 00:19:24,160
此時已經可以計算解碼所有影格所需的記憶體使用量

281
00:19:24,160 --> 00:19:27,160
如果太大，就會抽樣影格來調整。

282
00:19:27,160 --> 00:19:31,160
例如每秒 10 影格的 GIF 需要 10MB 記憶體來快取

283
00:19:31,160 --> 00:19:33,160
的情況下

284
00:19:33,160 --> 00:19:35,160
如果想要壓到 5MB

285
00:19:35,160 --> 00:19:39,160
把影格數減半就可以了。

286
00:19:39,160 --> 00:19:42,160
不過即使把相同的影格數減半

287
00:19:42,160 --> 00:19:43,160
保留哪些影格

288
00:19:43,160 --> 00:19:46,160
會影響動畫的流暢度。

289
00:19:46,160 --> 00:19:49,160
這兩個影片都是把影格數減半的版本

290
00:19:49,160 --> 00:19:51,160
但抽樣方式不同。

291
00:19:51,160 --> 00:19:57,160
左邊是簡單地跳過後半的影格。

292
00:19:57,160 --> 00:20:00,000
右邊是均勻抽樣的版本。

293
00:20:00,160 --> 00:20:05,600
透過這樣做，動畫的卡頓現象就能被有效抑制。

294
00:20:05,600 --> 00:20:09,600
雖然在測量上的效能數據並沒有改變，

295
00:20:09,600 --> 00:20:14,600
但改善這種體感上的效能也是很重要的工夫。

296
00:20:14,600 --> 00:20:22,100
實際調整的樣子就是這樣，畫面下方的滑桿是 Integrity 這個參數，

297
00:20:22,100 --> 00:20:26,600
1 是原始的影格數，0 是最低限度的影格數。

298
00:20:27,200 --> 00:20:33,200
即使調整 Integrity，也只是影格率在變化而已，

299
00:20:33,200 --> 00:20:38,200
無論取什麼值，都能維持動畫的連續性。

300
00:20:40,200 --> 00:20:42,200
最後是渲染 (Rendering)。

301
00:20:42,200 --> 00:20:46,200
在前面的工程中已經決定了影格圖像的大小和影格數，

302
00:20:46,200 --> 00:20:50,200
接下來就實際渲染影格圖像。

303
00:20:51,200 --> 00:20:53,700
這裡有一個問題。

304
00:20:54,300 --> 00:20:58,800
對於比原本顯示尺寸還小、不需要調整大小的影格圖像，

305
00:20:58,800 --> 00:21:02,800
是否也必須渲染每一個影格呢？

306
00:21:02,800 --> 00:21:05,800
答案其實是肯定的。

307
00:21:05,800 --> 00:21:07,800
原因如下。

308
00:21:07,800 --> 00:21:12,800
當從 CGImageSource 取出的影格圖像以 UIImage 顯示時，

309
00:21:12,800 --> 00:21:17,800
實際上會發生 DGIF 解壓縮 (Decompress) 的處理。

310
00:21:17,900 --> 00:21:23,900
這是因為從 CGImageSource 取出的 DGIF 的 CGImage 其實一開始是被壓縮的，

311
00:21:23,900 --> 00:21:26,900
無法直接進行繪製。

312
00:21:26,900 --> 00:21:33,900
在預設的行為下，UIImage 會將還原影格的處理延遲到繪製的前一刻，

313
00:21:33,900 --> 00:21:38,900
這樣一來，這個繁重的還原處理就會在主執行緒上執行。

314
00:21:38,900 --> 00:21:42,900
這麼做會導致捲動時的卡頓。

315
00:21:43,900 --> 00:21:48,900
為了解決這個問題，需要事先在背景執行緒還原影格，

316
00:21:48,900 --> 00:21:56,900
UIImage 的情況下，可以使用 byPreparingForDisplay 方法在任意時機還原影格。

317
00:21:56,900 --> 00:21:59,900
CGImage 的情況下，只要繪製到 CGContext，

318
00:21:59,900 --> 00:22:03,900
就能在那個時間點取得已還原影格的 CGImage。

319
00:22:03,900 --> 00:22:07,900
兩者都可以非同步呼叫，

320
00:22:08,900 --> 00:22:12,900
在背景執行緒上執行並事先處理好，

321
00:22:12,900 --> 00:22:19,900
就能防止在顯示到畫面的瞬間執行繁重處理而導致捲動卡頓。

322
00:22:19,900 --> 00:22:22,900
實施這些最佳化之後，

323
00:22:22,900 --> 00:22:26,120
即使在一個畫面上顯示超過 50 個動畫圖像也不會閃退，

324
00:22:26,120 --> 00:22:30,900
記憶體使用量也能控制在 100MB 以下。

325
00:22:30,900 --> 00:22:33,900
而且最重要的捲動流暢度也能維持。

326
00:22:33,900 --> 00:22:38,900
另一方面，視圖顯示和動畫顯示之間會產生些微延遲，

327
00:22:38,900 --> 00:22:41,140
影格率和解析度也會降低，

328
00:22:41,136 --> 00:22:44,900
這些都是取捨 (Trade-off) 的結果。

329
00:22:44,900 --> 00:22:49,900
在 AnimatedImage 中可以調整取捨的參數，

330
00:22:49,900 --> 00:22:54,900
讓品質能夠控制。

331
00:22:54,900 --> 00:22:57,900
以上就是全部內容，今天介紹的 AnimatedImage，

332
00:22:57,900 --> 00:23:02,900
以及DAWN for Mastodon主要功能超過 30 個，都以開源軟體 (OSS) 的形式公開。

333
00:23:02,900 --> 00:23:07,900
如果可以的話，也請看看這些其他的開源軟體。

334
00:23:07,900 --> 00:23:11,900
在製作這次演講的過程中，也發現了還有很多最佳化的空間，

335
00:23:11,900 --> 00:23:14,900
今後也會持續改善。

336
00:23:14,900 --> 00:23:18,900
請務必用AnimatedImage看看，如果能給我些回饋的話我會很開心。

337
00:23:18,900 --> 00:23:23,900
關於這次登場的 WebP 本身的詳細規格，

338
00:23:23,900 --> 00:23:27,900
請觀看下午岸川先生的「製作並學習 WebP 入門」，

339
00:23:27,900 --> 00:23:30,900
應該能加深各位的理解。

340
00:23:30,900 --> 00:23:33,900
今天的演講就到這裡。感謝聆聽。

341
00:23:40,900 --> 00:23:42,900
感謝您的發表。

342
00:23:42,900 --> 00:23:45,900
接下來進入問答時間。

343
00:23:45,900 --> 00:23:48,900
有意見或問題的人請舉手告知。

344
00:23:54,900 --> 00:23:57,900
因為沒有人有問題，

345
00:23:58,900 --> 00:24:02,900
時間到了就結束問答環節。

346
00:24:02,900 --> 00:24:05,900
接下來是一分鐘回饋時間。

347
00:24:27,900 --> 00:24:30,900
感謝收看。

348
00:24:57,900 --> 00:24:59,900
感謝收看。

349
00:25:00,000 --> 00:25:29,720
稍後將在四樓展示廳前舉辦「詢問講者」(Ask the Speaker) 活動

350
00:25:29,720 --> 00:25:35,000
有問題想問 Noppe 先生，或是想分享感想的朋友，歡迎參加

351
00:25:35,000 --> 00:25:36,560
那麼，Noppe 先生，非常感謝您

352
00:25:36,560 --> 00:25:37,560
謝謝大家

