1
00:00:06,500 --> 00:00:10,000
はい。では本日お越しいただき ありがとうございます。

2
00:00:10,000 --> 00:00:14,000
今日はハイパフォーマンスな 自負アニメ再生を実現する工夫

3
00:00:14,000 --> 00:00:17,000
というテーマでお話しさせていただきます。

4
00:00:17,000 --> 00:00:21,000
スライドはちょっと広く見てもらうために 英語で表記しているんですが

5
00:00:21,000 --> 00:00:23,000
トークは日本語で行います。

6
00:00:23,000 --> 00:00:28,000
この発表は実際のiOSアプリ開発で 直面したパフォーマンスの課題とか

7
00:00:28,000 --> 00:00:33,000
その解決策についてというところを 具体的な事例を交えながらご紹介します。

8
00:00:33,000 --> 00:00:35,000
まず自己紹介させてください。

9
00:00:35,000 --> 00:00:37,000
ノッペと言います。

10
00:00:37,000 --> 00:00:39,000
キツネのこのアイコンで活動しています。

11
00:00:39,000 --> 00:00:46,000
なんとですね、iOS DCは2018年から 毎年登壇させていただいておりまして

12
00:00:46,000 --> 00:00:49,000
皆さんも聴きに来ていただいている おかげだと思うんですけれども

13
00:00:49,000 --> 00:00:52,000
今年で8年連続の登壇となります。

14
00:00:52,000 --> 00:00:57,000
普段はDNAという会社で iOSアプリの開発をしていて

15
00:00:58,000 --> 00:01:01,000
個人でも趣味でアプリを作っています。

16
00:01:01,000 --> 00:01:04,000
今日お話しするアプリ

17
00:01:04,000 --> 00:01:07,000
Don't Form a Stoneというアプリを 紹介するんですけど

18
00:01:07,000 --> 00:01:12,000
そんなDon't Form a Stoneも個人開発の アプリのプロジェクトの一つとなっています。

19
00:01:12,000 --> 00:01:17,000
このアプリの開発を通じて得た知見というところを 皆さんと共有できればなと思います。

20
00:01:19,000 --> 00:01:26,000
2023年に私が開発したアプリが Don't Form a Stoneというものなんですけど

21
00:01:26,000 --> 00:01:31,000
前のとおりですね、Must-Donという SNSのためのアプリになっています。

22
00:01:31,000 --> 00:01:35,000
Must-Donちょっとまだ広く普及しているとは 言えないと思うんですけれども

23
00:01:35,000 --> 00:01:39,000
このアプリはこのMust-Donを 誰もが快適に使えるように

24
00:01:39,000 --> 00:01:45,000
なるべく普通のアプリとしてというところを 目指して開発しているものになります。

25
00:01:45,000 --> 00:01:48,000
つまりMust-Donの特殊性みたいなところを

26
00:01:48,000 --> 00:01:52,000
UIデザインとエンジニアリングというところで 一般化しようとするのが

27
00:01:52,000 --> 00:01:55,000
このアプリの目指すところになります。

28
00:01:55,000 --> 00:02:00,000
特に重要しているのはリアクションとかの コミュニケーション機能というところと

29
00:02:00,000 --> 00:02:05,000
滑らかなタイムラインのスクロール体験 というところを重視しています。

30
00:02:05,000 --> 00:02:10,000
余談になるんですけど、先日iOS26の対応とか

31
00:02:10,000 --> 00:02:13,000
イメージプレイグラウンドの導入という観点で

32
00:02:13,000 --> 00:02:16,000
App Storeでのフィーチャーを獲得しました。

33
00:02:16,000 --> 00:02:18,000
嬉しいですね。

34
00:02:18,000 --> 00:02:21,000
ありがとうございます。

35
00:02:22,000 --> 00:02:29,000
魅力あふれる新しいデザインを体験するアプリの 開発者として今後やらせていただきます。

36
00:02:29,000 --> 00:02:34,000
ちなみにMust-Donを使っている方というのは どれくらいいますか?

37
00:02:34,000 --> 00:02:35,000
ぼちぼち。

38
00:02:35,000 --> 00:02:37,000
聞いたことあるという方いますか?

39
00:02:37,000 --> 00:02:39,000
結構半分以上いる。

40
00:02:39,000 --> 00:02:43,000
Must-Donをご存じない方のために 簡単に説明させていただくと

41
00:02:43,000 --> 00:02:50,000
Must-Donは2016年にドイツのオイゲン氏によって 開発されたSNSのオープンソースソフトウェアになります。

42
00:02:50,000 --> 00:02:54,000
Clean On Railsで書かれているんですけど

43
00:02:54,000 --> 00:02:59,000
ただこのMust-Donというのは 特定のサービスを指しているわけではないんですね。

44
00:02:59,000 --> 00:03:03,000
企業とか個人がMust-Donを 自分のサーバーにデプロイすると

45
00:03:03,000 --> 00:03:08,000
そのサーバーの中でMust-Donが立ち上がって

46
00:03:08,000 --> 00:03:12,000
そのサーバーの中でアカウントを登録したりするという

47
00:03:12,000 --> 00:03:16,000
つまり自分のサーバーの中でSNSを 運用できるようにするというのが

48
00:03:16,000 --> 00:03:19,000
Must-Donができることになります。

49
00:03:19,000 --> 00:03:24,000
これが分散型ソーシャルネットワークプラットフォームと 呼ばれるものになります。

50
00:03:24,000 --> 00:03:30,000
特徴的なのは個人が立てたサーバー間の 投稿を交換しあって

51
00:03:30,000 --> 00:03:35,000
他のサーバーの投稿もタイムラインに 表示されるという点が面白い点かなと思います。

52
00:03:35,000 --> 00:03:39,000
なのでユーザーはどこか一つのサーバーで アカウントを作れば

53
00:03:39,000 --> 00:03:43,000
そこから複数のサーバーの投稿を 見ることができます。

54
00:03:43,000 --> 00:03:46,000
Must-DonはそのMust-Donサーバーに接続して

55
00:03:46,000 --> 00:03:50,000
iPhoneで快適に使えるUIというところを 提供しているものになります。

56
00:03:50,000 --> 00:03:54,000
現在は同様のプロトコルをInstagramのスレッツとか

57
00:03:54,000 --> 00:03:57,000
あとミスキーというSNSとかも採用しているので

58
00:03:57,000 --> 00:04:01,000
これらの投稿もMust-Donから見ることができます。

59
00:04:01,000 --> 00:04:05,000
そしてどんどん本題に入っていくんですけど

60
00:04:05,000 --> 00:04:10,000
Must-Donの特徴的な機能の一つとして カスタム絵文字というものがあります。

61
00:04:10,000 --> 00:04:13,000
Discordでも似たような機能あるかなと思うんですけど

62
00:04:13,000 --> 00:04:17,000
ユーザーが登録できる絵文字セットのことですね。

63
00:04:17,000 --> 00:04:20,000
各サーバーが独自の絵文字セットを持ってて

64
00:04:20,000 --> 00:04:22,000
そのファイルはGIFだったりとか

65
00:04:22,000 --> 00:04:25,000
ApingだったりWebpingだったりPingだったりするんですけど

66
00:04:25,000 --> 00:04:30,000
そういったさまざまなフォーマットで 絵文字がやり取りされています。

67
00:04:30,000 --> 00:04:35,000
これらの絵文字っていうのはタイムラインの投稿に含めて

68
00:04:35,000 --> 00:04:37,000
使用することもできますし

69
00:04:37,000 --> 00:04:41,000
一部のサーバーでは投稿へのリアクション

70
00:04:41,000 --> 00:04:45,000
スラックみたいな感じで使うこともできます。

71
00:04:45,000 --> 00:04:49,000
これはつまりタイムラインに数十個の絵文字が

72
00:04:49,000 --> 00:04:52,000
しかもGIFアニメーションがあふれるっていう 可能性があるということですね。

73
00:04:52,000 --> 00:04:56,000
これ点滅するんで気をつけて見てほしいんですけど

74
00:04:56,000 --> 00:05:00,000
実際に同時に数十個とかのGIFアニメーションが 再生される状況っていうのも

75
00:05:00,000 --> 00:05:02,000
Must-Donだとそんな珍しくないです。

76
00:05:02,000 --> 00:05:05,199
これが私が直面した課題の本質になります。

77
00:05:07,199 --> 00:05:11,399
実際にこれだけの量のアニメーション絵文字を再生してみると、

78
00:05:11,399 --> 00:05:14,899
こんな感じでスクロールが結構重たくなるんですね。

79
00:05:14,899 --> 00:05:20,300
上のほうにも半偶のアラートとかも出ちゃったりしてるんですけど、

80
00:05:20,300 --> 00:05:22,899
スクロールが重くなると。

81
00:05:22,899 --> 00:05:27,199
さらにメモリ使用率とCPU使用率が非常に高くなることで、

82
00:05:27,199 --> 00:05:29,300
デバイスがすごい熱くなって、

83
00:05:29,300 --> 00:05:33,100
熱くなると結果バッテリーもすぐ減ってしまうというところで、

84
00:05:33,100 --> 00:05:38,600
快適な体験とは言い難い状況になっていました。

85
00:05:38,600 --> 00:05:42,399
ですが、Dawnではこの問題を解決することができていて、

86
00:05:42,399 --> 00:05:47,500
現在はカスタム絵文字が大量に表示されても大きなパフォーマンスを損なうことなく、

87
00:05:47,500 --> 00:05:50,600
こんな感じでスクロールできています。

88
00:05:50,600 --> 00:05:57,000
今日はこれらをどのような感じで実現したかというところを紹介します。

89
00:05:58,000 --> 00:06:01,399
今日の話は大きく分けて2つのテーマに分かれていて、

90
00:06:01,399 --> 00:06:07,399
最初に軽く一般的な方法でどうやって辞法を再生するのかという方法。

91
00:06:07,399 --> 00:06:11,899
2つ目はMaddonで使っているロジックの話になるんですけど、

92
00:06:11,899 --> 00:06:17,899
そこで発生するパフォーマンス上の課題をどのように対応していくかという話になります。

93
00:06:17,899 --> 00:06:22,100
では順番に見ていきましょう。

94
00:06:22,199 --> 00:06:31,800
まず最初にUIキットを使って辞法を再生する一般的な方法について振り返ってみます。

95
00:06:31,800 --> 00:06:35,800
このコードはたくさん見たことがある方いると思うんですけど、

96
00:06:35,800 --> 00:06:41,600
このようにいつものようにファイルからUIイメージを作ってUIイメージビューに入れています。

97
00:06:41,600 --> 00:06:46,199
一応説明するとここではsample.gifというファイルを読み込んでいて、

98
00:06:46,199 --> 00:06:50,500
それをUIイメージにしてUIイメージビューで表示するという感じですね。

99
00:06:50,500 --> 00:06:55,500
これを実行するとこんな感じになるんですけど、

100
00:06:55,500 --> 00:07:01,100
画像は表示されているもののアニメーションはしませんというところになります。

101
00:07:01,100 --> 00:07:08,800
そこでこれを動かすためにGIFファイルの構造について振り返ってみましょう。

102
00:07:08,800 --> 00:07:11,899
ちょっとこれ像が歩いているんですけれども、

103
00:07:11,899 --> 00:07:19,000
GIFっていうのはこのスライドのように複数のフレーム画像を持ったファイルになっています。

104
00:07:19,000 --> 00:07:25,399
つまり複数のフレーム画像を持ったファイルと考えることができます。

105
00:07:25,399 --> 00:07:35,399
つまりGIFが持っている全てのフレーム画像を取り出して順番に表示をすることでアニメーションを実現することができます。

106
00:07:35,399 --> 00:07:40,399
パラパラ漫画ということですね。

107
00:07:40,399 --> 00:07:45,100
この仕組みを実現するにはまずフレーム画像を取り出す必要があるんですが、

108
00:07:45,300 --> 00:07:50,699
Power Graphicsのフレームワークの中にあるCGイメージソースを使うことで、

109
00:07:50,699 --> 00:08:00,100
画像データのメタデータだったりとか、その他の画像データに簡単にアクセスすることができます。

110
00:08:00,100 --> 00:08:04,100
これによってGIFが持っているフレーム画像の枚数だったりとか、

111
00:08:04,100 --> 00:08:12,300
それぞれのフレーム画像の表示時間みたいなものを取り出すことができるようになります。

112
00:08:12,300 --> 00:08:19,500
このGIFと似たような構造のファイルに、先ほど言ったapingだったりとかwebpというファイル形式があるんですが、

113
00:08:19,500 --> 00:08:23,300
CGイメージソースは実はこれらの形式にも対応しているので、

114
00:08:23,300 --> 00:08:29,899
ほとんどファイルタイプを気にする必要がなく同じようなコードで中からフレーム画像を取り出すことができます。

115
00:08:29,899 --> 00:08:40,500
こうして全てのフレーム画像をUIイメージにすることができました。

116
00:08:40,700 --> 00:08:45,100
そしたら作成したUIイメージの配列をUIイメージビューにセットしてみます。

117
00:08:45,100 --> 00:08:50,899
実は結構昔からUIイメージビューにはアニメーションイメージズというプロパティがありまして、

118
00:08:50,899 --> 00:08:57,500
ここに実はUIイメージの配列をセットすることでアニメーションを開始することができます。

119
00:08:57,500 --> 00:09:05,899
実際にこれをセットした後、スタートアニメーティングというメソッドを呼ぶと次のような挙動になります。

120
00:09:05,899 --> 00:09:09,500
これでGIFアニメーションが再生されました。

121
00:09:10,100 --> 00:09:12,500
再生するだけだったらこれでいいんですけれども、

122
00:09:12,500 --> 00:09:15,500
今回のテーマはパフォーマンスチューニングがテーマなわけですね。

123
00:09:15,500 --> 00:09:19,500
つまりこの方法には実はちょっと大きな問題があります。

124
00:09:21,899 --> 00:09:27,700
メモリ使用量というのが指数的に増加してアプリがクラッシュしてしまうという問題があります。

125
00:09:27,700 --> 00:09:37,299
実際に測定してみると、さっきの像が歩いているGIFの画像はだいたい1ファイル340キロバイトぐらいなんですけど、

126
00:09:37,500 --> 00:09:43,299
1つのGIFを再生するのにだいたい25メガぐらいのメモリを消費しています。

127
00:09:43,299 --> 00:09:50,500
25メガってどのくらいかというと、8Kの高解像度JPEG画像とかが入るだいたいそのくらいのサイズなんですね。

128
00:09:50,500 --> 00:09:53,500
なので結構な量のメモリが取っていると。

129
00:09:53,500 --> 00:10:00,500
さっきのソドンみたいにたくさん出したら当然結果は良くないというのは想像できるかなと思います。

130
00:10:01,000 --> 00:10:05,799
25メガっていうメモリの使用量っていうのは どこから来てるのかというところですね。

131
00:10:07,799 --> 00:10:12,899
メモリの使用量は一般的な8ビットのARGBの画像の場合は

132
00:10:12,899 --> 00:10:20,000
mイコールwかけるhかけるcかけるnっていう式で計算できます。

133
00:10:20,000 --> 00:10:22,200
全然難しい式じゃないんですけど、

134
00:10:22,200 --> 00:10:26,500
wが横のピクセル数、hが縦のピクセル数、

135
00:10:26,500 --> 00:10:29,399
cが1ピクセルあたりの色成分の数で、

136
00:10:29,399 --> 00:10:34,399
ARGBだったら4ですね。8ビットのやつが4つ並んでると。

137
00:10:34,399 --> 00:10:38,399
nがGIFのフレーム数になります。

138
00:10:38,399 --> 00:10:42,399
この例だと34フレームのGIFだったので、

139
00:10:42,399 --> 00:10:45,399
だいたい計算すると25メガぐらいになります。

140
00:10:45,399 --> 00:10:50,399
なので、先ほどの実装だと34フレームのGIFを表示するということは

141
00:10:50,399 --> 00:10:55,399
34枚分の非圧縮な画像をメモリ上に全部展開しているということになります。

142
00:10:55,399 --> 00:10:59,399
なので、フレーム数が多ければ多いほど、解像度が高ければ高いほど

143
00:10:59,399 --> 00:11:04,399
メモリ使用量が増加していきます。

144
00:11:04,399 --> 00:11:08,399
このままでは複数のGIFがあるとすぐにメモリ不足になってしまうので、

145
00:11:08,399 --> 00:11:15,399
パフォーマンスチューニングの必要性が明確になってきたかなと思います。

146
00:11:15,399 --> 00:11:18,399
ただ一言にパフォーマンスチューニングといっても

147
00:11:18,399 --> 00:11:20,399
何をすればいいのかというところですね。

148
00:11:20,399 --> 00:11:23,399
例えば今回の場合はメモリ使用量を減らすっていうのが

149
00:11:23,399 --> 00:11:28,399
本当の目的なのかというところをもう一回考えたいと思います。

150
00:11:28,399 --> 00:11:30,399
私はパフォーマンスチューニングを行う際に

151
00:11:30,399 --> 00:11:35,399
まず最初に何が大事かっていうのを考えることが重要かなと思っています。

152
00:11:35,399 --> 00:11:39,399
今日は私が普段使っているパフォーマンスチューニングのアプローチを

153
00:11:39,399 --> 00:11:43,399
紹介したいと思います。

154
00:11:43,399 --> 00:11:48,399
まず最も重要なのはユーザーの体験から考えることです。

155
00:11:48,399 --> 00:11:51,399
ユーザーが何を不都合に感じているのかを考えたり

156
00:11:51,399 --> 00:11:53,399
ファイリングしたりします。

157
00:11:53,399 --> 00:11:58,399
技術的な指標、さっき言えばメモリがたくさん使われているというものよりも

158
00:11:58,399 --> 00:12:01,399
実際にユーザーが何が困っているのかというところから

159
00:12:01,399 --> 00:12:05,399
始めることが重要かなと思います。

160
00:12:05,399 --> 00:12:10,399
次に重要なのがアプリが提供するコアな価値を明確にすることです。

161
00:12:10,399 --> 00:12:14,399
例えば天気アプリだったら素早く天気を確認できることが重要ですし

162
00:12:14,399 --> 00:12:17,399
ショッピングアプリだったら欲しい商品を簡単に見つけられる

163
00:12:17,399 --> 00:12:19,399
というところが大事になるわけですね。

164
00:12:20,399 --> 00:12:23,399
このようにアプリのコアバリューを定義することで

165
00:12:23,399 --> 00:12:28,399
パフォーマンスシューニングのときに優先順位がつきやすくなります。

166
00:12:28,399 --> 00:12:32,399
そして三つ目は可能な限り数値で測定するということです。

167
00:12:32,399 --> 00:12:36,399
例えばメモリの使用量やCPUの使用率とかフレームレート

168
00:12:36,399 --> 00:12:40,399
アプリのパフォーマンスに関するこれらの指標を測定します。

169
00:12:40,399 --> 00:12:44,399
これによって問題の箇所が特定が容易になったりだとか

170
00:12:44,399 --> 00:12:48,399
何か変更したときにそれがいい変更だったのか悪い変更だったのか

171
00:12:48,399 --> 00:12:53,399
そういったところを定義的に評価できるようになります。

172
00:12:53,399 --> 00:12:59,399
ちょっとそこに関連してここでInstrumentsの便利な使い方を一つ紹介するんですけど

173
00:12:59,399 --> 00:13:03,399
パフォーマンスシューニングやっているとアプリ全体を実行してしまうと

174
00:13:03,399 --> 00:13:05,399
アプリ全体のプロセスが出てきて

175
00:13:05,399 --> 00:13:08,399
プロファイルがすごい難しくなってしまうという問題があるんですけど

176
00:13:08,399 --> 00:13:12,399
特定のテストだけをプロファイルする方法があります。

177
00:13:12,399 --> 00:13:16,399
テストのところでこんな感じでダイヤマークのところを右クリックすると

178
00:13:16,399 --> 00:13:21,399
プロファイルのテストだけのプロファイルが実行できるので

179
00:13:21,399 --> 00:13:24,399
これを使うことで特定機能のパフォーマンスというのを

180
00:13:24,399 --> 00:13:29,399
簡単に測定することができます。

181
00:13:29,399 --> 00:13:33,399
最後に重要なのはパフォーマンスシューニングというのは

182
00:13:33,399 --> 00:13:37,399
結局トレードオフのパズルになりがちというところですね。

183
00:13:37,399 --> 00:13:40,399
当然無条件に処理が軽くなると嬉しいんですけど

184
00:13:40,399 --> 00:13:44,399
突き詰めていくと重要でないものの品質を落として

185
00:13:44,399 --> 00:13:49,399
重要なものの品質を上げるという話になりがちかなと思います。

186
00:13:49,399 --> 00:13:52,399
このときにさっき言っていたユーザー体験とか

187
00:13:52,399 --> 00:13:56,399
アプリのコア割りというものが何かというところを軸にすると

188
00:13:56,399 --> 00:14:00,399
試作選択が容易に行えるかなと思います。

189
00:14:00,399 --> 00:14:03,399
なので結論、いくらメモリとかCPUが疲れてても

190
00:14:03,399 --> 00:14:07,399
全くユーザーが不満に思わないんだったら何も問題ないという

191
00:14:07,399 --> 00:14:10,399
そういう割り切り方をしてもいいかなと思います。

192
00:14:10,399 --> 00:14:15,399
見えているパフォーマンスの問題とかを解決したくなっちゃうんですけど

193
00:14:15,399 --> 00:14:18,399
それは直して誰が嬉しくなるのかなというところを考えると

194
00:14:18,399 --> 00:14:22,399
優先順位つけやすいかなと思います。

195
00:14:22,399 --> 00:14:25,399
ではDawnでは何が重要だったかというと

196
00:14:25,399 --> 00:14:27,399
DawnはSNSのアプリなんですけど

197
00:14:27,399 --> 00:14:29,399
emojiのリアクションを介したコミュニケーションが

198
00:14:29,399 --> 00:14:32,399
重要なバリューになってきますと。

199
00:14:32,399 --> 00:14:36,399
そしてユーザーはほとんどの時間をスクロールに費やしているので

200
00:14:36,399 --> 00:14:38,399
そのときにタイムラインのスクロールが引っかかると

201
00:14:38,399 --> 00:14:40,399
いつもの悪い体験になってしまいます。

202
00:14:40,399 --> 00:14:43,399
そのため大量のemojiが表示されていても

203
00:14:43,399 --> 00:14:47,399
スクロールに影響を与えないということを最重要としました。

204
00:14:47,399 --> 00:14:50,399
一方でコンテキストが分かるところでは

205
00:14:50,399 --> 00:14:53,399
emojiのフレームごとの画質だったりとか

206
00:14:53,399 --> 00:14:57,399
フレームレートというのは多少犠牲にしてもいいかなと考えました。

207
00:14:57,399 --> 00:14:59,399
幸いなことにこれらを犠牲にすると

208
00:14:59,399 --> 00:15:01,399
メモリの使用量とかCPU使用率が

209
00:15:01,399 --> 00:15:06,600
安定に大幅に削減できてアプリの安定化とか 発電池バッテリーももちろん改善につながります。

210
00:15:09,000 --> 00:15:10,559
スクロールの引っかかりについては

211
00:15:10,559 --> 00:15:13,960
InstrumentsのAnimation Hitchesで確認すると分かりやすいです。

212
00:15:13,960 --> 00:15:17,759
Animation Hitchはが発生した箇所のメインスレッドの処理から

213
00:15:17,759 --> 00:15:20,559
何が原因で引っかかっているのかというところが特定できます。

214
00:15:20,559 --> 00:15:24,559
今回はInstrumentsの使い方とか詳細はこのトークではお話ししないんですが

215
00:15:24,559 --> 00:15:29,159
この辺り興味がある方がいればトーク後にお伺いしていただければと思います。

216
00:15:29,919 --> 00:15:34,159
まだWWDCでも多くのセッションで紹介されているのでぜひ活用してみてください。

217
00:15:35,159 --> 00:15:37,159
ちょっとこれ時間やばいかもしれないですね。

218
00:15:37,159 --> 00:15:39,159
まだ本題に入っていない。

219
00:15:41,159 --> 00:15:46,159
今回の話はアニメテッドイメージというOSSで公開しています。

220
00:15:46,159 --> 00:15:48,159
ここの実装を見てみましょう。

221
00:15:48,159 --> 00:15:53,159
全体のアニメテッドイメージの大きな流れを見ていくと

222
00:15:53,159 --> 00:15:58,159
ビューとイメージプロバイダーという左のやつと右のやつに分かれています。

223
00:15:58,159 --> 00:16:02,159
イメージプロバイダーは画像最適化のためのイメージプロセッサーと

224
00:16:02,159 --> 00:16:06,159
最適化された画像を保存するキャッシュを持っています。

225
00:16:08,159 --> 00:16:12,159
ビューとイメージプロバイダーは大きく分けて2つのタスクを持っていて

226
00:16:12,159 --> 00:16:16,159
1つ目は現在表示するべき画像がキャッシュに存在するか確認して

227
00:16:16,159 --> 00:16:18,159
存在していればそれを表示すること。

228
00:16:18,159 --> 00:16:21,159
2つ目はビューのサイズとかが変わったときに

229
00:16:21,159 --> 00:16:26,159
イメージプロバイダーに最適化された画像を生成することをリクエストすることになります。

230
00:16:27,159 --> 00:16:31,159
こうすることでビューは常に最適化された画像を表示できるようになります。

231
00:16:31,159 --> 00:16:35,159
キャッシュを介しているのはGIFが結構ループ再生をする性質があるので

232
00:16:35,159 --> 00:16:41,159
それに合わせて同じ画像を何度も表示するという意味でキャッシュを使っています。

233
00:16:43,159 --> 00:16:45,159
詳しいところなんですけど

234
00:16:45,159 --> 00:16:49,159
まず現在表示するべき画像がキャッシュに存在しているか確認して

235
00:16:49,159 --> 00:16:52,159
存在していればそれを表示する部分の処理になります。

236
00:16:52,159 --> 00:16:55,159
ビューはアップデートリンクというタイマーを使って

237
00:16:55,159 --> 00:17:00,159
60fpsで画面の更新タイミングに合わせてキャッシュの確認を行っています。

238
00:17:00,159 --> 00:17:03,159
キャッシュにフレーム画像があればビューに画像を返却して

239
00:17:03,159 --> 00:17:05,160
ビューに描画をします。

240
00:17:05,160 --> 00:17:08,160
一見するとマイフレーム処理してて無駄に見えるんですけど

241
00:17:08,160 --> 00:17:12,160
この仕組みのいいところはイメージプロバイダーが画像を返すか否かによって

242
00:17:12,160 --> 00:17:16,160
ビューの描画をコントロールできる点がいい点です。

243
00:17:16,160 --> 00:17:20,160
なのでこれによって重複したフレーム画像だったりをスキップしたりとか

244
00:17:20,160 --> 00:17:24,160
フレームレートを落としたりすることが容易に行えます。

245
00:17:24,160 --> 00:17:27,160
なのでフレーム画像がないときはタイムスタンプをインデックスに

246
00:17:27,160 --> 00:17:32,160
変換する処理程度で済むので軽量になります。

247
00:17:32,160 --> 00:17:34,160
ちょっとここを飛ばしますね。

248
00:17:34,160 --> 00:17:37,160
今言ったアップデートリンクなんですけど

249
00:17:37,160 --> 00:17:41,160
内部的にはUIアップデートリンクというクラスで実装しています。

250
00:17:41,160 --> 00:17:44,160
UIアップデートリンクは画像の表示タイミングに合わせて

251
00:17:44,160 --> 00:17:47,160
行動実行できるiOS17の機能です。

252
00:17:47,160 --> 00:17:50,160
時間の経過をベースにしているタイマーと違って

253
00:17:50,160 --> 00:17:53,160
描画タイミングと同期してくれるので

254
00:17:53,160 --> 00:17:58,160
毎回の処理の有用時間みたいなものが安定して確保できます。

255
00:17:58,160 --> 00:18:02,160
そして次にイメージプロバイダーの内部構造を見ていきましょう。

256
00:18:02,160 --> 00:18:04,160
先ほど紹介した通りイメージプロバイダーは

257
00:18:04,160 --> 00:18:07,160
イメージプロセッサーとキャッシュというのを持っていて

258
00:18:07,160 --> 00:18:10,160
イメージプロセッサーがフレーム画像を最適化して

259
00:18:10,160 --> 00:18:12,160
キャッシュに保存します。

260
00:18:12,160 --> 00:18:15,160
キャッシュはNSキャッシュで実装しているので

261
00:18:15,160 --> 00:18:19,160
安全なことを生かしてイメージプロセッサーからの保存の処理と

262
00:18:19,160 --> 00:18:24,160
ビューから取り出すという2つのスレッドからの処理を

263
00:18:24,160 --> 00:18:26,160
サポートしています。

264
00:18:26,160 --> 00:18:30,160
ではイメージプロセッサーの実装を見ていきましょう。

265
00:18:30,160 --> 00:18:33,160
イメージプロセッサーで4つのことをしていて

266
00:18:33,160 --> 00:18:36,160
1つが画像からフレーム画像を取り出す作業

267
00:18:36,160 --> 00:18:38,160
そしてフレーム画像をリサイズする作業

268
00:18:38,160 --> 00:18:41,160
そしてフレームの間引きをする作業と

269
00:18:41,160 --> 00:18:46,160
最後レンダリングをするという作業になっています。

270
00:18:46,160 --> 00:18:48,160
まずリサイズですね。

271
00:18:48,160 --> 00:18:51,160
リサイズはフレーム画像のサイズが大きいと

272
00:18:51,160 --> 00:18:53,160
メモリ使用量が増えちゃうので

273
00:18:53,160 --> 00:18:57,160
ビューで表示するサイズに合わせて画像をリサイズします。

274
00:18:57,160 --> 00:19:00,160
なので画像に表示する以上のサイズを

275
00:19:00,160 --> 00:19:02,160
メモリに保持するというのは無駄なので

276
00:19:02,160 --> 00:19:04,160
実際に画像にレンダリングするサイズまで

277
00:19:04,160 --> 00:19:07,160
小さくしているということですね。

278
00:19:07,160 --> 00:19:09,160
リサイズの処理が結構コストがかかるので

279
00:19:09,160 --> 00:19:12,160
ここではリサイズ後のサイズだけ決めて

280
00:19:12,160 --> 00:19:15,160
次の工程に進みます。

281
00:19:15,160 --> 00:19:20,160
次は描画フレームを間引く作業ですね。

282
00:19:20,160 --> 00:19:22,160
この時点で全てのフレームをデコードしたときに

283
00:19:22,160 --> 00:19:25,160
使われるメモリの量というのが計算可能なので

284
00:19:25,160 --> 00:19:28,160
それが大きすぎる場合はフレームを間引いて調整します。

285
00:19:28,160 --> 00:19:32,160
例えば毎秒10フレームのGIFをキャッシュするのに

286
00:19:32,160 --> 00:19:34,160
必要なメモリが10メガだったとしたときに

287
00:19:34,160 --> 00:19:36,160
5メガまで押さえたいよってなったら

288
00:19:36,160 --> 00:19:40,160
そのフレーム数を半分にすればいいんですね。

289
00:19:40,160 --> 00:19:43,160
ただ同じフレーム数を半分にする場合でも

290
00:19:43,160 --> 00:19:44,160
どのフレームを残すかによって

291
00:19:44,160 --> 00:19:47,160
アニメーションの滑らかさというのが変わってきます。

292
00:19:47,160 --> 00:19:50,160
この2つの動画はどちらもフレーム数を半分にしたものなんですけど

293
00:19:50,160 --> 00:19:52,160
間引き方が異なっています。

294
00:19:52,160 --> 00:19:58,160
左側は単純に後半のフレームをスキップしたもの。

295
00:19:58,160 --> 00:20:01,160
右は均一に間引いたものになります。

296
00:20:01,160 --> 00:20:06,599
こうすることでアニメーションのカクつきっていうのが結構抑えられているかなと思います。

297
00:20:06,599 --> 00:20:10,599
計測上のパフォーマンスっていうのはここでは変わらないんですけど、

298
00:20:10,599 --> 00:20:15,599
こういった体感上のパフォーマンスっていうものを改善する工夫も重要なところかなと思います。

299
00:20:15,599 --> 00:20:23,099
実際に調整している様子はこれで、この画面下のスライダーがIntegrityというパラメータで、

300
00:20:23,099 --> 00:20:27,599
1がオリジナルのフレーム数、0が最低限のフレーム数になります。

301
00:20:28,200 --> 00:20:34,200
Integrityは調整していてもフレームレートが変化しているだけで、

302
00:20:34,200 --> 00:20:39,200
どの値をとってもアニメーションの連続性っていうのは保たれているかなと思います。

303
00:20:41,200 --> 00:20:43,200
そして最後にレンダリングです。

304
00:20:43,200 --> 00:20:47,200
これまでの工程でフレーム画像のサイズとフレーム数が決まっているので、

305
00:20:47,200 --> 00:20:51,200
実際にフレーム画像をレンダリングします。

306
00:20:52,200 --> 00:20:54,700
ここで1つ問題があります。

307
00:20:55,299 --> 00:20:59,799
もともとの表示サイズより小さな、リサイズの必要がないフレーム画像でも、

308
00:20:59,799 --> 00:21:03,799
必ず各フレームをレンダリングする必要があるのでしょうか。

309
00:21:03,799 --> 00:21:06,799
これ、答えは実はイエスです。

310
00:21:06,799 --> 00:21:08,799
次のような理由があります。

311
00:21:08,799 --> 00:21:13,799
CGイメージソースから取り出されたフレーム画像をUIイメージとして表示すると、

312
00:21:13,799 --> 00:21:18,799
実はDGIFデフコンプレスという処理が発生します。

313
00:21:18,900 --> 00:21:24,900
これはCGイメージソースから取り出したDGIFのCGイメージというのは実は最初圧縮されていて、

314
00:21:24,900 --> 00:21:27,900
そのままでは描画することはできないんですね。

315
00:21:27,900 --> 00:21:34,900
デフォルトの挙動だとUIイメージは描画の直前までこのフレームを復元するという処理を遅延させるので、

316
00:21:34,900 --> 00:21:39,900
メインスレッドでこの重い復元処理というのが走ってしまうと。

317
00:21:39,900 --> 00:21:43,900
これやるとスクロールの引っかかりの原因になってしまいます。

318
00:21:44,900 --> 00:21:49,900
この問題を解決するために事前にバックグラウンドでフレームを復元しておく必要があるんですけど、

319
00:21:49,900 --> 00:21:57,900
UIイメージの場合はbyPreparingForDisplayメソッドを使うことで任意のタイミングでフレームを復元することができます。

320
00:21:57,900 --> 00:22:00,900
CGイメージの場合はCGコンテキストにドローしてあげれば、

321
00:22:00,900 --> 00:22:04,900
その時点で復元されたフレームでCGイメージを得ることができます。

322
00:22:04,900 --> 00:22:08,900
どちらも非同期で呼ぶことができるので、

323
00:22:09,900 --> 00:22:13,900
バックグラウンドスレッドで実行しておいて事前に処理しておくと、

324
00:22:13,900 --> 00:22:20,900
画面に表示される瞬間に重い処理が走ってスクロールがかくつくというのを防げるかなと思います。

325
00:22:20,900 --> 00:22:23,900
これらの最適化を実施した結果、

326
00:22:23,900 --> 00:22:27,900
1画面に50を超えるアニメーション画像を表示してもクラッシュすることなく、

327
00:22:27,900 --> 00:22:31,900
100MB以下のメモリ仕様に抑えることができました。

328
00:22:31,900 --> 00:22:34,900
そして最も重要なスクロールの滑らかさも維持できています。

329
00:22:34,900 --> 00:22:39,900
一方で、ビューの表示とアニメーションの表示の間に若干の遅延が発生したりとか、

330
00:22:39,900 --> 00:22:42,900
フレームレートや解像度が低下しているんですけど、

331
00:22:42,900 --> 00:22:45,900
この辺りはトレードオフの結果かなと思います。

332
00:22:45,900 --> 00:22:50,900
この辺はアニメーテッドイメージだとトレードオフのパラメーターを調整できるようにしていて、

333
00:22:50,900 --> 00:22:55,900
クオリティーコントロール可能な状態にしています。

334
00:22:55,900 --> 00:22:58,900
これで以上になるんですけど、本日紹介したアニメーテッドイメージをはじめ、

335
00:22:58,900 --> 00:23:03,900
DOM4マウスのDOMは主要な機能30を超えるOSSとして公開しています。

336
00:23:03,900 --> 00:23:08,900
もしよろしければ、他のOSSもご覧いただければと思います。

337
00:23:08,900 --> 00:23:12,900
今回のトーク作る中でも、まだまだ最適化の余地を見つけているので、

338
00:23:12,900 --> 00:23:15,900
今後も継続的に改善できればなと思います。

339
00:23:15,900 --> 00:23:19,900
ぜひアニメーテッドイメージを使ってみて、フィードバックいただけると嬉しいです。

340
00:23:19,900 --> 00:23:24,900
そして今回登場したWebP自体の細かい仕様っていうところについては、

341
00:23:24,900 --> 00:23:28,900
午後の岸川さんの作って学ぶWebP入門をご覧いただくと、

342
00:23:28,900 --> 00:23:31,900
より理解深まるんじゃないかなと思います。

343
00:23:31,900 --> 00:23:34,900
本日もお話でした。ご清聴ありがとうございました。

344
00:23:41,900 --> 00:23:43,900
発表ありがとうございます。

345
00:23:43,900 --> 00:23:46,900
それではQ&Aに入りたいと思います。

346
00:23:46,900 --> 00:23:49,900
コメントやご質問のある方は手を挙げてお知らせください。

347
00:23:55,900 --> 00:23:58,900
質問がある方いらっしゃらないので、

348
00:23:59,900 --> 00:24:03,900
お時間になりましたらこれでQ&Aを終了させていただきます。

349
00:24:03,900 --> 00:24:06,900
続いて1分間フィードバックのお時間です。

350
00:24:28,900 --> 00:24:31,900
ご視聴ありがとうございました。

351
00:24:58,900 --> 00:25:00,900
ご視聴ありがとうございました。

352
00:25:01,000 --> 00:25:30,720
この後4階展示ルーム前で アスクザスピーカーを実施します

353
00:25:30,720 --> 00:25:36,000
ノッペさんに質問がある方や 感想を伝えたい方は ぜひご参加ください

354
00:25:36,000 --> 00:25:37,559
それではノッペさん ありがとうございました

355
00:25:37,559 --> 00:25:38,559
ありがとうございました