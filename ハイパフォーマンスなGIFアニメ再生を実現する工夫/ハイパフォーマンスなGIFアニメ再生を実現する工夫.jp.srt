1
00:00:06,433 --> 00:00:09,933
はい。では本日お越しいただき ありがとうございます

2
00:00:09,933 --> 00:00:13,933
今日はハイパフォーマンスな 自負アニメ再生を実現する工夫

3
00:00:13,933 --> 00:00:16,933
というテーマでお話しさせていただきます

4
00:00:16,933 --> 00:00:20,933
スライドはちょっと広く見てもらうために 英語で表記しているんですが

5
00:00:20,933 --> 00:00:22,933
トークは日本語で行います

6
00:00:22,933 --> 00:00:28,399
この発表は実際のiOSアプリ開発で 直面したパフォーマンスの課題とか

7
00:00:28,399 --> 00:00:33,433
その解決策についてというところを 具体的な事例を交えながらご紹介します

8
00:00:34,133 --> 00:00:35,700
まず自己紹介させてください

9
00:00:35,700 --> 00:00:37,100
ノッペと言います

10
00:00:37,100 --> 00:00:39,799
キツネのこのアイコンで活動しています

11
00:00:39,799 --> 00:00:46,233
なんとですね、iOS DCは2018年から 毎年登壇させていただいておりまして

12
00:00:46,233 --> 00:00:49,866
皆さんも聴きに来ていただいている おかげだと思うんですけれども

13
00:00:49,866 --> 00:00:53,166
今年で8年連続の登壇となります

14
00:00:53,166 --> 00:00:57,433
普段は DeNA という会社で iOSアプリの開発をしていて

15
00:00:57,433 --> 00:01:00,566
個人でも趣味でアプリを作っています

16
00:01:00,566 --> 00:01:03,233
今日お話しするアプリ

17
00:01:03,233 --> 00:01:06,099
DAWN for Mastodon というアプリを 紹介するんですけど

18
00:01:06,099 --> 00:01:11,333
そんな DAWN for Mastodon も個人開発のアプリのプロジェクトの一つとなっています

19
00:01:11,333 --> 00:01:14,033
このアプリの開発を通じて得た知見というところを

20
00:01:14,033 --> 00:01:16,933
皆さんと共有できればなと思います

21
00:01:18,400 --> 00:01:25,400
2023 年に私が開発したアプリが DAWN for Mastodon というものなんですけど

22
00:01:25,400 --> 00:01:30,933
名前のとおりですね、Mastodon という SNS のためのアプリになっています

23
00:01:30,933 --> 00:01:34,933
Mastodon ちょっとまだ広く普及しているとは 言えないと思うんですけれども

24
00:01:34,933 --> 00:01:38,933
このアプリはこの Mastodon を誰もが快適に使えるように

25
00:01:38,933 --> 00:01:42,799
なるべく普通のアプリとしてというところを目指して

26
00:01:42,799 --> 00:01:44,933
開発しているものになります

27
00:01:44,933 --> 00:01:47,933
つまり Mastodon の特殊性みたいなところを

28
00:01:47,933 --> 00:01:51,933
UIデザインとエンジニアリングというところで 一般化しようとするのが

29
00:01:51,933 --> 00:01:54,299
このアプリの目指すところになります

30
00:01:54,299 --> 00:01:59,133
特に重要しているのはリアクションとかのコミュニケーション機能というところと

31
00:01:59,133 --> 00:02:03,133
滑らかなタイムラインのスクロール体験 というところを重視しています

32
00:02:04,466 --> 00:02:09,466
余談になるんですけど、先日iOS26の対応とか

33
00:02:09,466 --> 00:02:12,466
イメージプレイグラウンドの導入という観点で

34
00:02:12,466 --> 00:02:15,166
App Storeでのフィーチャーを獲得しました

35
00:02:15,166 --> 00:02:17,466
嬉しいですね

36
00:02:17,466 --> 00:02:20,466
ありがとうございます

37
00:02:20,866 --> 00:02:27,866
魅力あふれる新しいデザインを体験するアプリの 開発者として今後やらせていただきます

38
00:02:28,533 --> 00:02:33,533
ちなみに Mastodon を使っている方というのは どれくらいいますか?

39
00:02:33,533 --> 00:02:34,533
ぼちぼち

40
00:02:34,533 --> 00:02:36,533
聞いたことあるという方いますか?

41
00:02:36,533 --> 00:02:38,533
結構半分以上いる

42
00:02:38,533 --> 00:02:42,000
Mastodon をご存じない方のために 簡単に説明させていただくと

43
00:02:42,000 --> 00:02:49,066
Must-Donは2016年にドイツのオイゲン氏によって 開発されたSNSのオープンソースソフトウェアになります

44
00:02:49,066 --> 00:02:53,333
Ruby On Railsで書かれているんですけど

45
00:02:53,333 --> 00:02:58,533
ただこの Mastodon というのは 特定のサービスを指しているわけではないんですね

46
00:02:58,533 --> 00:03:02,733
企業とか個人が Mastodon を自分のサーバーにデプロイすると

47
00:03:02,733 --> 00:03:07,833
そのサーバーの中で Mastodon が立ち上がって

48
00:03:07,833 --> 00:03:11,199
そのサーバーの中でアカウントを登録したりするという

49
00:03:11,199 --> 00:03:15,199
つまり自分のサーバーの中でSNSを 運用できるようにするというのが

50
00:03:15,199 --> 00:03:18,199
Mastodon ができることになります

51
00:03:18,199 --> 00:03:23,533
これが分散型ソーシャルネットワークプラットフォームと 呼ばれるものになります

52
00:03:23,533 --> 00:03:29,533
特徴的なのは個人が立てたサーバー間の投稿を交換しあって

53
00:03:29,533 --> 00:03:34,533
他のサーバーの投稿もタイムラインに 表示されるという点が面白い点かなと思います

54
00:03:34,533 --> 00:03:38,066
なのでユーザーはどこか一つのサーバーで アカウントを作れば

55
00:03:38,066 --> 00:03:42,099
そこから複数のサーバーの投稿を 見ることができます

56
00:03:42,099 --> 00:03:45,033
DAWN はその Mastodon サーバーに接続して

57
00:03:45,033 --> 00:03:49,833
iPhoneで快適に使えるUIというところを 提供しているものになります

58
00:03:49,833 --> 00:03:53,133
現在は同様のプロトコルをInstagramのスレッツとか

59
00:03:53,133 --> 00:03:55,800
あとミスキーというSNSとかも採用しているので

60
00:03:55,800 --> 00:03:59,566
これらの投稿も Mastodon から見ることができます

61
00:04:00,533 --> 00:04:03,566
そしてどんどん本題に入っていくんですけど

62
00:04:03,566 --> 00:04:08,433
Mastodon の特徴的な機能の一つとして カスタム絵文字というものがあります

63
00:04:08,433 --> 00:04:12,533
Slack とか Discordでも似たような機能あるかなと思うんですけど

64
00:04:12,533 --> 00:04:15,966
ユーザーが登録できる絵文字セットのことですね

65
00:04:15,966 --> 00:04:18,766
各サーバーが独自の絵文字セットを持ってて

66
00:04:18,766 --> 00:04:21,100
そのファイルはGIFだったりとか

67
00:04:21,100 --> 00:04:24,533
APNG だったり WebP だったり PNG だったりするんですけど

68
00:04:24,533 --> 00:04:29,933
そういったさまざまなフォーマットで 絵文字がやり取りされています

69
00:04:29,933 --> 00:04:34,533
これらの絵文字っていうのはタイムラインの投稿に含めて

70
00:04:34,533 --> 00:04:36,533
使用することもできますし

71
00:04:36,533 --> 00:04:39,933
一部のサーバーでは投稿へのリアクション

72
00:04:39,933 --> 00:04:43,633
Slack みたいな感じで使うこともできます

73
00:04:43,633 --> 00:04:47,866
これはつまりタイムラインに数十個の絵文字が

74
00:04:47,866 --> 00:04:51,533
しかもGIFアニメーションがあふれるっていう 可能性があるということですね

75
00:04:51,533 --> 00:04:54,500
これ点滅するんで気をつけて見てほしいんですけど

76
00:04:54,500 --> 00:04:58,966
実際に同時に数十個とかのGIFアニメーションが 再生される状況っていうのも

77
00:04:58,966 --> 00:05:01,533
Mastodon だとそんな珍しくないです

78
00:05:01,533 --> 00:05:05,366
これが私が直面した課題の本質になります

79
00:05:06,733 --> 00:05:10,933
実際にこれだけの量のアニメーション絵文字を再生してみると、

80
00:05:10,933 --> 00:05:14,433
こんな感じでスクロールが結構重たくなるんですね

81
00:05:14,433 --> 00:05:19,833
上のほうにも半偶のアラートとかも出ちゃったりしてるんですけど、

82
00:05:21,399 --> 00:05:22,433
スクロールが重くなると

83
00:05:22,433 --> 00:05:26,933
さらにメモリ使用率とCPU使用率が非常に高くなることで、

84
00:05:26,933 --> 00:05:28,833
デバイスがすごい熱くなって、

85
00:05:28,833 --> 00:05:32,800
熱くなると結果バッテリーもすぐ減ってしまうというところで、

86
00:05:32,800 --> 00:05:38,133
快適な体験とは言い難い状況になっていました

87
00:05:38,133 --> 00:05:41,933
ですが、DAWN ではこの問題を解決することができていて、

88
00:05:41,933 --> 00:05:47,033
現在はカスタム絵文字が大量に表示されても大きなパフォーマンスを損なうことなく、

89
00:05:47,033 --> 00:05:50,133
こんな感じでスクロールできています

90
00:05:50,133 --> 00:05:55,166
今日はこれらをどのような感じで実現したかというところを紹介します

91
00:05:57,133 --> 00:06:00,199
今日の話は大きく分けて2つのテーマに分かれていて、

92
00:06:00,199 --> 00:06:06,333
最初に軽く一般的な方法でどうやって GIF を再生するのかという方法

93
00:06:06,333 --> 00:06:10,966
2つ目は DAWN で使っているロジックの話になるんですけど、

94
00:06:10,966 --> 00:06:17,133
そこで発生するパフォーマンス上の課題をどのように対応していくかという話になります

95
00:06:17,133 --> 00:06:21,233
では順番に見ていきましょう

96
00:06:21,233 --> 00:06:28,466
まず最初にUIキットを使って GIF を再生する一般的な方法について振り返ってみます

97
00:06:31,333 --> 00:06:34,866
このコードもたくさん見たことがある方いると思うんですけど、

98
00:06:34,866 --> 00:06:40,633
このようにいつものようにファイルから UIImage を作って UIImageView に入れています

99
00:06:40,633 --> 00:06:45,733
一応説明するとここではsample.gifというファイルを読み込んでいて、

100
00:06:45,733 --> 00:06:49,633
UIImage にして UIImageView で表示するという感じですね

101
00:06:49,633 --> 00:06:54,333
これを実行するとこんな感じになるんですけど、

102
00:06:54,333 --> 00:07:00,166
画像は表示されているもののアニメーションはしませんというところになります

103
00:07:00,166 --> 00:07:05,366
そこでこれを動かすためにGIFファイルの構造について振り返ってみましょう

104
00:07:07,699 --> 00:07:11,199
ちょっとこれゾウが歩いているんですけれども、

105
00:07:11,199 --> 00:07:17,866
GIFっていうのはこのスライドのように複数のフレーム画像を持ったファイルになっています

106
00:07:17,866 --> 00:07:24,266
つまり複数のフレーム画像を持ったファイルと考えることができます

107
00:07:24,266 --> 00:07:34,266
つまりGIFが持っている全てのフレーム画像を取り出して順番に表示をすることでアニメーションを実現することができます

108
00:07:34,266 --> 00:07:39,366
パラパラ漫画ということですね

109
00:07:39,366 --> 00:07:44,366
この仕組みを実現するにはまずフレーム画像を取り出す必要があるんですが、

110
00:07:44,366 --> 00:07:49,833
実は Core Graphics のフレームワークの中にある CGImageSource を使うことで、

111
00:07:49,833 --> 00:07:54,699
画像データのメタデータだったりとか

112
00:07:54,699 --> 00:07:59,100
その他の画像データに簡単にアクセスすることができます

113
00:07:59,100 --> 00:08:03,199
これによってGIFが持っているフレーム画像の枚数だったりとか、

114
00:08:03,199 --> 00:08:08,766
あとそれぞれのフレーム画像の表示時間みたいなものを

115
00:08:08,766 --> 00:08:11,833
取り出すことができるようになります

116
00:08:11,833 --> 00:08:14,066
このGIFと似たような構造のファイルに

117
00:08:14,066 --> 00:08:18,699
先ほど言った APNG だったりとか WebP というファイル形式があるんですが、

118
00:08:18,699 --> 00:08:22,166
CGImageSource は実はこれらの形式にも対応しているので、

119
00:08:22,166 --> 00:08:26,133
ほとんどファイルタイプを気にする必要がなく同じようなコードで

120
00:08:26,133 --> 00:08:29,066
中からフレーム画像を取り出すことができます

121
00:08:29,066 --> 00:08:33,833
こうして全てのフレーム画像を UIImage にすることができました

122
00:08:40,033 --> 00:08:44,233
そしたら作成した UIImage の配列を UIImageView にセットしてみます

123
00:08:44,233 --> 00:08:50,233
実は結構昔から UIImageView には animationImages というプロパティがありまして、

124
00:08:50,233 --> 00:08:56,266
ここに実は UIImage の配列をセットすることでアニメーションを開始することができます

125
00:08:56,766 --> 00:09:03,533
実際にこれをセットした後、startAnimating というメソッドを呼ぶと次のような挙動になります

126
00:09:05,233 --> 00:09:08,833
これでGIFアニメーションが再生されました

127
00:09:09,666 --> 00:09:11,899
再生するだけだったらこれでいいんですけれども、

128
00:09:11,899 --> 00:09:14,833
今回のテーマはパフォーマンスチューニングがテーマなわけですね

129
00:09:14,833 --> 00:09:18,833
つまりこの方法には実はちょっと大きな問題があります

130
00:09:21,433 --> 00:09:27,233
メモリ使用量というのが指数的に増加してアプリがクラッシュしてしまうという問題があります

131
00:09:27,233 --> 00:09:36,366
実際に測定してみると、さっきのゾウが歩いているGIFの画像はだいたい1ファイル340キロバイトぐらいなんですけど、

132
00:09:37,033 --> 00:09:41,966
1つのGIFを再生するのにだいたい25メガぐらいのメモリを消費しています

133
00:09:41,966 --> 00:09:44,666
25メガってどのくらいかというと

134
00:09:44,666 --> 00:09:49,733
8Kの高解像度JPEG画像とかが入るだいたいそのくらいのサイズなんですね

135
00:09:49,733 --> 00:09:52,799
なので結構な量のメモリが取っていると

136
00:09:52,799 --> 00:09:55,233
さっきのソドンみたいにたくさん出したら

137
00:09:55,233 --> 00:10:00,166
当然結果は良くないというのは想像できるかなと思います

138
00:10:00,166 --> 00:10:05,333
25メガっていうメモリの使用量っていうのは どこから来てるのかというところですね

139
00:10:07,333 --> 00:10:12,433
メモリの使用量は一般的な8ビットのARGBの画像の場合は

140
00:10:12,433 --> 00:10:19,533
m = w × h × c × n っていう式で計算できます

141
00:10:19,533 --> 00:10:21,733
全然難しい式じゃないんですけど、

142
00:10:21,733 --> 00:10:26,033
wが横のピクセル数、hが縦のピクセル数、

143
00:10:26,033 --> 00:10:28,933
cが1ピクセルあたりの色成分の数で、

144
00:10:28,933 --> 00:10:31,466
ARGBだったら4ですね

145
00:10:31,466 --> 00:10:33,466
8ビットのやつが4つ並んでると

146
00:10:33,466 --> 00:10:37,566
nがGIFのフレーム数になります

147
00:10:37,566 --> 00:10:41,566
この例だと34フレームのGIFだったので、

148
00:10:41,566 --> 00:10:44,533
だいたい計算すると25メガぐらいになります

149
00:10:44,833 --> 00:10:49,700
なので、先ほどの実装だと34フレームのGIFを表示するということは

150
00:10:49,700 --> 00:10:54,799
34枚分の非圧縮な画像をメモリ上に全部展開しているということになります

151
00:10:54,799 --> 00:10:59,100
なので、フレーム数が多ければ多いほど、解像度が高ければ高いほど

152
00:10:59,100 --> 00:11:01,533
メモリ使用量が増加していきます

153
00:11:03,933 --> 00:11:08,266
このままでは複数のGIFがあるとすぐにメモリ不足になってしまうので、

154
00:11:08,266 --> 00:11:14,933
パフォーマンスチューニングの必要性が明確になってきたかなと思います

155
00:11:14,933 --> 00:11:17,633
ただ一言にパフォーマンスチューニングといっても

156
00:11:17,633 --> 00:11:19,933
何をすればいいのかというところですね

157
00:11:19,933 --> 00:11:22,933
例えば今回の場合はメモリ使用量を減らすっていうのが

158
00:11:22,933 --> 00:11:27,600
本当の目的なのかというところをもう一回考えたいと思います

159
00:11:27,600 --> 00:11:30,033
私はパフォーマンスチューニングを行う際に

160
00:11:30,033 --> 00:11:35,200
まず最初に何が大事かっていうのを考えることが重要かなと思っています

161
00:11:35,200 --> 00:11:38,933
今日は私が普段使っているパフォーマンスチューニングのアプローチを

162
00:11:38,933 --> 00:11:40,533
紹介したいと思います

163
00:11:42,666 --> 00:11:47,666
まず最も重要なのはユーザーの体験から考えることです

164
00:11:47,666 --> 00:11:50,666
ユーザーが何を不都合に感じているのかを考えたり

165
00:11:50,666 --> 00:11:52,666
ファイリングしたりします

166
00:11:52,666 --> 00:11:57,666
技術的な指標、さっき言えばメモリがたくさん使われているというものよりも

167
00:11:57,666 --> 00:12:00,666
実際にユーザーが何が困っているのかというところから

168
00:12:00,666 --> 00:12:03,366
始めることが重要かなと思います

169
00:12:04,666 --> 00:12:09,466
次に重要なのがアプリが提供するコアな価値を明確にすることです

170
00:12:09,466 --> 00:12:14,033
例えば天気アプリだったら素早く天気を確認できることが重要ですし

171
00:12:14,033 --> 00:12:16,666
ショッピングアプリだったら欲しい商品を簡単に見つけられる

172
00:12:16,666 --> 00:12:18,666
というところが大事になるわけですね

173
00:12:19,666 --> 00:12:22,566
このようにアプリのコアバリューを定義することで

174
00:12:22,566 --> 00:12:26,866
パフォーマンスシューニングのときに優先順位がつきやすくなります

175
00:12:28,333 --> 00:12:31,933
そして三つ目は可能な限り数値で測定するということです

176
00:12:31,933 --> 00:12:35,933
例えばメモリの使用量やCPUの使用率とかフレームレート

177
00:12:35,933 --> 00:12:40,333
アプリのパフォーマンスに関するこれらの指標を測定します

178
00:12:40,333 --> 00:12:43,766
これによって問題の箇所が特定が容易になったりだとか

179
00:12:43,766 --> 00:12:47,799
何か変更したときにそれがいい変更だったのか悪い変更だったのか

180
00:12:47,799 --> 00:12:51,366
っていうところを定量的に評価できるようになります

181
00:12:52,766 --> 00:12:58,399
ちょっとそこに関連してここでInstrumentsの便利な使い方を一つ紹介するんですけど

182
00:12:58,399 --> 00:13:02,933
パフォーマンスシューニングやっているとアプリ全体を実行してしまうと

183
00:13:02,933 --> 00:13:04,333
アプリ全体のプロセスが出てきて

184
00:13:04,333 --> 00:13:08,333
プロファイルがすごい難しくなってしまうという問題があるんですけど

185
00:13:08,333 --> 00:13:11,366
特定のテストだけをプロファイルする方法があります

186
00:13:11,366 --> 00:13:15,933
テストのところでこんな感じでダイヤマークのところを右クリックすると

187
00:13:15,933 --> 00:13:20,933
プロファイルのテストだけのプロファイルが実行できるので

188
00:13:20,933 --> 00:13:23,500
これを使うことで特定機能のパフォーマンスというのを

189
00:13:23,500 --> 00:13:26,366
簡単に測定することができます

190
00:13:28,733 --> 00:13:32,433
最後に重要なのはパフォーマンスシューニングというのは

191
00:13:32,433 --> 00:13:36,399
結局トレードオフのパズルになりがちというところですね

192
00:13:36,399 --> 00:13:40,066
当然無条件に処理が軽くなると嬉しいんですけど

193
00:13:40,066 --> 00:13:43,933
突き詰めていくと重要でないものの品質を落として

194
00:13:43,933 --> 00:13:48,933
重要なものの品質を上げるという話になりがちかなと思います

195
00:13:48,933 --> 00:13:51,933
このときにさっき言っていたユーザー体験とか

196
00:13:51,933 --> 00:13:55,933
アプリのコアバリューというものが何かというところを軸にすると

197
00:13:55,933 --> 00:13:59,299
試作選択が容易に行えるかなと思います

198
00:13:59,299 --> 00:14:02,933
なので結論、いくらメモリとかCPUがつかれてても

199
00:14:02,933 --> 00:14:06,299
全くユーザーが不満に思わないんだったら何も問題ないという

200
00:14:06,299 --> 00:14:09,933
そういう割り切り方をしてもいいかなと思います

201
00:14:09,933 --> 00:14:14,266
見えているパフォーマンスの問題とかを解決したくなっちゃうんですけど

202
00:14:14,266 --> 00:14:17,466
それは直して誰が嬉しくなるのかなというところを考えると

203
00:14:17,466 --> 00:14:20,600
優先順位つけやすいかなと思います

204
00:14:21,399 --> 00:14:24,233
では DAWN では何が重要だったかというと

205
00:14:24,233 --> 00:14:26,799
DAWN は SNS のアプリなんですけど

206
00:14:26,799 --> 00:14:28,933
emojiのリアクションを介したコミュニケーションが

207
00:14:28,933 --> 00:14:31,399
重要なバリューになってきますと

208
00:14:31,399 --> 00:14:35,766
そしてユーザーはほとんどの時間をスクロールに費やしているので

209
00:14:35,766 --> 00:14:37,933
そのときにタイムラインのスクロールが引っかかると

210
00:14:37,933 --> 00:14:40,200
いつもの悪い体験になってしまいます

211
00:14:40,200 --> 00:14:42,933
そのため大量のemojiが表示されていても

212
00:14:42,933 --> 00:14:46,933
スクロールに影響を与えないということを最重要としました

213
00:14:47,399 --> 00:14:50,366
一方でコンテキストが分かるところでは

214
00:14:50,366 --> 00:14:52,633
emojiのフレームごとの画質だったりとか

215
00:14:52,633 --> 00:14:56,700
フレームレートというのは多少犠牲にしてもいいかなと考えました

216
00:14:56,700 --> 00:14:58,933
幸いなことにこれらを犠牲にすると

217
00:14:58,933 --> 00:15:00,633
メモリの使用量とかCPU使用率が

218
00:15:00,633 --> 00:15:04,066
安定に大幅に削減できてアプリの安定化とか

219
00:15:04,066 --> 00:15:06,133
発熱バッテリーももちろん改善につながります

220
00:15:08,533 --> 00:15:10,100
スクロールの引っかかりについては

221
00:15:10,100 --> 00:15:13,500
InstrumentsのAnimation Hitchesで確認すると分かりやすいです

222
00:15:13,733 --> 00:15:17,299
Animation Hitchはが発生した箇所のメインスレッドの処理から

223
00:15:17,299 --> 00:15:20,100
何が原因で引っかかっているのかというところが特定できます

224
00:15:20,100 --> 00:15:24,100
今回はInstrumentsの使い方とか詳細はこのトークではお話ししないんですが

225
00:15:24,100 --> 00:15:28,700
この辺り興味がある方がいればトーク後にお伺いしていただければと思います

226
00:15:29,366 --> 00:15:33,700
まだWWDCでも多くのセッションで紹介されているのでぜひ活用してみてください

227
00:15:34,700 --> 00:15:36,700
ちょっとこれ時間やばいかもしれないですね

228
00:15:36,700 --> 00:15:38,700
まだ本題に入っていない

229
00:15:40,700 --> 00:15:45,700
今回の話はアニメテッドイメージというOSSで公開しています

230
00:15:45,700 --> 00:15:47,700
ここの実装を見てみましょう

231
00:15:48,333 --> 00:15:53,266
全体のアニメテッドイメージの大きな流れを見ていくと

232
00:15:53,266 --> 00:15:58,000
ビューとイメージプロバイダーという左のやつと右のやつに分かれています

233
00:15:58,000 --> 00:16:02,066
イメージプロバイダーは画像最適化のためのイメージプロセッサーと

234
00:16:02,066 --> 00:16:06,233
最適化された画像を保存するキャッシュを持っています

235
00:16:07,700 --> 00:16:11,899
ビューとイメージプロバイダーは大きく分けて2つのタスクを持っていて

236
00:16:11,899 --> 00:16:15,966
1つ目は現在表示するべき画像がキャッシュに存在するか確認して

237
00:16:15,966 --> 00:16:18,233
存在していればそれを表示すること

238
00:16:18,233 --> 00:16:20,700
2つ目はビューのサイズとかが変わったときに

239
00:16:20,700 --> 00:16:25,700
イメージプロバイダーに最適化された画像を生成することをリクエストすることになります

240
00:16:26,700 --> 00:16:30,700
こうすることでビューは常に最適化された画像を表示できるようになります

241
00:16:30,700 --> 00:16:35,000
キャッシュを介しているのはGIFが結構ループ再生をする性質があるので

242
00:16:35,000 --> 00:16:40,700
それに合わせて同じ画像を何度も表示するという意味でキャッシュを使っています

243
00:16:42,533 --> 00:16:44,133
詳しいところなんですけど

244
00:16:44,133 --> 00:16:48,266
まず現在表示するべき画像がキャッシュに存在しているか確認して

245
00:16:48,266 --> 00:16:52,000
存在していればそれを表示する部分の処理になります

246
00:16:52,000 --> 00:16:54,700
ビューはアップデートリンクというタイマーを使って

247
00:16:54,700 --> 00:16:59,399
60fpsで画面の更新タイミングに合わせてキャッシュの確認を行っています

248
00:16:59,399 --> 00:17:02,700
キャッシュにフレーム画像があればビューに画像を返却して

249
00:17:02,700 --> 00:17:04,400
ビューに描画をします

250
00:17:04,400 --> 00:17:07,833
一見するとマイフレーム処理してて無駄に見えるんですけど

251
00:17:07,833 --> 00:17:11,700
この仕組みのいいところはイメージプロバイダーが画像を返すか否かによって

252
00:17:11,700 --> 00:17:15,200
ビューの描画をコントロールできる点がいい点です

253
00:17:15,200 --> 00:17:19,700
なのでこれによって重複したフレーム画像だったりをスキップしたりとか

254
00:17:19,700 --> 00:17:23,566
フレームレートを落としたりすることが容易に行えます

255
00:17:23,566 --> 00:17:26,400
なのでフレーム画像がないときはタイムスタンプをインデックスに

256
00:17:26,400 --> 00:17:29,500
変換する処理程度で済むので軽量になります

257
00:17:32,166 --> 00:17:33,700
ちょっとここを飛ばしますね

258
00:17:33,700 --> 00:17:36,700
今言ったアップデートリンクなんですけど

259
00:17:36,700 --> 00:17:40,966
内部的にはUIアップデートリンクというクラスで実装しています

260
00:17:40,966 --> 00:17:43,933
UIアップデートリンクは画像の表示タイミングに合わせて

261
00:17:43,933 --> 00:17:46,866
行動実行できるiOS17の機能です

262
00:17:46,866 --> 00:17:49,700
時間の経過をベースにしているタイマーと違って

263
00:17:49,700 --> 00:17:52,533
描画タイミングと同期してくれるので

264
00:17:52,533 --> 00:17:55,900
毎回の処理の有用時間みたいなものが安定して確保できます

265
00:17:58,400 --> 00:18:01,799
そして次にイメージプロバイダーの内部構造を見ていきましょう

266
00:18:01,799 --> 00:18:03,700
先ほど紹介した通りイメージプロバイダーは

267
00:18:03,700 --> 00:18:06,700
イメージプロセッサーとキャッシュというのを持っていて

268
00:18:06,700 --> 00:18:09,700
イメージプロセッサーがフレーム画像を最適化して

269
00:18:09,700 --> 00:18:11,466
キャッシュに保存します

270
00:18:11,466 --> 00:18:13,733
キャッシュはNSキャッシュで実装しているので

271
00:18:13,733 --> 00:18:19,066
スレッド安全なことを生かしてイメージプロセッサーからの保存の処理と

272
00:18:19,066 --> 00:18:23,700
ビューから取り出すという2つのスレッドからの処理を

273
00:18:23,700 --> 00:18:25,700
サポートしています

274
00:18:25,700 --> 00:18:29,133
ではイメージプロセッサーの実装を見ていきましょう

275
00:18:29,700 --> 00:18:32,700
イメージプロセッサーで4つのことをしていて

276
00:18:32,700 --> 00:18:35,000
1つが画像からフレーム画像を取り出す作業

277
00:18:35,000 --> 00:18:37,400
そしてフレーム画像をリサイズする作業

278
00:18:37,400 --> 00:18:40,700
そしてフレームの間引きをする作業と

279
00:18:40,700 --> 00:18:44,233
最後レンダリングをするという作業になっています

280
00:18:45,566 --> 00:18:47,533
まずリサイズですね

281
00:18:47,533 --> 00:18:50,700
リサイズはフレーム画像のサイズが大きいと

282
00:18:50,700 --> 00:18:52,266
メモリ使用量が増えちゃうので

283
00:18:52,266 --> 00:18:56,000
ビューで表示するサイズに合わせて画像をリサイズします

284
00:18:56,700 --> 00:18:59,700
なので画像に表示する以上のサイズを

285
00:18:59,700 --> 00:19:01,366
メモリに保持するというのは無駄なので

286
00:19:01,366 --> 00:19:03,700
実際に画像にレンダリングするサイズまで

287
00:19:03,700 --> 00:19:05,900
小さくしているということですね

288
00:19:05,900 --> 00:19:08,700
リサイズの処理が結構コストがかかるので

289
00:19:08,700 --> 00:19:11,700
ここではリサイズ後のサイズだけ決めて

290
00:19:11,700 --> 00:19:13,533
次の工程に進みます

291
00:19:14,700 --> 00:19:19,166
次は描画フレームを間引く作業ですね

292
00:19:19,166 --> 00:19:21,700
この時点で全てのフレームをデコードしたときに

293
00:19:21,700 --> 00:19:24,500
使われるメモリの量というのが計算可能なので

294
00:19:24,500 --> 00:19:27,566
それが大きすぎる場合はフレームを間引いて調整します

295
00:19:27,566 --> 00:19:31,466
例えば毎秒10フレームのGIFをキャッシュするのに

296
00:19:31,466 --> 00:19:33,266
必要なメモリが10メガだったとしたときに

297
00:19:33,266 --> 00:19:35,500
5メガまで押さえたいよってなったら

298
00:19:35,500 --> 00:19:38,166
そのフレーム数を半分にすればいいんですね

299
00:19:39,299 --> 00:19:42,700
ただ同じフレーム数を半分にする場合でも

300
00:19:42,700 --> 00:19:43,700
どのフレームを残すかによって

301
00:19:43,700 --> 00:19:45,766
アニメーションの滑らかさというのが変わってきます

302
00:19:45,766 --> 00:19:49,466
この2つの動画はどちらもフレーム数を半分にしたものなんですけど

303
00:19:49,466 --> 00:19:51,700
間引き方が異なっています

304
00:19:51,700 --> 00:19:57,200
左側は単純に後半のフレームをスキップしたもの

305
00:19:57,200 --> 00:20:00,700
右は均一に間引いたものになります

306
00:20:00,700 --> 00:20:06,133
こうすることでアニメーションのカクつきっていうのが結構抑えられているかなと思います

307
00:20:07,299 --> 00:20:10,366
計測上のパフォーマンスっていうのはここでは変わらないんですけど、

308
00:20:10,366 --> 00:20:15,599
こういった体感上のパフォーマンスっていうものを改善する工夫も重要なところかなと思います

309
00:20:16,966 --> 00:20:22,799
実際に調整している様子はこれで、この画面下のスライダーがIntegrityというパラメータで、

310
00:20:22,799 --> 00:20:27,533
1がオリジナルのフレーム数、0が最低限のフレーム数になります

311
00:20:28,266 --> 00:20:33,733
Integrityは調整していてもフレームレートが変化しているだけで、

312
00:20:33,733 --> 00:20:39,200
どの値をとってもアニメーションの連続性っていうのは保たれているかなと思います

313
00:20:40,733 --> 00:20:42,733
そして最後にレンダリングです

314
00:20:42,733 --> 00:20:46,733
これまでの工程でフレーム画像のサイズとフレーム数が決まっているので、

315
00:20:46,733 --> 00:20:50,733
実際にフレーム画像をレンダリングします

316
00:20:51,733 --> 00:20:54,233
ここで1つ問題があります

317
00:20:54,500 --> 00:20:59,333
もともとの表示サイズより小さな、リサイズの必要がないフレーム画像でも、

318
00:20:59,333 --> 00:21:03,333
必ず各フレームをレンダリングする必要があるのでしょうか

319
00:21:03,333 --> 00:21:06,333
これ、答えは実はイエスです

320
00:21:06,333 --> 00:21:08,333
次のような理由があります

321
00:21:08,333 --> 00:21:13,333
CGImageSourceから取り出されたフレーム画像を UIImage として表示すると、

322
00:21:14,033 --> 00:21:18,200
実は DGifDecompress という処理が発生します

323
00:21:18,200 --> 00:21:24,433
これは CGImageSource から取り出した GIF の CGImage というのは実は最初圧縮されていて、

324
00:21:24,666 --> 00:21:27,433
そのままでは描画することはできないんですね

325
00:21:27,433 --> 00:21:34,433
デフォルトの挙動だと UIImage は描画の直前までこのフレームを復元するという処理を遅延させるので、

326
00:21:34,433 --> 00:21:39,433
メインスレッドでこの重い復元処理というのが走ってしまうと

327
00:21:39,433 --> 00:21:43,433
これやるとスクロールの引っかかりの原因になってしまいます

328
00:21:44,666 --> 00:21:50,400
この問題を解決するために事前にバックグラウンドでフレームを復元しておく必要があるんですけど、

329
00:21:50,400 --> 00:21:57,433
UIImage の場合は byPreparingForDisplay メソッドを使うことで任意のタイミングでフレームを復元することができます

330
00:21:57,433 --> 00:22:00,433
CGImage の場合は CGContext に draw してあげれば、

331
00:22:00,433 --> 00:22:04,833
その時点で復元されたフレームで CGImage を得ることができます

332
00:22:04,833 --> 00:22:08,433
どちらも非同期で呼ぶことができるので、

333
00:22:09,133 --> 00:22:13,266
バックグラウンドスレッドで実行しておいて事前に処理しておくと、

334
00:22:13,266 --> 00:22:15,933
画面に表示される瞬間に重い処理が走って

335
00:22:15,933 --> 00:22:19,299
スクロールがかくつくというのを防げるかなと思います

336
00:22:20,433 --> 00:22:23,066
これらの最適化を実施した結果、

337
00:22:23,066 --> 00:22:26,666
1画面に50を超えるアニメーション画像を表示してもクラッシュすることなく、

338
00:22:26,666 --> 00:22:30,866
100MB以下のメモリ使用に抑えることができました

339
00:22:30,866 --> 00:22:34,433
そして最も重要なスクロールの滑らかさも維持できています

340
00:22:34,433 --> 00:22:38,933
一方で、ビューの表示とアニメーションの表示の間に若干の遅延が発生したりとか、

341
00:22:38,933 --> 00:22:41,799
フレームレートや解像度が低下しているんですけど、

342
00:22:41,799 --> 00:22:44,766
この辺りはトレードオフの結果かなと思います

343
00:22:44,766 --> 00:22:50,433
この辺は AnimatedImage だとトレードオフのパラメーターを調整できるようにしていて、

344
00:22:50,433 --> 00:22:53,700
クオリティーコントロール可能な状態にしています

345
00:22:55,066 --> 00:22:58,633
これで以上になるんですけど、本日紹介した AnimatedImage をはじめ、

346
00:22:58,633 --> 00:23:03,433
DAWN for Mastodon は主要な機能 30 を超えるOSSとして公開しています

347
00:23:03,433 --> 00:23:07,500
もしよろしければ、他のOSSもご覧いただければと思います

348
00:23:07,500 --> 00:23:12,733
今回のトーク作る中でも、まだまだ最適化の余地を見つけているので、

349
00:23:12,733 --> 00:23:15,566
今後も継続的に改善できればなと思います

350
00:23:15,566 --> 00:23:19,633
ぜひアニメーテッドイメージを使ってみて、フィードバックいただけると嬉しいです

351
00:23:19,633 --> 00:23:24,133
そして今回登場したWebP自体の細かい仕様っていうところについては、

352
00:23:24,133 --> 00:23:28,133
午後の岸川さんの作って学ぶWebP入門をご覧いただくと、

353
00:23:28,133 --> 00:23:30,766
より理解深まるんじゃないかなと思います

354
00:23:30,766 --> 00:23:34,433
以上が本日のお話でした。ご清聴ありがとうございました

355
00:23:42,066 --> 00:23:43,433
(司会) 発表ありがとうございます

356
00:23:43,433 --> 00:23:45,900
それではQ&Aに入りたいと思います

357
00:23:45,900 --> 00:23:49,433
コメントやご質問のある方は手を挙げてお知らせください

358
00:23:54,500 --> 00:23:58,333
質問がある方いらっしゃらないので、

359
00:24:00,400 --> 00:24:03,666
お時間になりましたらこれでQ&Aを終了させていただきます

360
00:24:03,666 --> 00:24:06,433
続いて1分間フィードバックのお時間です

361
00:24:28,833 --> 00:24:31,833
ご視聴ありがとうございました

362
00:24:58,833 --> 00:25:00,833
ご視聴ありがとうございました

363
00:25:00,933 --> 00:25:30,666
この後4階展示ルーム前で アスクザスピーカーを実施します

364
00:25:30,666 --> 00:25:35,933
ノッペさんに質問がある方や 感想を伝えたい方は ぜひご参加ください

365
00:25:38,700 --> 00:25:39,700
ありがとうございました

