1
00:00:00,000 --> 00:00:08,266
「Swift Build 微導覽」
「建構 Swift 新生態系的關鍵技術」
講者：giginet

2
00:00:08,266 --> 00:00:14,533
大家好，我是今天 Swift Build 之旅的導覽
giginet

3
00:00:14,533 --> 00:00:21,033
平常主要負責改善 LINE 的
建構系統與開發環境基礎設施

4
00:00:22,033 --> 00:00:25,166
今天以「Swift Build 微導覽」為題

5
00:00:25,166 --> 00:00:27,899
來看看 Swift 的建構系統吧

6
00:00:27,899 --> 00:00:33,700
今天在有明這麼大的會場講話
非常緊張

7
00:00:33,700 --> 00:00:37,033
沒想到有這麼多人
對建構系統感興趣

8
00:00:37,033 --> 00:00:38,899
請多指教

9
00:00:40,266 --> 00:00:49,966
在日常開發應用程式，或用 Swift 開發產品時
接觸建構系統的機會應該很多

10
00:00:50,766 --> 00:00:59,533
各位在開發時，按下 Xcode 的 "Build" 按鈕
就會啟動模擬器並執行應用程式

11
00:00:59,533 --> 00:01:01,266
非常簡單呢

12
00:01:03,266 --> 00:01:10,700
同樣地，可能也會用指令列（CLI）
建立 Swift 套件並進行建構

13
00:01:10,700 --> 00:01:18,633
執行 "swift build" 指令後
就能像這樣建構並執行套件

14
00:01:18,933 --> 00:01:20,266
非常方便呢

15
00:01:22,500 --> 00:01:30,766
然而，關於這兩個建構系統
在日常中會浮現各種疑問

16
00:01:30,766 --> 00:01:38,333
例如 Xcode 專案與 Package.swift
為什麼會存在這兩種定義

17
00:01:38,333 --> 00:01:49,233
那 Xcode 專案的建構，是用 Xcode Build
為什麼 Swift 套件又是用 Swift Build 來建構呢

18
00:01:49,233 --> 00:01:55,700
那 Swift Build 的指令
能不能用來建構 iOS app 呢

19
00:01:56,266 --> 00:02:02,133
反過來說，那用 Xcode Build 指令
能不能建構 Swift 套件呢

20
00:02:02,500 --> 00:02:06,799
應該常常會有這類疑問吧

21
00:02:06,799 --> 00:02:12,933
而且也有各式各樣的建構工具
應該都聽過不少吧

22
00:02:12,933 --> 00:02:19,433
平時熟悉的 Xcode
以及其指令列（CLI）工具 xcodebuild

23
00:02:19,433 --> 00:02:23,233
Swift 套件管理器（SPM）

24
00:02:23,233 --> 00:02:25,800
還有 swiftc（Swift 編譯器）

25
00:02:25,800 --> 00:02:29,433
這是 Swift 編譯器吧

26
00:02:29,433 --> 00:02:33,233
或許也有人聽過
「わいわい swiftc」(waiwai-swiftc)
這個活動呢

27
00:02:34,266 --> 00:02:36,833
還有 clang 編譯器和 ld（連結器）

28
00:02:36,833 --> 00:02:41,266
以及 llbuild 等產品

29
00:02:41,766 --> 00:02:49,766
雖然多少聽這些名字
但能說明各自職責的人應該很少吧

30
00:02:50,566 --> 00:02:58,133
不只如此，Apple 在今年二月公開了
Swift Build 這個開源專案

31
00:02:58,133 --> 00:03:01,966
這個建構系統又是什麼呢

32
00:03:01,966 --> 00:03:07,199
已經夠複雜了
現在又增加了 Swift Build

33
00:03:07,199 --> 00:03:08,900
真是讓人摸不著頭緒

34
00:03:11,266 --> 00:03:17,033
如此這般， Swift 的生態系
每年都變得更複雜

35
00:03:17,033 --> 00:03:22,866
這些元件如何相互運作
並不容易理解

36
00:03:22,866 --> 00:03:28,666
本次講座將以 Swift 的
各項開源產品為主題

37
00:03:28,666 --> 00:03:33,166
來詳細探討
這個複雜化的生態系如何運作

38
00:03:33,166 --> 00:03:35,033
一起來看看吧

39
00:03:37,266 --> 00:03:41,699
這裡先來複習一下基本的建構流程

40
00:03:41,699 --> 00:03:48,933
從 Swift 原始碼到可執行檔
會經過哪些處理呢

41
00:03:48,933 --> 00:03:52,566
執行 "swiftc" 指令

42
00:03:52,566 --> 00:03:55,933
就會像這樣建構出可執行檔

43
00:03:58,066 --> 00:04:05,133
不過實際的專案
並不像剛才的範例那樣簡單

44
00:04:05,133 --> 00:04:08,433
而是由多個 Swift 檔案組成

45
00:04:08,433 --> 00:04:13,266
而且每個檔案之間
都有相依關係（Dependency）

46
00:04:13,266 --> 00:04:20,466
在 iOS 應用程式的情況下
也需要參照 iOS SDK

47
00:04:20,466 --> 00:04:24,366
解決這些問題的作業就是連結處理 (Link)

48
00:04:24,366 --> 00:04:30,833
首先將各個原始碼編譯 建立物件檔

49
00:04:30,833 --> 00:04:34,766
最後將各個物件檔進行連結處理 (Link)

50
00:04:34,766 --> 00:04:38,466
建立可執行檔，這就是整個流程

51
00:04:38,466 --> 00:04:44,933
如果刻意將編譯與連結處理 (Link)
分開執行的話

52
00:04:44,933 --> 00:04:46,166
會像這樣

53
00:04:46,166 --> 00:04:51,100
用 swiftc 編譯器，或 C clang 編譯器

54
00:04:51,100 --> 00:04:54,433
將原始碼編譯成物件檔

55
00:04:54,433 --> 00:04:59,899
再用連結器 ld 進行連結
建立可執行檔

56
00:04:59,899 --> 00:05:04,766
這一連串的操作
可以說就是基本的建構流程

57
00:05:07,933 --> 00:05:16,333
題外話，swiftc 編譯器內部
如何運作其實也很有趣

58
00:05:16,333 --> 00:05:21,766
但本次講座的主題
是整體建構流程的概觀

59
00:05:21,766 --> 00:05:26,233
所以就不說明編譯器內部細節

60
00:05:26,233 --> 00:05:30,233
但參加過「わいわい swiftc」(waiwai-swiftc)的人

61
00:05:30,233 --> 00:05:32,933
可能看過這樣的圖

62
00:05:32,933 --> 00:05:36,233
雖然非常複雜

63
00:05:36,233 --> 00:05:38,366
但原始碼會經過各種管線(pipeline)

64
00:05:38,366 --> 00:05:41,600
最終轉換成物件檔(object)

65
00:05:41,600 --> 00:05:45,366
可以這樣理解

66
00:05:45,366 --> 00:05:50,399
好，既然了解建構的基本原理

67
00:05:50,399 --> 00:05:54,633
讓我們回到 Xcode
再按一次 Build 按鈕吧

68
00:05:54,633 --> 00:05:59,533
這時候要讓應用程式啟動
發生了什麼事呢

69
00:05:59,533 --> 00:06:04,399
這是 Xcode 上的建構紀錄

70
00:06:04,399 --> 00:06:07,033
看看這個紀錄

71
00:06:07,033 --> 00:06:11,833
從 Swift 程式碼建立物件檔

72
00:06:11,833 --> 00:06:16,033
再進行連結處理
產生應用程式的二進位檔（Binary）

73
00:06:16,033 --> 00:06:21,266
不過這只是整個建構系統的一部分

74
00:06:21,266 --> 00:06:26,333
仔細看會發現
還進行了各種其他處理

75
00:06:26,333 --> 00:06:30,899
例如建立 App Bundle

76
00:06:30,899 --> 00:06:35,666
如果有圖片等資源
會編譯資產目錄（Asset Catalog）

77
00:06:35,666 --> 00:06:41,266
最後對完成的應用程式
進行程式碼簽署

78
00:06:41,266 --> 00:06:45,333
可以看出由許多步驟構成

79
00:06:47,566 --> 00:06:51,600
像這種實際的應用程式專案

80
00:06:51,600 --> 00:06:54,533
是由許多建構步驟組成

81
00:06:54,533 --> 00:06:58,433
這些步驟不只是執行編譯器

82
00:06:58,433 --> 00:07:03,466
還包括呼叫外部工具等
基於複雜的相依關係（Dependency）

83
00:07:03,466 --> 00:07:07,333
需要有機制來排程這些大量操作

84
00:07:07,333 --> 00:07:10,533
並有效率地執行

85
00:07:10,533 --> 00:07:17,333
解決這些問題的
就是建構系統這個概念

86
00:07:17,333 --> 00:07:22,066
一般的建構系統 會確保冪等性

87
00:07:22,066 --> 00:07:26,533
也就是無論執行幾次
都會得到相同結果

88
00:07:26,533 --> 00:07:29,199
需要確保指令能這樣執行

89
00:07:29,199 --> 00:07:35,633
另外，已經建構完成的產物
可以不用重新建構就直接使用

90
00:07:35,633 --> 00:07:38,333
也需要具備快取機制

91
00:07:38,333 --> 00:07:42,633
雖然有許多知名的建構系統

92
00:07:42,633 --> 00:07:48,300
但 Swift 的建構
使用的是 llbuild 這個建構系統

93
00:07:48,300 --> 00:07:53,066
來看看 llbuild 實際的運作範例

94
00:07:53,066 --> 00:07:58,000
就像剛才的建構紀錄中所示

95
00:07:58,000 --> 00:08:03,166
列舉出建構應用程式所需的步驟

96
00:08:03,166 --> 00:08:10,233
每個建構任務
都可以定義輸入與輸出

97
00:08:10,233 --> 00:08:15,266
例如編譯的話
就是將原始碼作為輸入

98
00:08:15,266 --> 00:08:18,866
輸出物件檔，就是這樣

99
00:08:18,866 --> 00:08:24,033
接下來定義所有任務的輸入、輸出

100
00:08:24,033 --> 00:08:31,699
定義到這裡
就會發現各個任務之間存在相依關係

101
00:08:31,699 --> 00:08:40,066
例如連結處理 (Link)
必須等到所有物件檔編譯完成
才能進行連結

102
00:08:40,066 --> 00:08:48,333
另一方面原始碼或資產的編譯
可以並行處理

103
00:08:48,333 --> 00:08:54,533
建構系統會從輸入輸出
判斷相依關係（Dependency）

104
00:08:54,533 --> 00:09:01,033
規劃執行順序
以便有效率地執行

105
00:09:01,033 --> 00:09:09,033
像這樣根據輸入輸出排序的執行計畫
就叫做建構圖（Build Graph）

106
00:09:09,033 --> 00:09:13,266
這就是建構系統的基本概念

107
00:09:13,266 --> 00:09:19,766
實際看看 Xcode 的建構紀錄

108
00:09:19,766 --> 00:09:23,933
像原始碼編譯這類可並行化的處理

109
00:09:23,933 --> 00:09:27,666
會像這樣並行執行

110
00:09:30,633 --> 00:09:35,200
而 llbuild 會接收
這樣的建構任務定義

111
00:09:35,200 --> 00:09:38,766
以建構宣告檔（Manifest）的格式

112
00:09:38,766 --> 00:09:41,266
進行排程並執行

113
00:09:41,266 --> 00:09:47,133
Xcode 或 Swift 套件管理器（SPM）等
上層的建構系統

114
00:09:47,133 --> 00:09:51,966
會產生建構宣告檔（Manifest）
並交給 llbuild

115
00:09:51,966 --> 00:09:58,466
然後 llbuild 會根據這個檔案
排程並執行各個步驟

116
00:10:00,566 --> 00:10:05,799
來看看 Swift 套件管理器（SPM）
實際產生的建構宣告檔（Manifest）

117
00:10:05,799 --> 00:10:09,633
是個超大的 YAML 檔
應該看不出來寫了什麼

118
00:10:09,633 --> 00:10:15,233
放大來看
會發現定義了各個節點

119
00:10:15,233 --> 00:10:19,533
這裡寫著要執行的指令與輸入值

120
00:10:19,533 --> 00:10:22,433
以及預期的輸出

121
00:10:23,733 --> 00:10:27,533
例如輸入 Swift 原始碼

122
00:10:27,533 --> 00:10:30,266
執行 swiftc（Swift 編譯器）指令

123
00:10:30,266 --> 00:10:34,133
預期輸出物件檔

124
00:10:34,133 --> 00:10:38,666
llbuild 會接收大量這樣的節點

125
00:10:38,666 --> 00:10:42,433
並根據這些節點
組建建構圖（Build Graph）之後執行

126
00:10:42,433 --> 00:10:47,833
回顧到目前為止的流程

127
00:10:47,833 --> 00:10:50,666
為了執行大量指令

128
00:10:50,666 --> 00:10:54,033
需要 llbuild 的宣告檔（Manifest）
這點應該很清楚了

129
00:10:54,033 --> 00:10:57,100
到此終於登場的

130
00:10:57,100 --> 00:11:00,466
就是 Xcode 或 Swift 套件管理器（SPM）

131
00:11:00,466 --> 00:11:02,366
這些大家熟悉的建構系統

132
00:11:02,366 --> 00:11:05,833
它們負責建立建構宣告檔（Manifest）

133
00:11:05,833 --> 00:11:11,233
讓 llbuild 執行各種任務
這就是它們的職責

134
00:11:11,233 --> 00:11:14,933
Xcode 或 Swift 套件管理器（SPM）

135
00:11:14,933 --> 00:11:18,366
會讀取 Xcode 專案或套件

136
00:11:18,366 --> 00:11:22,933
從中建構 llbuild 的
建構宣告檔（Manifest）

137
00:11:22,933 --> 00:11:26,733
了解這些流程後

138
00:11:26,733 --> 00:11:31,866
來看看目前的情況是什麼樣子

139
00:11:31,866 --> 00:11:34,666
其實是這樣的結構

140
00:11:34,666 --> 00:11:41,033
就像這張圖所示，至今為止的建構系統

141
00:11:41,033 --> 00:11:44,399
分為 Xcode 與 Swift 套件管理器（SPM）

142
00:11:44,399 --> 00:11:50,633
它們各自用不同的機制
建立 llbuild 的宣告檔（Manifest）

143
00:11:50,633 --> 00:11:58,700
看到這個結構就能理解
開頭提到的疑問為什麼會發生

144
00:11:58,700 --> 00:12:03,866
套件宣告檔（Manifest）與 Xcode 專案
並不相容

145
00:12:03,866 --> 00:12:07,399
它們的建構路徑是完全不同的

146
00:12:07,399 --> 00:12:13,133
也因此 Swift Build 指令無法用來建構 iOS app

147
00:12:13,133 --> 00:12:19,566
這個結構中宣告檔（Manifest）
的產生部分被重複管理

148
00:12:19,566 --> 00:12:21,966
可以看出有很多浪費

149
00:12:21,966 --> 00:12:27,899
而且這些建構系統存在功能差異

150
00:12:27,899 --> 00:12:36,866
例如產生框架（Framework）等 Apple 平台特有的流程
只有 Xcode 端才有

151
00:12:36,866 --> 00:12:39,966
相反地，想建構 Linux 版本

152
00:12:39,966 --> 00:12:43,633
或巨集（Macro）、套件外掛（Plugin）
等功能

153
00:12:43,633 --> 00:12:46,333
只有 Swift 套件管理器（SPM）端有提供

154
00:12:46,333 --> 00:12:54,100
這時登場的就是本次主題的 Swift Build

155
00:12:54,100 --> 00:12:58,766
這次公開的 Swift Build

156
00:12:58,766 --> 00:13:04,033
是將 Xcode 內部使用的建構系統

157
00:13:04,033 --> 00:13:05,766
開源化的產物

158
00:13:05,766 --> 00:13:12,066
從 Xcode 16.3 開始
Swift Build 也隨 Xcode 一起發布

159
00:13:12,066 --> 00:13:16,433
而且 Swift 套件管理器（SPM）端

160
00:13:16,433 --> 00:13:20,233
也開始提供使用 Swift Build 的模式

161
00:13:20,233 --> 00:13:26,799
從 Swift 6.2 開始
可以使用 Swift Build 模式

162
00:13:28,266 --> 00:13:33,133
用 Swift 套件管理器（SPM）建構時

163
00:13:33,133 --> 00:13:38,333
傳統的建構系統
稱為原生建構系統 (Native Build System)

164
00:13:38,333 --> 00:13:43,566
將 "build-system" 參數設為 "swiftbuild"

165
00:13:43,566 --> 00:13:47,000
就能試用這個新的建構系統

166
00:13:47,000 --> 00:13:50,899
這個建構系統做了什麼事呢

167
00:13:50,899 --> 00:13:56,466
在這張圖中
就是誕生了這樣的路徑

168
00:13:56,466 --> 00:14:03,066
Swift 套件管理器（SPM）
能與 Xcode 使用相同的建構系統

169
00:14:03,066 --> 00:14:07,133
而這個 Swift Build 開源了

170
00:14:07,133 --> 00:14:09,933
這就是最近的重大變更

171
00:14:09,933 --> 00:14:17,766
可以看出這個 Swift Build 的結構
有很多優點

172
00:14:17,766 --> 00:14:23,633
關於這點
Swift 官方討論區上正在進行討論

173
00:14:23,633 --> 00:14:28,500
也介紹了移轉到 Swift Build 的目標
包括以下幾點

174
00:14:28,500 --> 00:14:33,066
首先是統一建構體驗

175
00:14:33,066 --> 00:14:38,866
如前所述， Xcode 與
Swift 套件管理器（SPM）的建構有差異

176
00:14:38,866 --> 00:14:43,766
這個功能差異是因為
作為 llbuild 的前端

177
00:14:43,766 --> 00:14:48,633
Xcode 與 SPM 有不同的實作
就如同剛才看到的

178
00:14:48,633 --> 00:14:53,666
統一體驗是目標之一

179
00:14:53,666 --> 00:15:03,600
另外在 Linux 等 app 以外的平台建構 Swift 專案時
提供一致的體驗，也是目的之一

180
00:15:03,600 --> 00:15:12,733
第二點是計畫擴充
Swift 套件的宣告檔（Manifest）功能

181
00:15:12,733 --> 00:15:22,966
例如增加目前 Swift 套件尚未支援的建構設定
或是針對 app 建構功能之類的擴充

182
00:15:24,266 --> 00:15:28,166
而且也說明了
更新到 Swift Build 後

183
00:15:28,166 --> 00:15:32,399
能大幅度的最佳化建構效率

184
00:15:32,399 --> 00:15:35,766
建構排程會變得更聰明

185
00:15:35,766 --> 00:15:37,733
並行處理效能會進一步提升

186
00:15:37,733 --> 00:15:40,666
也就是建構會變快

187
00:15:40,666 --> 00:15:45,233
還開始支援
顯式建構模組（Explicitly Build Module）

188
00:15:45,233 --> 00:15:49,266
已經開始支援這個新的建構排程機制

189
00:15:49,266 --> 00:15:55,033
這是一種先行建置專案中所有模組的策略

190
00:15:55,033 --> 00:15:58,233
能讓產物更容易重複使用

191
00:15:58,233 --> 00:16:02,566
也能進一步提升正確性與冪等性

192
00:16:03,799 --> 00:16:08,533
接下來看看 Swift Build 的運作方式

193
00:16:08,533 --> 00:16:16,233
Swift Build 為了建構 Xcode 專案
或 Swift 套件

194
00:16:16,233 --> 00:16:21,399
會以稱為 PIF（專案交換格式）
的專用格式載入專案

195
00:16:21,399 --> 00:16:27,366
之後為了建構專案
會產生建構計畫

196
00:16:27,366 --> 00:16:33,133
與 llbuild 通訊
實際執行建構圖（Build Graph）

197
00:16:33,133 --> 00:16:37,066
這個稱為 PIF（專案交換格式）的格式

198
00:16:37,066 --> 00:16:41,466
是向 Swift Build 請求建構的
專案表達方式

199
00:16:41,466 --> 00:16:45,933
用 JSON 表達類似 Xcode 專案的結構

200
00:16:45,933 --> 00:16:52,566
在剛才的圖中
用於前端建構系統的通訊

201
00:16:52,566 --> 00:17:00,433
Xcode 或 Swift 套件管理器（SPM）
已經具備輸出 PIF（專案交換格式）的機制

202
00:17:00,433 --> 00:17:03,733
有個叫 "dumpPIF" 的指令

203
00:17:03,733 --> 00:17:09,700
用這個指令將應用程式的 Xcode 專案
轉換為 PIF（專案交換格式）

204
00:17:09,700 --> 00:17:13,433
就能取得這樣的 JSON 檔案

205
00:17:13,433 --> 00:17:18,299
這與 Xcode 專案的" TARGET" 設定檔結構非常相似

206
00:17:19,733 --> 00:17:24,666
讓我們用這個 PIF（專案交換格式）
執行 Swift Build

207
00:17:24,666 --> 00:17:32,433
Swift Build 專案附帶了
稱為 "swbuild" 的指令列（CLI）介面

208
00:17:32,433 --> 00:17:37,500
將 PIF（專案交換格式）傳給它
就能建構專案

209
00:17:37,500 --> 00:17:40,633
實際執行看看

210
00:17:40,633 --> 00:17:43,866
會產生這樣的輸出來建構

211
00:17:43,866 --> 00:17:47,833
應用程式確實被建構出來了

212
00:17:51,266 --> 00:17:57,433
最後 Swift Build 會從接收到的
PIF（專案交換格式）

213
00:17:57,433 --> 00:18:00,799
產生建構計畫並執行

214
00:18:00,799 --> 00:18:03,366
關於這部分的行為

215
00:18:03,366 --> 00:18:06,200
Swift Build 內的文件有寫

216
00:18:06,200 --> 00:18:08,533
但要了解詳細行為

217
00:18:08,533 --> 00:18:11,733
似乎只能去讀原始碼

218
00:18:11,733 --> 00:18:14,533
而且非常困難

219
00:18:14,533 --> 00:18:18,566
即使讀了也很難理解

220
00:18:18,566 --> 00:18:22,966
看看 Swift Build 的原始碼

221
00:18:22,966 --> 00:18:28,599
會發現提供了各種建構任務的操作

222
00:18:28,599 --> 00:18:33,933
一開始看到的 Xcode
建構紀錄中的各個步驟

223
00:18:33,933 --> 00:18:37,033
分別對應到各個動作
可以這樣理解

224
00:18:37,033 --> 00:18:43,566
今後想知道各個建構階段
進行什麼操作時

225
00:18:43,566 --> 00:18:48,433
因為已經開源
可以輕鬆查看細節行為了

226
00:18:51,266 --> 00:18:58,233
建構任務的計畫完成後
就會執行任務

227
00:18:58,233 --> 00:19:04,433
基本上 Swift Build 會使用
llbuild 的宣告檔（Manifest）來產生任務

228
00:19:04,433 --> 00:19:07,500
並請求 llbuild 執行

229
00:19:07,500 --> 00:19:09,900
不過這時候 Swift Build

230
00:19:09,900 --> 00:19:14,333
不是只建立 llbuild 用的
宣告檔（Manifest）就結束

231
00:19:14,333 --> 00:19:18,833
實際上會與 llbuild 雙向通訊

232
00:19:18,833 --> 00:19:22,533
一邊制定執行計畫一邊執行任務

233
00:19:22,533 --> 00:19:28,200
例如一開始說明的
編譯與連結處理任務

234
00:19:28,200 --> 00:19:32,266
當需要連結處理所需的物件檔時

235
00:19:32,266 --> 00:19:35,233
llbuild 會向 Swift Build 詢問

236
00:19:35,233 --> 00:19:39,033
之後再制定編譯計畫，就是這樣的機制

237
00:19:39,033 --> 00:19:42,366
關於這部分文件有解說

238
00:19:42,366 --> 00:19:44,566
有興趣的人可以看看

239
00:19:44,566 --> 00:19:50,633
那麼 Swift Build 的職責
與內部運作的概念

240
00:19:50,633 --> 00:19:52,566
應該有所了解了

241
00:19:52,566 --> 00:19:55,666
再回到剛才的圖

242
00:19:55,666 --> 00:20:03,933
目前只有 Swift 套件管理器（SPM）
可選用 Swift Build 而已

243
00:20:03,933 --> 00:20:10,566
但未來可知 Swift 套件管理器（SPM）
預設的建構系統會變成 Swift Build

244
00:20:10,566 --> 00:20:11,666
這已經公開了

245
00:20:11,666 --> 00:20:15,000
這個結構會變得非常簡單

246
00:20:15,000 --> 00:20:19,233
所以以後 Xcode 與 Swift 套件管理器（SPM）
的建構流程會統一

247
00:20:19,233 --> 00:20:23,166
但是要實現這個目標

248
00:20:23,166 --> 00:20:25,566
還缺少許多必要功能

249
00:20:25,566 --> 00:20:34,266
像是需要重新實作一些
只有 Swift 套件管理器（SPM）的原生建構模式
才有的功能

250
00:20:34,866 --> 00:20:42,299
如果能順利實作的話
未來在套件宣告檔（Manifest）
就能進行更進階的建構流程

251
00:20:42,299 --> 00:20:45,866
而且跨平台相容也會有進展

252
00:20:45,866 --> 00:20:52,633
未來從 Xcode 專案建構 Linux 用二進位檔
或 Android 應用程式的日子

253
00:20:52,633 --> 00:20:59,166
或許也會到來
總結一下，如同一開始介紹的

254
00:20:59,166 --> 00:21:03,566
Swift 的建構系統中
出現了許多工具

255
00:21:03,566 --> 00:21:10,133
透過本次講座應該能理解
各個建構工具的職責與相互關係

256
00:21:10,133 --> 00:21:14,799
這次為了解釋 Swift Build 是什麼

257
00:21:14,799 --> 00:21:17,866
說明了建構系統的整體樣貌

258
00:21:17,866 --> 00:21:20,599
雖說是建構

259
00:21:20,599 --> 00:21:26,166
但根據需求規模
會執行各種不同的任務

260
00:21:26,166 --> 00:21:32,766
也介紹了 Swift Build 的職責與結構

261
00:21:32,766 --> 00:21:38,533
藉此能填補建構系統的功能差異

262
00:21:38,533 --> 00:21:41,933
跨平台對應也會進展，這些都已公布

263
00:21:41,933 --> 00:21:45,433
可以期待未來生態系的改善

264
00:21:45,433 --> 00:21:49,666
而且 Swift Build 開源化後

265
00:21:49,666 --> 00:21:56,666
過去是黑盒子的 Xcode 建構處理實作
現在可以詳細閱讀了

266
00:21:56,666 --> 00:22:00,566
有興趣的人請務必去看看程式庫

267
00:22:00,566 --> 00:22:03,733
希望透過本次講座

268
00:22:03,733 --> 00:22:07,133
能有更多人對 Swift 開源相關的開發產生興趣

269
00:22:07,133 --> 00:22:10,500
進而為生態系做出貢獻

270
00:22:10,500 --> 00:22:12,700
感謝各位聆聽

271
00:22:19,799 --> 00:22:21,733
感謝您的發表

272
00:22:21,733 --> 00:22:24,533
那麼接下來進入問答時間

273
00:22:24,533 --> 00:22:27,966
有意見或問題的人請舉手

274
00:22:30,866 --> 00:22:32,266
轉交麥克風

275
00:22:36,033 --> 00:22:37,166
感謝您的發表

276
00:22:37,166 --> 00:22:40,133
我有個問題

277
00:22:40,133 --> 00:22:50,900
我記得以前 XCFramework
不用 Xcode 就無法建立

278
00:22:50,900 --> 00:22:55,966
如果導入了 Swift Build

279
00:22:55,966 --> 00:22:58,900
用開源的 Swift Build

280
00:22:58,900 --> 00:23:01,900
或只用 Swift 套件管理器（SPM）

281
00:23:01,900 --> 00:23:07,000
就能建立 XCFramework
這樣理解對嗎

282
00:23:07,933 --> 00:23:18,566
是的，具體來說
這張圖沒有載明建立 XCFramework 的路線

283
00:23:18,566 --> 00:23:23,233
但原則上努力點應該是能做到的

284
00:23:23,233 --> 00:23:30,400
順帶一提
我公開了一個叫 Scipio 的第三方建構工具

285
00:23:30,400 --> 00:23:36,500
這個工具會改寫 PIF（專案交換格式）的部分

286
00:23:36,500 --> 00:23:44,566
實現用 Swift Build
從 Swift 套件建立 XCFramework

287
00:23:44,566 --> 00:23:50,333
我想未來應該能用更簡單的方式實現

288
00:23:51,566 --> 00:23:52,733
謝謝

289
00:23:56,766 --> 00:24:00,433
好的，由於時間問題
下一位會是最後一位

290
00:24:00,433 --> 00:24:04,066
有意見或問題的人請舉手

291
00:24:06,000 --> 00:24:07,666
請手下留情

292
00:24:07,666 --> 00:24:10,566
我要問個比較深入的問題

293
00:24:11,866 --> 00:24:15,266
Swift 套件管理器（SPM）
產生 PIF（專案交換格式）的流程

294
00:24:15,266 --> 00:24:22,566
以前 Swift 套件管理器（SPM）
除了原生模式之外 還有 Xcode Build 模式

295
00:24:22,566 --> 00:24:29,599
將 Xcode Build 作為下游
由 Swift 套件管理器（SPM）啟動建構的方式

296
00:24:29,599 --> 00:24:32,500
那時候會傳 PIF（專案交換格式）

297
00:24:32,500 --> 00:24:37,266
這次的話流程完全一樣

298
00:24:37,266 --> 00:24:41,333
只是傳遞的目標變成 Swift Build

299
00:24:41,333 --> 00:24:44,266
Swift Build 其實就是

300
00:24:44,266 --> 00:24:49,966
原本 xcodebuild 接收 PIF（專案交換格式）的部分

301
00:24:49,966 --> 00:24:53,299
就這樣直接開源化

302
00:24:53,299 --> 00:24:57,133
然後換個名字推出的東西，這樣理解對嗎

303
00:24:57,133 --> 00:24:58,833
好問題

304
00:24:58,833 --> 00:25:03,866
我為了避免混淆，才刻意省略的部分
被提出來了

305
00:25:03,866 --> 00:25:08,000
其實看 Xcode 16.2 以前的圖

306
00:25:08,000 --> 00:25:10,099
這裡寫著 "xcodebuild"

307
00:25:10,099 --> 00:25:16,400
原有的 xcodebuild 是完全黑盒子的狀況

308
00:25:16,400 --> 00:25:21,566
但是從 Swift 套件管理器（SPM）透過
xcodebuild 建構的路徑也存在

309
00:25:21,566 --> 00:25:24,666
所以就像您剛才說的

310
00:25:24,666 --> 00:25:31,833
幾乎相同的機制，其實從以前就有了

311
00:25:31,833 --> 00:25:39,766
不過其實 xcodebuild 模式還是存在的

312
00:25:39,766 --> 00:25:45,033
Swift Build 與 xcodebuild
是分開維護的狀況

313
00:25:45,033 --> 00:25:49,133
關於這部分我就沒有追得很深入

314
00:25:49,133 --> 00:25:53,466
但應該是高度相容的狀態

315
00:25:53,466 --> 00:25:58,666
所以理解為 xcodebuild 直接開源化了

316
00:25:58,666 --> 00:26:01,666
應該也沒什麼問題

317
00:26:01,666 --> 00:26:04,866
但那裡的實作有兩種

318
00:26:04,866 --> 00:26:07,433
這部分我就不太了解了

319
00:26:08,566 --> 00:26:09,833
謝謝

320
00:26:12,266 --> 00:26:17,133
那麼時間到了，問答環節到此結束

321
00:26:17,133 --> 00:26:20,099
接下來是一分鐘回饋時間

322
00:26:22,266 --> 00:26:31,099
翻譯：@Mori_Liu
校對：Lihsuan Chen

