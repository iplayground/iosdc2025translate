1
00:00:00,000 --> 00:00:11,520
「Swift Build 彈丸之旅」
「Swift Build 打造的新生態系」
講者：giginet
（旁白配音：立木文彥）

2
00:00:15,983 --> 00:00:22,220
大家好，我是今天 Swift Build 之旅的導覽
giginet

3
00:00:22,219 --> 00:00:28,739
平常主要負責改善 LINE 的
建構系統與開發環境基礎設施

4
00:00:29,739 --> 00:00:32,880
今天以「Swift Build 彈丸之旅」為題

5
00:00:32,880 --> 00:00:35,600
來看看 Swift 的建構系統吧

6
00:00:35,600 --> 00:00:41,399
今天在有明這麼大的會場講話
非常緊張

7
00:00:41,399 --> 00:00:44,719
沒想到有這麼多人
對建構系統感興趣

8
00:00:44,719 --> 00:00:46,600
請多指教

9
00:00:47,980 --> 00:00:57,666
在日常開發應用程式，或用 Swift 開發產品時
接觸建構系統的機會應該很多

10
00:00:58,460 --> 00:01:07,239
各位在開發時，按下 Xcode 的 "Build" 按鈕
就會啟動模擬器並執行應用程式

11
00:01:07,240 --> 00:01:08,983
非常簡單呢

12
00:01:10,983 --> 00:01:18,400
同樣地，可能也會用指令列（CLI）
建立 Swift 套件並進行建構

13
00:01:18,400 --> 00:01:26,319
執行 "swift build" 指令後
就能像這樣建構並執行套件

14
00:01:26,626 --> 00:01:27,983
非常方便呢

15
00:01:30,190 --> 00:01:38,453
然而，關於這兩個建構系統
在日常中會浮現各種疑問

16
00:01:38,450 --> 00:01:46,040
例如 Xcode 專案與 Package.swift
為什麼會存在這兩種定義

17
00:01:46,040 --> 00:01:56,940
那 Xcode 專案的建構，是用 Xcode Build
為什麼 Swift 套件又是用 Swift Build 來建構呢

18
00:01:56,939 --> 00:02:03,400
那 Swift Build 的指令
能不能用來建構 iOS App 呢

19
00:02:03,983 --> 00:02:09,820
反過來說，那用 Xcode Build 指令
能不能建構 Swift 套件呢

20
00:02:10,210 --> 00:02:14,500
應該常常會有這類疑問吧

21
00:02:14,500 --> 00:02:20,640
而且也有各式各樣的建構工具
應該都聽過不少吧

22
00:02:20,639 --> 00:02:27,139
平時熟悉的 Xcode
以及其指令列（CLI）工具 xcodebuild

23
00:02:27,139 --> 00:02:30,939
Swift 套件管理器（SPM）

24
00:02:30,939 --> 00:02:33,500
還有 swiftc（Swift 編譯器）

25
00:02:33,500 --> 00:02:37,120
這是 Swift 編譯器吧

26
00:02:37,120 --> 00:02:40,919
或許也有人聽過
「わいわい swiftc」(waiwai-swiftc)
這個活動呢

27
00:02:41,983 --> 00:02:44,520
還有 clang 編譯器和 ld（連結器）

28
00:02:44,520 --> 00:02:48,979
以及 llbuild 等產品

29
00:02:49,460 --> 00:02:57,460
雖然多少聽這些名字
但能說明各自職責的人應該很少吧

30
00:02:58,280 --> 00:03:05,840
不只如此，Apple 在今年二月公開了
Swift Build 這個開源專案

31
00:03:05,840 --> 00:03:09,659
這個建構系統又是什麼呢

32
00:03:09,659 --> 00:03:14,900
已經夠複雜了
現在又增加了 Swift Build

33
00:03:14,900 --> 00:03:16,599
真是讓人摸不著頭緒

34
00:03:18,979 --> 00:03:24,719
如此這般， Swift 的生態系
每年都變得更複雜

35
00:03:24,720 --> 00:03:30,560
這些元件如何相互運作
並不容易理解

36
00:03:30,560 --> 00:03:36,380
本次講座將以 Swift 的
各項開源產品為主題

37
00:03:36,379 --> 00:03:40,860
來詳細探討
這個複雜化的生態系如何運作

38
00:03:40,860 --> 00:03:42,720
一起來看看吧

39
00:03:44,983 --> 00:03:49,400
這裡先來複習一下基本的建構流程

40
00:03:49,400 --> 00:03:56,639
從 Swift 原始碼到可執行檔
會經過哪些處理呢

41
00:03:56,639 --> 00:04:00,280
執行 "swiftc" 指令

42
00:04:00,280 --> 00:04:03,639
就會像這樣建構出可執行檔

43
00:04:05,760 --> 00:04:12,819
不過實際的專案
並不像剛才的範例那樣簡單

44
00:04:12,819 --> 00:04:16,139
而是由多個 Swift 檔案組成

45
00:04:16,139 --> 00:04:20,959
而且每個檔案之間
都有相依關係（Dependency）

46
00:04:20,959 --> 00:04:28,160
在 iOS 應用程式的情況下
也需要參照 iOS SDK

47
00:04:28,160 --> 00:04:32,079
解決這些問題的作業就是連結處理 (Link)

48
00:04:32,079 --> 00:04:38,540
首先將各個原始碼編譯 建立物件檔

49
00:04:38,540 --> 00:04:42,459
最後將各個物件檔進行連結處理 (Link)

50
00:04:42,459 --> 00:04:46,160
建立可執行檔，這就是整個流程

51
00:04:46,160 --> 00:04:52,620
如果刻意將編譯與連結處理 (Link)
分開執行的話

52
00:04:52,620 --> 00:04:53,860
會像這樣

53
00:04:53,860 --> 00:04:58,800
用 swiftc 編譯器，或 C clang 編譯器

54
00:04:58,800 --> 00:05:02,120
將原始碼編譯成物件檔

55
00:05:02,120 --> 00:05:07,600
再用連結器 ld 進行連結
建立可執行檔

56
00:05:07,600 --> 00:05:12,459
這一連串的操作
可以說就是基本的建構流程

57
00:05:15,640 --> 00:05:24,040
題外話，swiftc 編譯器內部
如何運作其實也很有趣

58
00:05:24,040 --> 00:05:29,459
但本次講座的主題
是整體建構流程的概觀

59
00:05:29,459 --> 00:05:33,920
所以就不說明編譯器內部細節

60
00:05:33,920 --> 00:05:37,920
但參加過「わいわい swiftc」(waiwai-swiftc)的人

61
00:05:37,920 --> 00:05:40,620
可能看過這樣的圖

62
00:05:40,620 --> 00:05:43,920
雖然非常複雜

63
00:05:43,920 --> 00:05:46,079
但原始碼會經過各種管線(pipe)

64
00:05:46,079 --> 00:05:49,300
最終轉換成物件檔(object)

65
00:05:49,300 --> 00:05:53,079
可以這樣理解

66
00:05:53,079 --> 00:05:58,100
好，既然了解建構的基本原理

67
00:05:58,100 --> 00:06:02,339
讓我們回到 Xcode
再按一次 Build 按鈕吧

68
00:06:02,339 --> 00:06:07,240
這時候要讓應用程式啟動
發生了什麼事呢

69
00:06:07,240 --> 00:06:12,100
這是 Xcode 上的建構紀錄

70
00:06:12,100 --> 00:06:14,720
看看這個紀錄

71
00:06:14,720 --> 00:06:19,540
從 Swift 程式碼建立物件檔

72
00:06:19,540 --> 00:06:23,720
再進行連結處理
產生應用程式的二進位檔（Binary）

73
00:06:23,720 --> 00:06:28,980
不過這只是整個建構系統的一部分

74
00:06:28,980 --> 00:06:34,019
仔細看會發現
還進行了各種其他處理

75
00:06:34,019 --> 00:06:38,600
例如建立 App Bundle

76
00:06:38,600 --> 00:06:43,379
如果有圖片等資源
會編譯資產目錄（Asset Catalog）

77
00:06:43,379 --> 00:06:48,959
最後對完成的應用程式
進行程式碼簽署

78
00:06:48,959 --> 00:06:53,019
可以看出由許多步驟構成

79
00:06:55,260 --> 00:06:59,300
像這種實際的應用程式專案

80
00:06:59,300 --> 00:07:02,240
是由許多建構步驟組成

81
00:07:02,240 --> 00:07:06,139
這些步驟不只是執行編譯器

82
00:07:06,139 --> 00:07:11,180
還包括呼叫外部工具等
基於複雜的相依關係（Dependency）

83
00:07:11,180 --> 00:07:15,040
需要有機制來排程這些大量操作

84
00:07:15,040 --> 00:07:18,240
並有效率地執行

85
00:07:18,240 --> 00:07:25,040
解決這些問題的
就是建構系統這個概念

86
00:07:25,040 --> 00:07:29,759
一般的建構系統 會確保冪等性

87
00:07:29,759 --> 00:07:34,240
也就是無論執行幾次
都會得到相同結果

88
00:07:34,240 --> 00:07:36,899
需要確保指令能這樣執行

89
00:07:36,899 --> 00:07:43,339
另外，已經建構完成的產物
可以不用重新建構就直接使用

90
00:07:43,339 --> 00:07:46,019
也需要具備快取機制

91
00:07:46,019 --> 00:07:50,339
雖然有許多知名的建構系統

92
00:07:50,339 --> 00:07:56,000
但 Swift 的建構
使用的是 llbuild 這個建構系統

93
00:07:56,000 --> 00:08:00,779
來看看 llbuild 實際的運作範例

94
00:08:00,779 --> 00:08:05,699
就像剛才的建構紀錄中所示

95
00:08:05,699 --> 00:08:10,879
列舉出建構應用程式所需的步驟

96
00:08:10,879 --> 00:08:17,939
每個建構任務
都可以定義輸入與輸出

97
00:08:17,939 --> 00:08:22,959
例如編譯的話
就是將原始碼作為輸入

98
00:08:22,959 --> 00:08:26,560
輸出物件檔,就是這樣

99
00:08:26,560 --> 00:08:31,720
接下來定義所有任務的輸入、輸出

100
00:08:31,720 --> 00:08:39,399
定義到這裡
就會發現各個任務之間存在相依關係

101
00:08:39,399 --> 00:08:47,779
例如連結處理 (Link)
必須等到所有物件檔編譯完成
才能進行連結

102
00:08:47,779 --> 00:08:56,039
另一方面原始碼或資產的編譯
可以並行處理

103
00:08:56,039 --> 00:09:02,220
建構系統會從輸入輸出
判斷相依關係（Dependency）

104
00:09:02,220 --> 00:09:08,720
規劃執行順序
以便有效率地執行

105
00:09:08,720 --> 00:09:16,720
像這樣根據輸入輸出排序的執行計畫
就叫做建構圖（Build Graph）

106
00:09:16,720 --> 00:09:20,960
這就是建構系統的基本概念

107
00:09:20,960 --> 00:09:27,460
實際看看 Xcode 的建構紀錄

108
00:09:27,460 --> 00:09:31,620
像原始碼編譯這類可並行化的處理

109
00:09:31,620 --> 00:09:35,380
會像這樣並行執行

110
00:09:38,340 --> 00:09:42,900
而 llbuild 會接收
這樣的建構任務定義

111
00:09:42,899 --> 00:09:46,460
以建構宣告檔（Manifest）的格式

112
00:09:46,460 --> 00:09:48,960
進行排程並執行

113
00:09:48,960 --> 00:09:54,840
Xcode 或 Swift 套件管理器（SPM）等
上層的建構系統

114
00:09:54,840 --> 00:09:59,659
會產生建構宣告檔（Manifest）
並交給 llbuild

115
00:09:59,659 --> 00:10:06,179
然後 llbuild 會根據這個檔案
排程並執行各個步驟

116
00:10:08,260 --> 00:10:13,500
來看看 Swift 套件管理器（SPM）
實際產生的建構宣告檔（Manifest）

117
00:10:13,500 --> 00:10:17,340
是個超大的 YAML 檔
應該看不出來寫了什麼

118
00:10:17,340 --> 00:10:22,919
放大來看
會發現定義了各個節點

119
00:10:22,919 --> 00:10:27,240
這裡寫著要執行的指令與輸入值

120
00:10:27,240 --> 00:10:30,120
以及預期的輸出

121
00:10:31,419 --> 00:10:35,220
例如輸入 Swift 原始碼

122
00:10:35,220 --> 00:10:37,980
執行 swiftc（Swift 編譯器）指令

123
00:10:37,980 --> 00:10:41,840
預期輸出物件檔

124
00:10:41,840 --> 00:10:46,379
llbuild 會接收大量這樣的節點

125
00:10:46,379 --> 00:10:50,139
並根據這些節點
組建建構圖（Build Graph）之後執行

126
00:10:50,139 --> 00:10:55,519
回顧到目前為止的流程

127
00:10:55,519 --> 00:10:58,379
為了執行大量指令

128
00:10:58,379 --> 00:11:01,720
需要 llbuild 的宣告檔（Manifest）
這點應該很清楚了

129
00:11:01,720 --> 00:11:04,799
到此終於登場的

130
00:11:04,799 --> 00:11:08,159
就是 Xcode 或 Swift 套件管理器（SPM）

131
00:11:08,159 --> 00:11:10,059
這些大家熟悉的建構系統

132
00:11:10,059 --> 00:11:13,519
它們負責建立建構宣告檔（Manifest）

133
00:11:13,519 --> 00:11:18,940
讓 llbuild 執行各種任務
這就是它們的職責

134
00:11:18,940 --> 00:11:22,620
Xcode 或 Swift 套件管理器（SPM）

135
00:11:22,620 --> 00:11:26,080
會讀取 Xcode 專案或套件

136
00:11:26,080 --> 00:11:30,620
從中建構 llbuild 的
建構宣告檔（Manifest）

137
00:11:30,620 --> 00:11:34,440
了解這些流程後

138
00:11:34,440 --> 00:11:39,580
來看看目前的情況是什麼樣子

139
00:11:39,580 --> 00:11:42,379
其實是這樣的結構

140
00:11:42,379 --> 00:11:48,740
就像這張圖所示，至今為止的建構系統

141
00:11:48,740 --> 00:11:52,100
分為 Xcode 與 Swift 套件管理器（SPM）

142
00:11:52,100 --> 00:11:58,320
它們各自用不同的機制
建立 llbuild 的宣告檔（Manifest）

143
00:11:58,320 --> 00:12:06,399
看到這個結構就能理解
開頭提到的疑問為什麼會發生

144
00:12:06,399 --> 00:12:11,580
套件宣告檔（Manifest）與 Xcode 專案
並不相容

145
00:12:11,580 --> 00:12:15,100
它們的建構路徑是完全不同的

146
00:12:15,100 --> 00:12:20,840
也因此 Swift Build 指令無法用來建構 iOS App

147
00:12:20,840 --> 00:12:27,259
這個結構中宣告檔（Manifest）
的產生部分被重複管理

148
00:12:27,259 --> 00:12:29,659
可以看出有很多浪費

149
00:12:29,659 --> 00:12:35,600
而且這些建構系統存在功能差異

150
00:12:35,600 --> 00:12:44,580
例如產生框架（Framework）等 Apple 平台特有的流程
只有 Xcode 端才有

151
00:12:44,580 --> 00:12:47,679
相反地，想建構 Linux 版本

152
00:12:47,679 --> 00:12:51,340
或巨集（Macro）、套件外掛（Plugin）
等功能

153
00:12:51,340 --> 00:12:54,019
只有 Swift 套件管理器（SPM）端有提供

154
00:12:54,019 --> 00:13:01,799
這時登場的就是本次主題的 Swift Build

155
00:13:01,799 --> 00:13:06,480
這次公開的 Swift Build

156
00:13:06,480 --> 00:13:11,740
是將 Xcode 內部使用的建構系統

157
00:13:11,740 --> 00:13:13,480
開源化的產物

158
00:13:13,480 --> 00:13:19,779
從 Xcode 16.3 開始
Swift Build 也隨 Xcode 一起發布

159
00:13:19,779 --> 00:13:24,139
而且 Swift 套件管理器（SPM）端

160
00:13:24,139 --> 00:13:27,919
也開始提供使用 Swift Build 的模式

161
00:13:27,919 --> 00:13:34,500
從 Swift 6.2 開始
可以使用 Swift Build 模式

162
00:13:35,983 --> 00:13:40,820
用 Swift 套件管理器（SPM）建構時

163
00:13:40,820 --> 00:13:46,039
傳統的建構系統
稱為原生建構系統 (Native Build System)

164
00:13:46,039 --> 00:13:51,279
將 "build-system" 參數設為 "swiftbuild"

165
00:13:51,279 --> 00:13:54,700
就能試用這個新的建構系統

166
00:13:54,700 --> 00:13:58,600
這個建構系統做了什麼事呢

167
00:13:58,600 --> 00:14:04,179
在這張圖中
就是誕生了這樣的路徑

168
00:14:04,179 --> 00:14:10,779
Swift 套件管理器（SPM）
能與 Xcode 使用相同的建構系統

169
00:14:10,779 --> 00:14:14,840
而這個 Swift Build 開源了

170
00:14:14,840 --> 00:14:17,620
這就是最近的重大變更

171
00:14:17,620 --> 00:14:25,460
可以看出這個 Swift Build 的結構
有很多優點

172
00:14:25,460 --> 00:14:31,320
關於這點
Swift 官方討論區上正在進行討論

173
00:14:31,320 --> 00:14:36,200
也介紹了移轉到 Swift Build 的目標
包括以下幾點

174
00:14:36,200 --> 00:14:40,779
首先是統一建構體驗

175
00:14:40,779 --> 00:14:46,559
如前所述， Xcode 與
Swift 套件管理器（SPM）的建構有差異

176
00:14:46,559 --> 00:14:51,480
這個功能差異是因為
作為 llbuild 的前端

177
00:14:51,480 --> 00:14:56,320
Xcode 與 SPM 有不同的實作
就如同剛才看到的

178
00:14:56,320 --> 00:15:01,379
統一體驗是目標之一

179
00:15:01,379 --> 00:15:11,299
另外在 Linux 等 App 以外的平台建構 Swift 專案時
提供一致的體驗，也是目的之一

180
00:15:11,299 --> 00:15:20,419
第二點是計畫擴充
Swift 套件的宣告檔（Manifest）功能

181
00:15:20,419 --> 00:15:30,679
例如增加目前 Swift 套件尚未支援的建構設定
或是針對 App 建構功能之類的擴充

182
00:15:31,983 --> 00:15:35,880
而且也說明了
更新到 Swift Build 後

183
00:15:35,879 --> 00:15:40,100
能大幅度的最佳化建構效率

184
00:15:40,100 --> 00:15:43,460
建構排程會變得更聰明

185
00:15:43,460 --> 00:15:45,440
並行處理效能會進一步提升

186
00:15:45,440 --> 00:15:48,360
也就是建構會變快

187
00:15:48,360 --> 00:15:52,919
還開始支援
顯式建構模組（Explicitly Build Module）

188
00:15:52,919 --> 00:15:56,980
已經開始支援這個新的建構排程機制

189
00:15:56,980 --> 00:16:02,740
這是一種先行建置專案中所有模組的策略

190
00:16:02,740 --> 00:16:05,940
能讓產物更容易重複使用

191
00:16:05,940 --> 00:16:10,279
也能進一步提升正確性與冪等性

192
00:16:11,500 --> 00:16:16,240
接下來看看 Swift Build 的運作方式

193
00:16:16,240 --> 00:16:23,940
Swift Build 為了建構 Xcode 專案
或 Swift 套件

194
00:16:23,940 --> 00:16:29,100
會以稱為 PIF（專案交換格式）
的專用格式載入專案

195
00:16:29,100 --> 00:16:35,080
之後為了建構專案
會產生建構計畫

196
00:16:35,080 --> 00:16:40,840
與 llbuild 通訊
實際執行建構圖（Build Graph）

197
00:16:40,840 --> 00:16:44,779
這個稱為 PIF（專案交換格式）的格式

198
00:16:44,779 --> 00:16:49,159
是向 Swift Build 請求建構的
專案表達方式

199
00:16:49,159 --> 00:16:53,639
用 JSON 表達類似 Xcode 專案的結構

200
00:16:53,639 --> 00:17:00,279
在剛才的圖中
用於前端建構系統的通訊

201
00:17:00,279 --> 00:17:08,119
Xcode 或 Swift 套件管理器（SPM）
已經具備輸出 PIF（專案交換格式）的機制

202
00:17:08,119 --> 00:17:11,440
有個叫 "dumpPIF" 的指令

203
00:17:11,440 --> 00:17:17,400
用這個指令將應用程式的 Xcode 專案
轉換為 PIF（專案交換格式）

204
00:17:17,400 --> 00:17:21,119
就能取得這樣的 JSON 檔案

205
00:17:21,119 --> 00:17:26,000
這與 Xcode 專案的" TARGET" 設定檔結構非常相似

206
00:17:27,420 --> 00:17:32,360
讓我們用這個 PIF（專案交換格式）
執行 Swift Build

207
00:17:32,359 --> 00:17:40,119
Swift Build 專案附帶了
稱為 "swbuild" 的指令列（CLI）介面

208
00:17:40,119 --> 00:17:45,200
將 PIF（專案交換格式）傳給它
就能建構專案

209
00:17:45,200 --> 00:17:48,319
實際執行看看

210
00:17:48,319 --> 00:17:51,579
會產生這樣的輸出來建構

211
00:17:51,579 --> 00:17:55,519
應用程式確實被建構出來了

212
00:17:58,983 --> 00:18:05,120
最後 Swift Build 會從接收到的
PIF（專案交換格式）

213
00:18:05,119 --> 00:18:08,500
產生建構計畫並執行

214
00:18:08,500 --> 00:18:11,079
關於這部分的行為

215
00:18:11,079 --> 00:18:13,900
Swift Build 內的文件有寫

216
00:18:13,900 --> 00:18:16,240
但要了解詳細行為

217
00:18:16,240 --> 00:18:19,420
似乎只能去讀原始碼

218
00:18:19,420 --> 00:18:22,240
而且非常困難

219
00:18:22,240 --> 00:18:26,279
即使讀了也很難理解

220
00:18:26,279 --> 00:18:30,660
看看 Swift Build 的原始碼

221
00:18:30,660 --> 00:18:36,299
會發現提供了各種建構任務的操作

222
00:18:36,299 --> 00:18:41,619
一開始看到的 Xcode
建構紀錄中的各個步驟

223
00:18:41,619 --> 00:18:44,740
分別對應到各個動作
可以這樣理解

224
00:18:44,740 --> 00:18:51,259
今後想知道各個建構階段
進行什麼操作時

225
00:18:51,259 --> 00:18:56,119
因為已經開源
可以輕鬆查看細節行為了

226
00:18:58,983 --> 00:19:05,920
建構任務的計畫完成後
就會執行任務

227
00:19:05,920 --> 00:19:12,119
基本上 Swift Build 會使用
llbuild 的宣告檔（Manifest）來產生任務

228
00:19:12,119 --> 00:19:15,200
並請求 llbuild 執行

229
00:19:15,200 --> 00:19:17,599
不過這時候 Swift Build

230
00:19:17,599 --> 00:19:22,019
不是只建立 llbuild 用的
宣告檔（Manifest）就結束

231
00:19:22,019 --> 00:19:26,539
實際上會與 llbuild 雙向通訊

232
00:19:26,539 --> 00:19:30,240
一邊制定執行計畫一邊執行任務

233
00:19:30,240 --> 00:19:35,900
例如一開始說明的
編譯與連結處理任務

234
00:19:35,900 --> 00:19:39,960
當需要連結處理所需的物件檔時

235
00:19:39,960 --> 00:19:42,940
llbuild 會向 Swift Build 詢問

236
00:19:42,940 --> 00:19:46,740
之後再制定編譯計畫，就是這樣的機制

237
00:19:46,740 --> 00:19:50,059
關於這部分文件有解說

238
00:19:50,059 --> 00:19:52,279
有興趣的人可以看看

239
00:19:52,279 --> 00:19:58,319
那麼 Swift Build 的職責
與內部運作的概念

240
00:19:58,319 --> 00:20:00,279
應該有所了解了

241
00:20:00,279 --> 00:20:03,359
再回到剛才的圖

242
00:20:03,359 --> 00:20:11,640
目前只有 Swift 套件管理器（SPM）
可選用 Swift Build 而已

243
00:20:11,640 --> 00:20:18,279
但未來可知 Swift 套件管理器（SPM）
預設的建構系統會變成 Swift Build

244
00:20:18,279 --> 00:20:19,359
這已經公開了

245
00:20:19,359 --> 00:20:22,700
這個結構會變得非常簡單

246
00:20:22,700 --> 00:20:26,920
所以以後 Xcode 與 Swift 套件管理器（SPM）
的建構流程會統一

247
00:20:26,920 --> 00:20:30,859
但是要實現這個目標

248
00:20:30,859 --> 00:20:33,259
還缺少許多必要功能

249
00:20:33,260 --> 00:20:41,983
像是需要重新實作一些
只有 Swift 套件管理器（SPM）的原生建構模式
才有的功能

250
00:20:42,560 --> 00:20:50,000
如果能順利實作的話
未來在套件宣告檔（Manifest）
就能進行更進階的建構流程

251
00:20:50,000 --> 00:20:53,580
而且跨平台相容也會有進展

252
00:20:53,580 --> 00:21:00,340
未來從 Xcode 專案建構 Linux 用二進位檔
或 Android 應用程式的日子

253
00:21:00,339 --> 00:21:06,859
或許也會到來
總結一下，如同一開始介紹的

254
00:21:06,859 --> 00:21:11,259
Swift 的建構系統中
出現了許多工具

255
00:21:11,259 --> 00:21:17,839
透過本次講座應該能理解
各個建構工具的職責與相互關係

256
00:21:17,839 --> 00:21:22,500
這次為了解釋 Swift Build 是什麼

257
00:21:22,500 --> 00:21:25,579
說明了建構系統的整體樣貌

258
00:21:25,579 --> 00:21:28,299
雖說是建構

259
00:21:28,299 --> 00:21:33,880
但根據需求規模
會執行各種不同的任務

260
00:21:33,880 --> 00:21:40,460
也介紹了 Swift Build 的職責與結構

261
00:21:40,460 --> 00:21:46,220
藉此能填補建構系統的功能差異

262
00:21:46,220 --> 00:21:49,640
跨平台對應也會進展，這些都已公布

263
00:21:49,640 --> 00:21:53,119
可以期待未來生態系的改善

264
00:21:53,119 --> 00:21:57,380
而且 Swift Build 開源化後

265
00:21:57,380 --> 00:22:04,359
過去是黑盒子的 Xcode 建構處理實作
現在可以詳細閱讀了

266
00:22:04,359 --> 00:22:08,259
有興趣的人請務必去看看程式庫

267
00:22:08,259 --> 00:22:11,440
希望透過本次講座

268
00:22:11,440 --> 00:22:14,839
能有更多人對 Swift 開源相關的開發產生興趣

269
00:22:14,839 --> 00:22:18,200
進而為生態系做出貢獻

270
00:22:18,200 --> 00:22:20,400
感謝各位聆聽

271
00:22:27,500 --> 00:22:29,440
感謝您的發表

272
00:22:29,440 --> 00:22:32,220
那麼接下來進入問答時間

273
00:22:32,220 --> 00:22:35,660
有意見或問題的人請舉手

274
00:22:38,560 --> 00:22:39,983
轉交麥克風

275
00:22:43,720 --> 00:22:44,880
感謝您的發表

276
00:22:44,880 --> 00:22:47,839
我有個問題

277
00:22:47,839 --> 00:22:58,599
我記得以前 XCFramework
不用 Xcode 就無法建立

278
00:22:58,599 --> 00:23:03,680
如果導入了 Swift Build

279
00:23:03,680 --> 00:23:06,599
用開源的 Swift Build

280
00:23:06,599 --> 00:23:09,599
或只用 Swift 套件管理器（SPM）

281
00:23:09,600 --> 00:23:14,700
就能建立 XCFramework
這樣理解對嗎

282
00:23:15,620 --> 00:23:26,280
是的，具體來說
這張圖沒有載明建立 XCFramework 的路線

283
00:23:26,279 --> 00:23:30,920
但原則上努力點應該是能做到的

284
00:23:30,920 --> 00:23:38,099
順帶一提
我公開了一個叫 Scipio 的第三方建構工具

285
00:23:38,099 --> 00:23:44,200
這個工具會改寫 PIF（專案交換格式）的部分

286
00:23:44,200 --> 00:23:52,279
實現用 Swift Build
從 Swift 套件建立 XCFramework

287
00:23:52,279 --> 00:23:58,039
我想未來應該能用更簡單的方式實現

288
00:23:59,260 --> 00:24:00,420
謝謝

289
00:24:04,480 --> 00:24:08,140
好的，由於時間問題
下一位會是最後一位

290
00:24:08,140 --> 00:24:11,759
有意見或問題的人請舉手

291
00:24:13,700 --> 00:24:15,360
請手下留情

292
00:24:15,359 --> 00:24:18,279
我要問個比較深入的問題

293
00:24:19,559 --> 00:24:22,980
Swift 套件管理器（SPM）
產生 PIF（專案交換格式）的流程

294
00:24:22,980 --> 00:24:30,279
以前 Swift 套件管理器（SPM）
除了原生模式之外 還有 Xcode Build 模式

295
00:24:30,279 --> 00:24:37,299
將 Xcode Build 作為下游
由 Swift 套件管理器（SPM）啟動建構的方式

296
00:24:37,299 --> 00:24:40,200
那時候會傳 PIF（專案交換格式）

297
00:24:40,200 --> 00:24:44,980
這次的話流程完全一樣

298
00:24:44,980 --> 00:24:49,019
只是傳遞的目標變成 Swift Build

299
00:24:49,019 --> 00:24:51,960
Swift Build 其實就是

300
00:24:51,960 --> 00:24:57,680
原本 xcodebuild 接收 PIF（專案交換格式）的部分

301
00:24:57,680 --> 00:25:01,000
就這樣直接開源化

302
00:25:01,000 --> 00:25:04,839
然後換個名字推出的東西，這樣理解對嗎

303
00:25:04,839 --> 00:25:06,519
好問題

304
00:25:06,519 --> 00:25:11,579
我為了避免混淆，才刻意省略的部分
被提出來了

305
00:25:11,579 --> 00:25:15,700
其實看 Xcode 16.2 以前的圖

306
00:25:15,700 --> 00:25:17,799
這裡寫著 "xcodebuild"

307
00:25:17,799 --> 00:25:24,099
原有的 xcodebuild 是完全黑盒子的狀況

308
00:25:24,099 --> 00:25:29,259
但是從 Swift 套件管理器（SPM）透過
xcodebuild 建構的路徑也存在

309
00:25:29,259 --> 00:25:32,359
所以就像您剛才說的

310
00:25:32,359 --> 00:25:39,539
幾乎相同的機制，其實從以前就有了

311
00:25:39,539 --> 00:25:47,480
不過其實 xcodebuild 模式還是存在的

312
00:25:47,480 --> 00:25:52,720
Swift Build 與 xcodebuild
是分開維護的狀況

313
00:25:52,720 --> 00:25:56,819
關於這部分我就沒有追得很深入

314
00:25:56,819 --> 00:26:01,160
但應該是高度相容的狀態

315
00:26:01,160 --> 00:26:06,359
所以理解為 xcodebuild 直接開源化了

316
00:26:06,359 --> 00:26:09,380
應該也沒什麼問題

317
00:26:09,380 --> 00:26:12,579
但那裡的實作有兩種

318
00:26:12,579 --> 00:26:15,119
這部分我就不太了解了

319
00:26:16,260 --> 00:26:17,540
謝謝

320
00:26:19,983 --> 00:26:24,840
那麼時間到了，問答環節到此結束

321
00:26:24,839 --> 00:26:27,799
接下來是一分鐘回饋時間

322
00:26:29,983 --> 00:26:33,860
一分鐘回饋時間

323
00:26:33,859 --> 00:26:38,799
請掃描螢幕上的 QR 碼傳送回饋

