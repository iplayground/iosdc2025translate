
11
00:00:02,197 --> 00:00:04,439
早安

12
00:00:04,439 --> 00:00:06,878
是的，今天要談的是

13
00:00:06,878 --> 00:00:10,637
超過 5000 萬下載量的漫畫服務

14
00:00:10,637 --> 00:00:16,138
也就是支撐電子漫畫服務的日誌基礎架構設計開發的一切

15
00:00:16,138 --> 00:00:17,478
以此為主題

16
00:00:17,478 --> 00:00:19,838
來進行分享

17
00:00:19,838 --> 00:00:23,637
稍微自我介紹一下

18
00:00:23,637 --> 00:00:25,478
我叫 Desks

19
00:00:25,478 --> 00:00:28,637
雖然是個有點難讀的名字

20
00:00:28,637 --> 00:00:30,259
但大致上還算好念

21
00:00:30,259 --> 00:00:31,579
就是這樣

22
00:00:31,579 --> 00:00:33,378
請多指教

23
00:00:33,378 --> 00:00:34,959
我是台灣人

24
00:00:34,959 --> 00:00:37,298
在日本已經待了 9 年

25
00:00:37,298 --> 00:00:39,859
用日文沒問題

26
00:00:39,859 --> 00:00:41,798
是的，請多指教

27
00:00:41,798 --> 00:00:44,859
在 LINE Digital Frontier 股份有限公司

28
00:00:44,859 --> 00:00:46,359
工作

29
00:00:46,359 --> 00:00:47,759
興趣是

30
00:00:47,759 --> 00:00:51,298
漫畫、動畫、VTuber 等

31
00:00:51,298 --> 00:00:54,359
基本上都是宅興趣

32
00:00:54,359 --> 00:00:59,819
天氣好的時候會騎摩托車

33
00:00:59,819 --> 00:01:03,259
去兜風

34
00:01:03,259 --> 00:01:06,197
就像照片中這樣

35
00:01:06,197 --> 00:01:11,718
進入正題，今天要談的內容

36
00:01:11,718 --> 00:01:14,858
為什麼我們必須

37
00:01:14,858 --> 00:01:17,739
進行日誌系統的遷移

38
00:01:17,739 --> 00:01:22,500
以及日誌基礎架構的構建設計和實作

39
00:01:22,500 --> 00:01:26,918
還有測試程式碼，會針對性地進行分享

40
00:01:26,918 --> 00:01:33,037
由於時間關係，要全部介紹很困難，所以會針對性地介紹

41
00:01:33,037 --> 00:01:40,537
Swift 語言使用 Swift 6.1.0，也就是 Swift 6 來實作

42
00:01:40,537 --> 00:01:44,900
遷移作業，這次不是新導入

43
00:01:44,900 --> 00:01:50,418
而是從舊系統遷移到新系統，也會談到具體的作業

44
00:01:50,418 --> 00:01:53,278
關於發布

45
00:01:53,278 --> 00:01:55,977
因為是相當大規模的專案

46
00:01:55,977 --> 00:01:57,138
所以採用了比較安全的

47
00:01:57,138 --> 00:01:59,239
階段性發布

48
00:01:59,239 --> 00:02:00,596
這樣的方法

49
00:02:00,596 --> 00:02:02,656
就是這樣的感覺

50
00:02:02,656 --> 00:02:05,334
首先，範例程式碼

51
00:02:05,334 --> 00:02:07,197
放在我個人的

52
00:02:07,197 --> 00:02:08,899
GitHub 上

53
00:02:08,899 --> 00:02:11,000
如果有興趣的話

54
00:02:11,000 --> 00:02:12,836
可以下載

55
00:02:12,836 --> 00:02:13,818
試試看

56
00:02:13,818 --> 00:02:16,437
今天省略的內容全部

57
00:02:16,437 --> 00:02:19,598
都在這個範例程式碼中

58
00:02:19,598 --> 00:02:21,399
請務必參考

59
00:02:21,399 --> 00:02:26,919
首先，為什麼必須進行遷移

60
00:02:26,919 --> 00:02:33,657
其實 LINE 漫畫已經有各種日誌

61
00:02:33,657 --> 00:02:38,560
這個日誌系統即將結束服務

62
00:02:38,560 --> 00:02:39,800
會消失

63
00:02:39,800 --> 00:02:41,598
伺服器會消失

64
00:02:41,598 --> 00:02:44,318
就是這樣

65
00:02:44,318 --> 00:02:49,157
如果關閉的話，就必須收集新的日誌

66
00:02:49,157 --> 00:02:51,199
所以必須導入新系統

67
00:02:51,199 --> 00:02:52,717
就是這樣的感覺

68
00:02:52,717 --> 00:02:55,336
總之，只能做了

69
00:02:55,336 --> 00:02:59,000
遇到這種情況時

70
00:02:59,000 --> 00:03:00,979
首先會要求新的基礎架構或

71
00:03:00,979 --> 00:03:02,860
SDK

72
00:03:02,860 --> 00:03:05,479
之類的，對吧

73
00:03:05,479 --> 00:03:09,318
基礎架構或函式庫都可以

74
00:03:09,318 --> 00:03:10,776
什麼都可以，請給我

75
00:03:10,776 --> 00:03:12,019
就是這樣的感覺

76
00:03:12,019 --> 00:03:15,038
但是得到的答案是沒有

77
00:03:15,038 --> 00:03:15,639
沒有

78
00:03:15,639 --> 00:03:19,479
那就只能自己做了

79
00:03:19,479 --> 00:03:23,000
我回答說了解，然後從基礎架構

80
00:03:23,000 --> 00:03:24,560
開始製作

81
00:03:24,560 --> 00:03:31,157
在那之前，首先什麼是日誌？

82
00:03:31,157 --> 00:03:37,899
在 LINE 漫畫中，指的是收集使用者行為的日誌

83
00:03:37,899 --> 00:03:42,180
例如畫面轉換、曝光等

84
00:03:42,180 --> 00:03:46,276
某個物件、視圖、按鈕、圖片等

85
00:03:46,276 --> 00:03:51,818
進入畫面並能夠被看見的狀態

86
00:03:51,818 --> 00:03:53,538
稱為曝光

87
00:03:53,538 --> 00:03:55,459
我想大家應該都知道

88
00:03:55,459 --> 00:04:01,680
點擊、拖拽、滑動等手勢

89
00:04:01,680 --> 00:04:05,657
作為使用者的行為被收集

90
00:04:05,657 --> 00:04:10,079
製作某種資料並發送

91
00:04:10,079 --> 00:04:15,959
這實際上有很多作用

92
00:04:15,959 --> 00:04:19,079
例如作品的推薦等

93
00:04:19,079 --> 00:04:22,459
大致上透過什麼路徑

94
00:04:22,459 --> 00:04:24,120
讀什麼作品

95
00:04:24,120 --> 00:04:24,879
使用者

96
00:04:24,879 --> 00:04:28,480
這些調查統計很有用

97
00:04:28,480 --> 00:04:29,639
所以很重要

98
00:04:29,639 --> 00:04:33,180
另一方面，對故障調查也很有用

99
00:04:33,180 --> 00:04:38,439
例如觀察到某個原因不明的當機

100
00:04:38,439 --> 00:04:42,579
那麼查看該特定使用者的日誌

101
00:04:42,579 --> 00:04:45,620
當機前做了什麼

102
00:04:45,620 --> 00:04:49,459
這樣的追蹤就變得可能

103
00:04:49,459 --> 00:04:54,019
所以雖然不是主要功能，但很重要

104
00:04:54,019 --> 00:04:54,759
是的

105
00:04:54,759 --> 00:05:01,699
如剛才所說，LINE 漫畫已經嵌入了各種日誌

106
00:05:01,699 --> 00:05:02,300
是的

107
00:05:02,300 --> 00:05:07,180
這次不是談如何收集日誌

108
00:05:07,180 --> 00:05:09,439
而是如何將日誌發送到伺服器

109
00:05:09,439 --> 00:05:13,000
關於這類基礎架構的實作

110
00:05:13,000 --> 00:05:16,600
遷移的要件

111
00:05:16,600 --> 00:05:19,879
不是新導入，而是遷移

112
00:05:19,879 --> 00:05:23,139
所以如剛才所寫的

113
00:05:23,139 --> 00:05:26,360
從收集日誌的立場來看

114
00:05:26,360 --> 00:05:28,620
希望盡量保持原樣

115
00:05:28,620 --> 00:05:31,860
日誌結構、資料和名稱全部

116
00:05:31,860 --> 00:05:34,439
請保持原樣

117
00:05:34,439 --> 00:05:39,819
也希望能提供同等功能

118
00:05:39,819 --> 00:05:43,180
在遷移期間作為適應期

119
00:05:43,180 --> 00:05:44,040
雙重發送

120
00:05:44,040 --> 00:05:48,160
也就是舊系統和新系統同時

121
00:05:48,160 --> 00:05:51,519
存在的狀態下，向兩邊都發送日誌

122
00:05:51,519 --> 00:05:55,579
這是相當重要的要件之一

123
00:05:55,579 --> 00:05:58,278
這次不進行強制更新

124
00:05:58,278 --> 00:05:59,699
被這樣告知

125
00:05:59,699 --> 00:06:04,699
這對之後的發布計畫有很大影響

126
00:06:04,699 --> 00:06:06,838
這裡請記住

127
00:06:06,838 --> 00:06:09,740
關於日誌系統

128
00:06:09,740 --> 00:06:11,819
要件已經了解了

129
00:06:11,819 --> 00:06:14,459
但日誌系統到底是什麼樣的？

130
00:06:14,459 --> 00:06:16,740
這是根本的問題

131
00:06:16,740 --> 00:06:19,399
不能阻塞主執行緒

132
00:06:19,399 --> 00:06:21,579
畢竟只是發送日誌

133
00:06:21,579 --> 00:06:24,399
不要過度使用系統資源

134
00:06:24,399 --> 00:06:28,019
因為大家都很愛看漫畫

135
00:06:28,019 --> 00:06:29,980
卡頓會很討厭

136
00:06:29,980 --> 00:06:32,658
不能壓迫記憶體

137
00:06:32,658 --> 00:06:35,240
希望控制通訊量

138
00:06:35,240 --> 00:06:38,879
連帶著，也希望控制電力消耗

139
00:06:38,879 --> 00:06:42,500
限制相當嚴格

140
00:06:42,500 --> 00:06:45,740
即使這樣說也不明白

141
00:06:45,740 --> 00:06:50,759
所以轉換成更技術性的規格

142
00:06:50,759 --> 00:06:54,538
首先，我考慮的是

143
00:06:54,538 --> 00:06:58,860
資料型別設為 Dictionary ，鍵為 String

144
00:06:58,860 --> 00:07:01,019
值設為 Sendable

145
00:07:01,019 --> 00:07:07,459
因為說不能妨礙主執行緒

146
00:07:07,459 --> 00:07:10,899
所以使用 Concurrent 的異步處理

147
00:07:10,899 --> 00:07:12,860
切換到其他執行緒

148
00:07:12,860 --> 00:07:15,240
優先級設為 Utility

149
00:07:15,240 --> 00:07:17,379
這樣

150
00:07:17,379 --> 00:07:20,677
並行進行發送處理

151
00:07:20,677 --> 00:07:22,720
緩衝區和資料的持久化

152
00:07:22,720 --> 00:07:26,177
不直接發送，不即時發送

153
00:07:26,177 --> 00:07:28,418
而是暫時保存

154
00:07:28,418 --> 00:07:31,000
關於通訊

155
00:07:31,000 --> 00:07:32,579
為了節省資料量

156
00:07:32,579 --> 00:07:33,798
進行壓縮

157
00:07:33,798 --> 00:07:36,177
gzip 或 deflate

158
00:07:36,177 --> 00:07:37,899
是可以考慮的手段

159
00:07:37,899 --> 00:07:40,000
為了保證 QoS

160
00:07:40,000 --> 00:07:42,199
加入 Exponential Backoff

161
00:07:42,199 --> 00:07:44,838
這樣的重試機制

162
00:07:44,838 --> 00:07:48,177
這個基礎架構當然

163
00:07:48,177 --> 00:07:49,120
難得做了

164
00:07:49,120 --> 00:07:50,838
做成 Swift Package

165
00:07:50,838 --> 00:07:54,879
指定 Swift 6.1.0

166
00:07:54,879 --> 00:07:58,399
這大致就是決定的規格

167
00:07:58,399 --> 00:08:00,579
在那之前

168
00:08:00,579 --> 00:08:01,939
在實作之前

169
00:08:01,939 --> 00:08:04,819
關於 Swift 6 的重點稍微說明一下

170
00:08:04,819 --> 00:08:06,879
我想大家應該都知道

171
00:08:06,879 --> 00:08:10,079
首先，升級到 Swift 6 後

172
00:08:10,079 --> 00:08:12,819
會出現很多建置錯誤

173
00:08:12,819 --> 00:08:16,579
大致上改善這些就能解決

174
00:08:16,579 --> 00:08:20,259
具體來說，大多是 Sendable 的錯誤

175
00:08:20,259 --> 00:08:22,038
加上 Sendable 就好了

176
00:08:22,038 --> 00:08:22,319
首先

177
00:08:22,319 --> 00:08:27,120
要加上 Sendable ，首先不要建立變數

178
00:08:27,120 --> 00:08:31,220
無論如何都必須建立的情況下

179
00:08:31,220 --> 00:08:31,839
變數

180
00:08:31,839 --> 00:08:34,057
那就設為 actor

181
00:08:34,057 --> 00:08:38,220
這成為基本原則

182
00:08:38,220 --> 00:08:42,139
之後的原始碼也大致是這樣的感覺

183
00:08:42,139 --> 00:08:45,240
無論如何都無法適用 Sendable 的情況

184
00:08:45,240 --> 00:08:48,200
就針對性地加上 unchecked Sendable

185
00:08:48,200 --> 00:08:56,418
另一方面，測試案例之後會介紹

186
00:08:56,418 --> 00:08:59,519
隨便加上 unchecked Sendable

187
00:08:59,519 --> 00:09:05,500
因為不是產品程式碼，所以不需要嚴格要求

188
00:09:05,500 --> 00:09:07,418
我是這樣想的

189
00:09:07,418 --> 00:09:13,700
接下來介紹一切的開始， Digest Loop

190
00:09:13,700 --> 00:09:16,360
首先，因為不即時發送日誌

191
00:09:16,360 --> 00:09:18,639
所以會暫時保存

192
00:09:18,639 --> 00:09:20,860
所以發送處理

193
00:09:20,860 --> 00:09:22,580
大致是這樣的邏輯

194
00:09:22,580 --> 00:09:25,480
有資料儲存之類的東西

195
00:09:25,480 --> 00:09:29,580
只要有資料就執行 while 迴圈

196
00:09:29,580 --> 00:09:31,960
在 while 迴圈中

197
00:09:31,960 --> 00:09:34,080
從資料儲存

198
00:09:34,080 --> 00:09:36,940
取出一些資料

199
00:09:36,940 --> 00:09:41,080
以 chunk 為單位發送

200
00:09:41,080 --> 00:09:45,620
發送成功後刪除資料

201
00:09:45,620 --> 00:09:49,038
發生錯誤時從 while 迴圈脫離並中斷

202
00:09:49,038 --> 00:09:51,658
資料儲存沒有資料時

203
00:09:51,658 --> 00:09:55,480
從 while 迴圈脫離

204
00:09:55,480 --> 00:10:00,480
這樣的 Digest Loop 是基本的核心邏輯

205
00:10:00,480 --> 00:10:03,980
讓我們稍微關注這個原始碼

206
00:10:03,980 --> 00:10:07,860
這裡有資料儲存之類的

207
00:10:07,860 --> 00:10:11,038
這樣的組件

208
00:10:11,038 --> 00:10:12,460
還有網路客戶端

209
00:10:12,460 --> 00:10:16,038
還有容納這個 while 迴圈的

210
00:10:16,038 --> 00:10:17,759
某個 class 是必要的

211
00:10:17,759 --> 00:10:19,759
稱為 Dispatcher

212
00:10:19,759 --> 00:10:24,677
DataToSend 這個神秘的結構體

213
00:10:24,677 --> 00:10:27,740
這也是某種型別

214
00:10:27,740 --> 00:10:31,379
所以從這裡橫向展開

215
00:10:31,379 --> 00:10:34,019
會連接到什麼話題

216
00:10:34,019 --> 00:10:37,500
就是架構的話題

217
00:10:37,500 --> 00:10:41,820
首先，剛才看到的某個名稱

218
00:10:41,820 --> 00:10:43,158
讓我們決定名稱

219
00:10:43,158 --> 00:10:45,740
例如 entity 設為 TrackingData

220
00:10:45,740 --> 00:10:47,139
這樣命名

221
00:10:47,139 --> 00:10:49,278
Dispatcher

222
00:10:49,278 --> 00:10:51,557
TrackingDispatcher

223
00:10:51,557 --> 00:10:54,840
SQLDataStore、NetworkClient 等

224
00:10:54,840 --> 00:10:56,759
決定具體的名稱

225
00:10:56,759 --> 00:11:00,500
實際對外使用的公開介面是

226
00:11:00,500 --> 00:11:02,580
Tracker

227
00:11:02,580 --> 00:11:04,158
這樣命名

228
00:11:04,158 --> 00:11:06,418
如剛才所見

229
00:11:06,418 --> 00:11:13,360
切分了層級，所以可以從組件切分層級

230
00:11:13,360 --> 00:11:16,740
看起來可能不明白，所以畫了圖

231
00:11:16,740 --> 00:11:20,700
這只表示相依關係和協定符合

232
00:11:20,700 --> 00:11:28,139
大致是這樣的構成，例如紅色部分是 entity 和 dispatcher

233
00:11:28,139 --> 00:11:33,418
中間夾著協定

234
00:11:33,418 --> 00:11:36,620
順便一提，看過這樣的圖嗎？

235
00:11:36,620 --> 00:11:41,658
Clean Architecture 等，有很多圓圈圍繞

236
00:11:41,658 --> 00:11:42,658
比較看看

237
00:11:42,658 --> 00:11:45,519
會是這樣的構成

238
00:11:45,519 --> 00:11:51,440
請仔細看箭頭，指向內部

239
00:11:51,440 --> 00:11:56,700
所以符合 Clean Architecture 中箭頭的原則

240
00:11:56,700 --> 00:11:59,798
所以算是某種 Clean Architecture

241
00:11:59,798 --> 00:12:02,918
是自然的構成

242
00:12:02,918 --> 00:12:10,677
總之是容易測試、低耦合、容易替換相依的構成

243
00:12:10,677 --> 00:12:14,519
這就是架構的整體像

244
00:12:14,519 --> 00:12:18,600
實體是這樣簡單的資料

245
00:12:18,600 --> 00:12:25,460
總之分配 ID，其中是

246
00:12:25,460 --> 00:12:30,778
日誌的原始資料直接序列化保存

247
00:12:30,778 --> 00:12:36,940
定義了這樣的結構體

248
00:12:36,940 --> 00:12:44,778
當然加上了 Sendable

249
00:12:44,778 --> 00:12:49,840
使用案例是這樣的構成

250
00:12:49,840 --> 00:12:57,200
Dispatcher 周圍有協定

251
00:12:57,200 --> 00:13:02,220
這樣的相依關係

252
00:13:02,220 --> 00:13:07,918
程式碼展開是這樣，但 Dispatcher 只有一個方法

253
00:13:07,918 --> 00:13:18,158
sendLog，以名稱和 Dictionary 陣列為參數

254
00:13:18,158 --> 00:13:23,399
資料儲存是 save、get、delete 等常見的 CRUD

255
00:13:23,399 --> 00:13:30,298
網路更簡單，只是發送，所以是 async 函數

256
00:13:30,298 --> 00:13:36,158
這裡的重點當然是加上 Sendable

257
00:13:36,158 --> 00:13:44,418
外側沒什麼好說的，單純是具體實作

258
00:13:44,418 --> 00:13:51,340
按照協定實作就好

259
00:13:51,340 --> 00:13:55,340
定義了 CREATE TABLE 的查詢

260
00:13:55,340 --> 00:14:00,259
只有 2 個欄位，primary key 的 integer 和 app log

261
00:14:00,259 --> 00:14:05,200
直接保存的簡單構成

262
00:14:05,200 --> 00:14:09,720
為什麼使用 SQLite，可能有人會問

263
00:14:09,720 --> 00:14:15,139
簡單的 schema 是第一個原因

264
00:14:15,139 --> 00:14:22,658
這樣的構成今後應該不會有遷移

265
00:14:22,658 --> 00:14:29,379
SQLite 就足夠了

266
00:14:29,379 --> 00:14:34,580
iOS 標準搭載，不需要額外的函式庫

267
00:14:34,580 --> 00:14:39,817
這次採用簡單的 SQLite

268
00:14:39,817 --> 00:14:44,960
馬上就會遇到障礙，因為是 C 函式庫

269
00:14:44,960 --> 00:14:49,639
所以處理指標，在 Swift 中是 opaque pointer

270
00:14:49,639 --> 00:14:53,519
遺憾的是在 Swift Evolution 0331 中 Sendable 被移除了

271
00:14:53,519 --> 00:14:57,500
所以無論如何都無法建置

272
00:14:57,500 --> 00:15:01,177
那怎麼辦呢？

273
00:15:01,177 --> 00:15:05,177
還記得嗎？針對性地加上 unchecked Sendable

274
00:15:05,177 --> 00:15:12,619
所以準備這樣的包裝器，隱藏 opaque pointer

275
00:15:12,619 --> 00:15:17,099
當然不是隨便的 Sendable，而是加上鎖

276
00:15:17,099 --> 00:15:21,980
這樣至少這個是安全的

277
00:15:21,980 --> 00:15:25,700
套用後是這樣的構成

278
00:15:25,700 --> 00:15:32,057
資料庫指標隱藏在內部，所以變得簡潔

279
00:15:32,057 --> 00:15:35,057
而且確實是 Sendable

280
00:15:35,057 --> 00:15:38,740
CRUD 的實作這次省略

281
00:15:38,740 --> 00:15:48,019
只是對 SQLite 執行 query 實作，大家應該都能做到

282
00:15:48,019 --> 00:15:50,817
就這樣，加油吧

283
00:15:50,817 --> 00:15:57,677
開玩笑的，範例程式碼中有，請看看

284
00:15:57,677 --> 00:16:01,057
稍微談談測試

285
00:16:01,057 --> 00:16:10,817
只是 CRUD，所以只要測試 I/O 處理的正常情況

286
00:16:10,817 --> 00:16:17,658
這裡的重點是加上 Suite .serialize 這個巨集

287
00:16:17,658 --> 00:16:21,220
為什麼呢？因為直接操作檔案系統

288
00:16:21,220 --> 00:16:24,677
Swift Testing 預設是

289
00:16:24,677 --> 00:16:30,618
與 XCTest 不同，是並行處理

290
00:16:30,618 --> 00:16:34,000
所以測試案例執行時會發生競爭

291
00:16:34,000 --> 00:16:35,778
所以這裡設為序列化

292
00:16:35,778 --> 00:16:37,139
這是重點

293
00:16:37,139 --> 00:16:38,576
是的

294
00:16:38,576 --> 00:16:42,118
資料庫就說到這裡

295
00:16:42,118 --> 00:16:44,240
接下來是網路客戶端

296
00:16:44,240 --> 00:16:47,778
這是圖的右下部分

297
00:16:47,778 --> 00:16:49,220
首先

298
00:16:49,220 --> 00:16:53,557
URLSession 等 HTTP 客戶端

299
00:16:53,557 --> 00:16:55,576
不直接硬編碼

300
00:16:55,576 --> 00:16:58,240
而是夾入協定

301
00:16:58,240 --> 00:17:01,519
可能會壓縮

302
00:17:01,519 --> 00:17:06,720
所以假設 5kB

303
00:17:06,720 --> 00:17:12,220
定義常數來壓縮 body

304
00:17:12,220 --> 00:17:15,920
這樣的網路處理

305
00:17:15,920 --> 00:17:24,019
順便一提，處理重試等待時間的 Task sleep

306
00:17:24,019 --> 00:17:27,519
suspend 函數也作為閉包放入

307
00:17:27,519 --> 00:17:35,640
這是協定 conformance 的主體前半部分

308
00:17:35,640 --> 00:17:39,420
如果 deflate 的大小符合條件

309
00:17:39,420 --> 00:17:43,778
在 header 加上 encoding 進行壓縮

310
00:17:43,778 --> 00:17:46,380
否則普通發送

311
00:17:46,380 --> 00:17:50,400
後半部分是重試的部分

312
00:17:50,400 --> 00:17:53,660
執行 repeat while

313
00:17:53,660 --> 00:18:00,038
夾入 suspend 進行發送

314
00:18:00,038 --> 00:18:07,759
壓縮演算法這裡使用 zlib

315
00:18:07,759 --> 00:18:08,960
是的

316
00:18:08,960 --> 00:18:10,920
看伺服器而定

317
00:18:10,920 --> 00:18:13,759
什麼壓縮演算法都可以

318
00:18:13,759 --> 00:18:15,880
只要能接受就好

319
00:18:15,880 --> 00:18:18,096
順便一提，Compression Framework

320
00:18:18,096 --> 00:18:19,778
是 Apple 官方的

321
00:18:19,778 --> 00:18:20,700
試過了

322
00:18:20,700 --> 00:18:22,420
但沒成功

323
00:18:22,420 --> 00:18:27,038
所以使用經典的 zlib 實作

324
00:18:27,038 --> 00:18:31,076
稍微談談測試

325
00:18:31,076 --> 00:18:33,096
這樣的構成

326
00:18:33,096 --> 00:18:34,940
全部可以用 Mock 注入

327
00:18:34,940 --> 00:18:38,355
所以等待秒數也能完全控制

328
00:18:38,355 --> 00:18:41,019
例如返回 400 錯誤的

329
00:18:41,019 --> 00:18:43,298
Networking 注入

330
00:18:43,298 --> 00:18:45,500
可以觀察到

331
00:18:45,500 --> 00:18:48,076
第一次發送和 3 次重試

332
00:18:48,076 --> 00:18:51,420
總共 4 次發送的斷言

333
00:18:51,420 --> 00:18:53,038
秒數是 2、4、8

334
00:18:53,038 --> 00:18:54,940
2 的 n 次方

335
00:18:54,940 --> 00:18:57,336
可以控制

336
00:18:57,336 --> 00:18:59,519
終於到 Dispatcher 了

337
00:18:59,519 --> 00:19:04,259
資料儲存

338
00:19:04,259 --> 00:19:07,115
網路和錯誤處理器

339
00:19:07,115 --> 00:19:10,519
將製作的組件放入處理

340
00:19:10,519 --> 00:19:12,259
Task

341
00:19:12,259 --> 00:19:15,298
這裡出現了 var

342
00:19:15,298 --> 00:19:16,576
是 actor

343
00:19:16,576 --> 00:19:19,355
用 actor

344
00:19:19,355 --> 00:19:22,019
另外

345
00:19:22,019 --> 00:19:22,660
這裡

346
00:19:22,660 --> 00:19:26,115
Override Executor

347
00:19:26,115 --> 00:19:27,759
為什麼

348
00:19:27,759 --> 00:19:31,140
必須這樣做？

349
00:19:31,140 --> 00:19:33,278
是為了簡化處理

350
00:19:33,278 --> 00:19:36,855
actor 本身

351
00:19:36,855 --> 00:19:38,960
內部的

352
00:19:38,960 --> 00:19:40,440
var 的 Data Race

353
00:19:40,440 --> 00:19:43,380
會避免

354
00:19:43,380 --> 00:19:46,355
但內部處理的順序

355
00:19:46,355 --> 00:19:50,759
就不知道了

356
00:19:50,759 --> 00:19:54,880
所以這裡故意設為序列化

357
00:19:54,880 --> 00:20:01,140
這個日誌系統是簡單的構成

358
00:20:01,140 --> 00:20:04,200
不需要那麼多並行

359
00:20:04,200 --> 00:20:05,920
總之先設為序列化

360
00:20:05,920 --> 00:20:09,740
這樣下功夫

361
00:20:09,740 --> 00:20:11,778
Digest Loop

362
00:20:11,778 --> 00:20:14,500
應該看起來很熟悉

363
00:20:14,500 --> 00:20:16,240
將 while 迴圈放入 Task 中

364
00:20:16,240 --> 00:20:17,460
執行

365
00:20:17,460 --> 00:20:20,440
Digest 的主體

366
00:20:20,440 --> 00:20:22,160
順便一提

367
00:20:22,160 --> 00:20:25,057
最後加上 yield

368
00:20:25,057 --> 00:20:27,115
這個函數

369
00:20:27,115 --> 00:20:33,317
可以想成是時間未定的 Task.sleep

370
00:20:33,317 --> 00:20:34,519
目的是

371
00:20:34,519 --> 00:20:38,298
讓給其他優先級高的

372
00:20:38,298 --> 00:20:39,740
優先級

373
00:20:39,740 --> 00:20:42,900
這是很好的構成

374
00:20:42,900 --> 00:20:44,519
所以在這裡

375
00:20:44,519 --> 00:20:46,057
加入 Task.yield

376
00:20:46,057 --> 00:20:53,817
Digest 的主體

377
00:20:53,817 --> 00:20:58,160
單純取出資料發送

378
00:20:58,160 --> 00:21:01,096
發送成功後刪除

379
00:21:01,096 --> 00:21:06,200
資料的保存

380
00:21:06,200 --> 00:21:08,278
準備 Digest 開始和結束的函數

381
00:21:08,278 --> 00:21:10,519
Protocol Conformance

382
00:21:10,519 --> 00:21:16,778
序列化後發送，就這樣

383
00:21:16,778 --> 00:21:22,660
測試當然全部用 Mock

384
00:21:22,660 --> 00:21:25,900
例如這樣的感覺

385
00:21:25,900 --> 00:21:31,200
放入 70 件日誌

386
00:21:31,200 --> 00:21:36,259
開始 Digest 後發送了 2 次

387
00:21:36,259 --> 00:21:39,380
71 件發送的斷言

388
00:21:39,380 --> 00:21:42,538
接下來是並行處理

389
00:21:42,538 --> 00:21:49,000
用 Task Group 大量開始 Digest

390
00:21:49,000 --> 00:21:51,420
沒有重複發送，很好地發送了

391
00:21:51,420 --> 00:21:53,759
Tracker 主體

392
00:21:53,759 --> 00:21:55,538
不需要做什麼

393
00:21:55,538 --> 00:21:57,660
將所有組件放入

394
00:21:57,660 --> 00:22:00,140
準備通用介面就好

395
00:22:00,140 --> 00:22:02,317
使用方法是這樣

396
00:22:02,317 --> 00:22:04,836
放入真實的實作

397
00:22:04,836 --> 00:22:07,519
在這裡放入 Task.sleep

398
00:22:07,519 --> 00:22:09,298
隱藏 URLSession 的網路包裝器

399
00:22:09,298 --> 00:22:12,019
測試覆蓋率

400
00:22:12,019 --> 00:22:14,355
字很小，是 82.6%

401
00:22:14,355 --> 00:22:15,900
相當高

402
00:22:15,900 --> 00:22:19,480
終於基礎架構完成了

403
00:22:19,480 --> 00:22:22,680
但這不是結束

404
00:22:22,680 --> 00:22:24,355
進入遷移作業

405
00:22:24,355 --> 00:22:28,480
例如現在的狀況

406
00:22:28,480 --> 00:22:30,980
有舊的日誌

407
00:22:30,980 --> 00:22:34,259
想要 Dual send 到剛才做的 Tracker

408
00:22:34,259 --> 00:22:36,115
想要 Dual send

409
00:22:36,115 --> 00:22:38,220
那麼這樣的

410
00:22:38,220 --> 00:22:41,538
Adapter Pattern 是可以考慮的

411
00:22:41,538 --> 00:22:44,076
總之在這個包裝器中

412
00:22:44,076 --> 00:22:45,557
發送到兩邊

413
00:22:45,557 --> 00:22:47,057
遺憾的是

414
00:22:47,057 --> 00:22:48,440
這做不到

415
00:22:48,440 --> 00:22:50,038
為什麼？

416
00:22:50,038 --> 00:22:52,180
因為日誌

417
00:22:52,180 --> 00:22:55,180
現實沒那麼順利

418
00:22:55,180 --> 00:22:58,400
能直接發送的日誌

419
00:22:58,400 --> 00:23:00,460
本來就不多

420
00:23:00,460 --> 00:23:03,076
API 的介面也

421
00:23:03,076 --> 00:23:08,460
不合，採用這個方法會產生大量對應邏輯

422
00:23:08,460 --> 00:23:15,538
會變成這樣，效能也不太好

423
00:23:15,538 --> 00:23:21,660
所以放棄了，那怎麼辦？用毅力

424
00:23:21,660 --> 00:23:29,680
用毅力，預先找出所有的日誌呼叫

425
00:23:29,680 --> 00:23:36,355
一個一個修改，作業量龐大，很辛苦

426
00:23:36,355 --> 00:23:42,038
不是全部都不好，老實說效能是針對性修改的

427
00:23:42,038 --> 00:23:47,278
所以效能相對較好

428
00:23:47,278 --> 00:23:53,680
難得重新檢視，總之這個日誌是什麼？

429
00:23:53,680 --> 00:23:57,317
一邊討論一邊刪除不需要的

430
00:23:57,317 --> 00:23:59,836
這就是重構

431
00:23:59,836 --> 00:24:03,480
就是這樣的時機

432
00:24:03,480 --> 00:24:06,855
不然永遠做不到

433
00:24:06,855 --> 00:24:09,640
作為正面因素

434
00:24:09,640 --> 00:24:12,240
實際做的事情

435
00:24:12,240 --> 00:24:13,596
例如這樣的日誌

436
00:24:13,596 --> 00:24:16,180
以點擊為例

437
00:24:16,180 --> 00:24:18,740
有舊的 Tap 事件日誌

438
00:24:18,740 --> 00:24:22,057
Tracker 也提供新的 Tap 事件

439
00:24:22,057 --> 00:24:26,096
這些分別呼叫基礎架構的 API

440
00:24:26,096 --> 00:24:27,480
然後

441
00:24:27,480 --> 00:24:29,920
舊的

442
00:24:29,920 --> 00:24:32,019
在舊的加上方法

443
00:24:32,019 --> 00:24:33,740
然後這樣

444
00:24:33,740 --> 00:24:35,298
連接到新的

445
00:24:35,298 --> 00:24:36,057
是的

446
00:24:36,057 --> 00:24:38,980
這樣連接

447
00:24:38,980 --> 00:24:39,317
這樣

448
00:24:39,317 --> 00:24:43,400
返回 self

449
00:24:43,400 --> 00:24:45,817
所以變成 fluent interface

450
00:24:45,817 --> 00:24:47,180
這樣

451
00:24:47,180 --> 00:24:47,380
是的

452
00:24:47,380 --> 00:24:49,460
這樣連接

453
00:24:49,460 --> 00:24:50,680
啊

454
00:24:50,680 --> 00:24:54,096
fluent interface

455
00:24:54,096 --> 00:24:55,259
所以容易使用

456
00:24:55,259 --> 00:24:59,140
首先這樣寫，用眼睛就能看出

457
00:24:59,140 --> 00:25:01,019
這是 Dual Send 對應完成

458
00:25:01,019 --> 00:25:05,778
所以不需要手動修改的日誌

459
00:25:05,778 --> 00:25:09,400
夾入這樣的好方法就好

460
00:25:09,400 --> 00:25:10,855
就是這樣的感覺

461
00:25:10,855 --> 00:25:14,317
需要個別修改的地方

462
00:25:14,317 --> 00:25:18,720
這樣並列，個別實作

463
00:25:18,720 --> 00:25:22,259
例如這個例子

464
00:25:22,259 --> 00:25:24,615
改變了鍵

465
00:25:24,615 --> 00:25:26,700
item id 改為 new item id

466
00:25:26,700 --> 00:25:28,880
實際我做的作業

467
00:25:28,880 --> 00:25:31,317
不只是這麼簡單的作業

468
00:25:31,317 --> 00:25:32,278
有很多

469
00:25:32,278 --> 00:25:34,400
有幾種模式

470
00:25:34,400 --> 00:25:35,460
努力了

471
00:25:35,460 --> 00:25:38,220
結果

472
00:25:38,220 --> 00:25:40,519
真的很辛苦

473
00:25:40,519 --> 00:25:42,798
從中途開始

474
00:25:42,798 --> 00:25:44,400
作業中途

475
00:25:44,400 --> 00:25:48,019
我到底在做什麼？

476
00:25:48,019 --> 00:25:50,180
我為什麼在這裡？

477
00:25:50,180 --> 00:25:52,220
懷疑人生

478
00:25:52,220 --> 00:25:57,700
作業量非常龐大

479
00:25:57,700 --> 00:26:03,000
懷著這樣的心情

480
00:26:03,000 --> 00:26:09,160
反覆討論這個日誌到底是什麼？

481
00:26:09,160 --> 00:26:12,038
結果成功減少了 payload size

482
00:26:12,038 --> 00:26:14,480
有很多共通參數

483
00:26:14,480 --> 00:26:17,336
不需要就刪除

484
00:26:17,336 --> 00:26:23,596
所以新系統成功減少了資料量

485
00:26:23,596 --> 00:26:27,057
舊系統就這樣保留

486
00:26:27,057 --> 00:26:31,538
這就是遷移作業的話題

487
00:26:31,538 --> 00:26:35,057
接下來

488
00:26:35,057 --> 00:26:38,519
既然做了東西，就必須發布

489
00:26:38,519 --> 00:26:40,660
發布計畫

490
00:26:40,660 --> 00:26:45,220
剛才也談到階段性遷移

491
00:26:45,220 --> 00:26:47,740
有很多優點

492
00:26:47,740 --> 00:26:49,880
我想大家應該都有做

493
00:26:49,880 --> 00:26:53,200
canary 發布這樣的方法

494
00:26:53,200 --> 00:26:54,836
有很多優點

495
00:26:54,836 --> 00:26:57,740
發現問題時

496
00:26:57,740 --> 00:26:59,038
立即停止

497
00:26:59,038 --> 00:27:00,680
可以止血

498
00:27:00,680 --> 00:27:03,115
有很多優點

499
00:27:03,115 --> 00:27:06,180
如果變成大事故

500
00:27:06,180 --> 00:27:07,817
必須出 hot fix

501
00:27:07,817 --> 00:27:09,096
的話

502
00:27:09,096 --> 00:27:11,538
會變成很辛苦的作業

503
00:27:11,538 --> 00:27:13,557
會有很多人動起來

504
00:27:13,557 --> 00:27:17,836
所以這樣大規模的遷移

505
00:27:17,836 --> 00:27:20,836
總之建議階段性遷移

506
00:27:20,836 --> 00:27:22,000
可以控制

507
00:27:22,000 --> 00:27:27,940
伺服器負載分散也有這樣的面向

508
00:27:27,940 --> 00:27:29,798
逐漸開放

509
00:27:29,798 --> 00:27:33,940
如果一氣發布很多日誌

510
00:27:33,940 --> 00:27:36,740
新系統的伺服器

511
00:27:36,740 --> 00:27:39,836
不知道能不能承受

512
00:27:39,836 --> 00:27:42,615
所以這真的有必要

513
00:27:42,615 --> 00:27:45,615
順便一提，大家還記得嗎？

514
00:27:45,615 --> 00:27:48,200
不進行強制更新

515
00:27:48,200 --> 00:27:52,038
所以這也需要對策

516
00:27:52,038 --> 00:27:57,640
為什麼？因為不進行強制更新

517
00:27:57,640 --> 00:28:03,420
一直使用舊 app 的使用者

518
00:28:03,420 --> 00:28:07,640
會一直向舊系統發送日誌

519
00:28:07,640 --> 00:28:10,440
所以不強制更新

520
00:28:10,440 --> 00:28:13,019
這樣的發送會一直持續

521
00:28:13,019 --> 00:28:16,259
剛才說過，伺服器會消失

522
00:28:16,259 --> 00:28:21,076
所以會一直向不存在的伺服器發送資料

523
00:28:21,076 --> 00:28:25,298
所以為什麼不進行強制更新？

524
00:28:25,298 --> 00:28:28,740
純粹是使用者流失等

525
00:28:28,740 --> 00:28:31,596
UX 相關的擔憂

526
00:28:31,596 --> 00:28:32,920
盡量不要做

527
00:28:32,920 --> 00:28:37,680
那就必須考慮中間手段

528
00:28:37,680 --> 00:28:42,900
所以如剛才所說，不更新的使用者

529
00:28:42,900 --> 00:28:45,596
會一直向舊系統發送

530
00:28:45,596 --> 00:28:48,420
也談到成本削減

531
00:28:48,420 --> 00:28:50,440
我想剛才說過

532
00:28:50,440 --> 00:28:56,298
所以需要 2 種控制

533
00:28:56,298 --> 00:29:01,538
對舊系統準備阻斷日誌的 flag

534
00:29:01,538 --> 00:29:05,057
對新系統是階段性 rollout

535
00:29:05,057 --> 00:29:07,980
所以也準備 flag

536
00:29:07,980 --> 00:29:10,400
對使用者的比例

537
00:29:10,400 --> 00:29:12,278
逐漸開放

538
00:29:12,278 --> 00:29:16,000
這裡的重點是

539
00:29:16,000 --> 00:29:19,615
阻斷控制預設是 true

540
00:29:19,615 --> 00:29:20,596
全開放

541
00:29:20,596 --> 00:29:22,380
硬編碼

542
00:29:22,380 --> 00:29:25,259
例如 flag 不存在時

543
00:29:25,259 --> 00:29:27,880
程式碼中硬編碼的值

544
00:29:27,880 --> 00:29:29,180
設為 false

545
00:29:29,180 --> 00:29:32,557
rollout 相反

546
00:29:32,557 --> 00:29:35,019
從 false 變為 true

547
00:29:35,019 --> 00:29:40,096
無論如何，預設值都是最終狀態

548
00:29:40,096 --> 00:29:45,519
所以 flag 可以從 Firebase 最終刪除

549
00:29:45,519 --> 00:29:53,400
刪除後會按照最終狀態運作

550
00:29:53,400 --> 00:29:55,720
這樣的設定

551
00:29:55,720 --> 00:29:59,076
實績

552
00:29:59,076 --> 00:30:03,278
2024 年 10 月

553
00:30:03,278 --> 00:30:06,140
已經預先發布了阻斷控制

554
00:30:06,140 --> 00:30:09,740
所以大約 1 年前

555
00:30:09,740 --> 00:30:15,259
這個 true 值

556
00:30:15,259 --> 00:30:18,259
花時間

557
00:30:18,259 --> 00:30:21,960
讓 flag 滲透，預先發布

558
00:30:21,960 --> 00:30:26,160
控制實作也隔 1 個月

559
00:30:26,160 --> 00:30:28,038
加入控制實作

560
00:30:28,038 --> 00:30:34,380
所以對舊系統什麼都沒發生

561
00:30:34,380 --> 00:30:37,180
當然已經嵌入了 flag

562
00:30:37,180 --> 00:30:42,460
之後改變 flag，舊系統的發送也會全部消失

563
00:30:42,460 --> 00:30:43,817
就是這樣的感覺

564
00:30:43,817 --> 00:30:47,336
這樣就不需要強制更新

565
00:30:47,336 --> 00:30:51,740
新系統的實績

566
00:30:51,740 --> 00:30:57,115
今年 1 月將 flag 設為 false，100%開放

567
00:30:57,115 --> 00:31:06,615
4 月

568
00:31:06,615 --> 00:31:11,038
4 月 10 日左右

569
00:31:11,038 --> 00:31:14,640
實際使用 calendar versioning

570
00:31:14,640 --> 00:31:19,000
發布時期是這個時候

571
00:31:19,000 --> 00:31:23,880
分 5 階段

572
00:31:23,880 --> 00:31:30,576
4 月上旬立即觀察到故障，暫時設為 0%

573
00:31:30,576 --> 00:31:37,000
設法修復後，沒問題就跳到 50%

574
00:31:37,000 --> 00:31:40,460
之後按計畫

575
00:31:40,460 --> 00:31:46,115
結果沒有 hot fix，非常好

576
00:31:46,115 --> 00:31:49,739
物理穩定性也好，心理安心

577
00:31:49,739 --> 00:31:53,199
特別是安心非常重要

578
00:31:53,199 --> 00:31:55,679
焦慮真的很辛苦

579
00:31:55,679 --> 00:31:57,679
真的

580
00:31:57,679 --> 00:31:59,159
用穩健的手段

581
00:31:59,159 --> 00:32:01,778
發布是推薦的

582
00:32:01,778 --> 00:32:05,900
flag 的控制等

583
00:32:05,900 --> 00:32:07,000
相當

584
00:32:07,000 --> 00:32:08,679
在計畫階段

585
00:32:08,679 --> 00:32:09,557
這樣

586
00:32:09,557 --> 00:32:11,679
決定 true false

587
00:32:11,679 --> 00:32:13,538
所以

588
00:32:13,538 --> 00:32:15,134
這樣

589
00:32:15,134 --> 00:32:16,719
沒有殘留

590
00:32:16,719 --> 00:32:20,317
不會造成 flag 永遠無法刪除的狀態

591
00:32:20,317 --> 00:32:22,159
強制更新當然

592
00:32:22,159 --> 00:32:27,940
沒有進行，現在還在 dual send 期間

593
00:32:27,940 --> 00:32:34,719
所以還有一點

594
00:32:34,719 --> 00:32:40,440
發布後是監控，如果有 crash 就修正

595
00:32:40,440 --> 00:32:44,317
調查原因修正，還有還沒做

596
00:32:44,317 --> 00:32:49,480
控制 flag 的刪除、舊實作的刪除等任務

597
00:32:49,480 --> 00:32:54,659
還留著，這是工程師最興奮的階段

598
00:32:54,659 --> 00:33:01,000
刪除不需要的實作，一口氣產生 2000 行的紅色數字

599
00:33:01,000 --> 00:33:08,259
的差異，還沒做，但很期待

600
00:33:08,259 --> 00:33:17,076
距離目標還有一點，進入總結

601
00:33:17,076 --> 00:33:22,199
首先談了日誌系統到底是什麼？行為日誌是什麼？

602
00:33:22,199 --> 00:33:30,317
從一開始考慮的 Digest Loop 這個核心邏輯

603
00:33:30,317 --> 00:33:33,836
展開到介面設計、架構的話題

604
00:33:33,836 --> 00:33:36,817
當然是 Clean SOLID 的構成

605
00:33:36,817 --> 00:33:42,836
基於 Swift 6 的實作進行介紹

606
00:33:42,836 --> 00:33:46,380
針對性地介紹了測試程式碼

607
00:33:46,380 --> 00:33:51,480
完整的原始碼在範例 repository 中，請看看

608
00:33:51,480 --> 00:33:54,855
當然這是自製的

609
00:33:54,855 --> 00:33:57,134
基本上都是我做的

610
00:33:57,134 --> 00:34:04,778
今後功能擴展或想加什麼功能

611
00:34:04,778 --> 00:34:07,380
不需要依賴外部人員

612
00:34:07,380 --> 00:34:09,900
公司內部解決

613
00:34:09,900 --> 00:34:12,539
這是內製化的優點

614
00:34:12,840 --> 00:34:22,018
雖然我很辛苦，開玩笑的，基礎架構製作其實很有趣，大家有機會一定要試試，一點都不可怕

615
00:34:22,018 --> 00:34:39,179
總結 2，介紹了遷移作業的方法，雖然有優雅的 Adapter Pattern，但現實沒那麼順利，通常都是這樣

616
00:34:39,179 --> 00:34:42,518
理想終究是理想

617
00:34:42,518 --> 00:34:44,780
所以基本上

618
00:34:44,780 --> 00:34:47,119
咬緊牙關用毅力

619
00:34:47,119 --> 00:34:49,639
一定要用毅力

620
00:34:49,639 --> 00:34:51,599
用毅力做了

621
00:34:51,599 --> 00:34:54,300
結果很好

622
00:34:54,300 --> 00:34:57,500
也完成了重構

623
00:34:57,500 --> 00:34:58,920
很好

624
00:34:58,920 --> 00:35:00,699
Helper 方法等

625
00:35:00,699 --> 00:35:03,039
個別實作的具體手段

626
00:35:03,039 --> 00:35:05,099
透過原始碼

627
00:35:05,099 --> 00:35:06,920
總結 3

628
00:35:06,920 --> 00:35:08,360
這裡很簡單

629
00:35:08,360 --> 00:35:10,739
要點是

630
00:35:10,739 --> 00:35:12,518
對舊系統

631
00:35:12,518 --> 00:35:14,159
設為 false 後

632
00:35:14,159 --> 00:35:15,260
變為 true

633
00:35:15,260 --> 00:35:16,900
相反

634
00:35:16,900 --> 00:35:20,199
設為 true 後變為 false

635
00:35:20,199 --> 00:35:22,699
對新系統的 rollout

636
00:35:22,699 --> 00:35:25,659
從 false 變為 true

637
00:35:25,659 --> 00:35:28,860
config 可以刪除

638
00:35:28,860 --> 00:35:30,480
的構成

639
00:35:30,480 --> 00:35:32,500
這樣的安排

640
00:35:32,500 --> 00:35:33,280
很好

641
00:35:33,280 --> 00:35:36,679
不需要強制更新

642
00:35:36,679 --> 00:35:39,599
如果這有參考價值

643
00:35:39,599 --> 00:35:43,739
這次日誌 rollout 分了 5 階段

644
00:35:43,739 --> 00:35:47,518
分幾階段都可以，這裡隨意

645
00:35:47,518 --> 00:35:50,119
附帶一提

646
00:35:50,119 --> 00:35:54,400
雖然做了基本的日誌基礎架構

647
00:35:54,400 --> 00:35:56,739
還有很多事情要做

648
00:35:56,739 --> 00:35:59,699
配合 CPU 使用率、記憶體

649
00:35:59,699 --> 00:36:01,559
調整發送速度

650
00:36:01,559 --> 00:36:03,420
這樣的工夫可以考慮

651
00:36:03,420 --> 00:36:05,880
遊戲 app 或即時 app 等

652
00:36:05,880 --> 00:36:07,380
對效能要求嚴格

653
00:36:07,380 --> 00:36:09,000
的 app

654
00:36:09,000 --> 00:36:10,900
日誌系統可以考慮

655
00:36:10,900 --> 00:36:13,940
這些因素

656
00:36:13,940 --> 00:36:16,219
磁碟容量

657
00:36:16,219 --> 00:36:17,719
相當危險

658
00:36:17,719 --> 00:36:19,539
使用者無法開啟資料庫

659
00:36:19,539 --> 00:36:21,659
的情況

660
00:36:21,659 --> 00:36:23,119
這裡

661
00:36:23,119 --> 00:36:25,340
fallback 到記憶體資料儲存

662
00:36:25,340 --> 00:36:26,880
這樣

663
00:36:26,880 --> 00:36:28,860
這樣

664
00:36:28,860 --> 00:36:31,539
不改變基礎架構的行為

665
00:36:31,539 --> 00:36:34,539
替換相依

666
00:36:34,539 --> 00:36:35,619
就變成記憶體

667
00:36:35,619 --> 00:36:37,179
這樣的手段

668
00:36:37,179 --> 00:36:39,460
離線環境

669
00:36:39,460 --> 00:36:42,199
例如在飛機上

670
00:36:42,199 --> 00:36:44,000
無法發送

671
00:36:44,000 --> 00:36:46,719
監控 Reachability

672
00:36:46,719 --> 00:36:48,800
不發送

673
00:36:48,800 --> 00:36:50,280
Wi-Fi 連上後

674
00:36:50,280 --> 00:36:52,219
大量發送

675
00:36:52,219 --> 00:36:54,480
這樣的工夫可以考慮

676
00:36:54,480 --> 00:36:57,460
以上就是全部

677
00:36:57,460 --> 00:36:59,239
重複

678
00:36:59,239 --> 00:37:00,699
參考

679
00:37:00,699 --> 00:37:02,599
還有原始碼 repository

680
00:37:02,599 --> 00:37:04,360
範例程式碼在這裡

681
00:37:04,360 --> 00:37:05,440
請看看

682
00:37:05,440 --> 00:37:07,920
稍微宣傳一下

683
00:37:07,920 --> 00:37:09,340
會舉辦 after event

684
00:37:09,340 --> 00:37:10,518
這裡

685
00:37:10,518 --> 00:37:13,139
LINE 漫畫的幕後故事

686
00:37:13,139 --> 00:37:15,599
ebookjapan 等的幕後故事

687
00:37:15,599 --> 00:37:17,659
預定分享

688
00:37:17,659 --> 00:37:20,280
時間是下個月

689
00:37:20,280 --> 00:37:22,219
10 月 17 日

690
00:37:22,219 --> 00:37:23,699
還有一點時間

691
00:37:23,699 --> 00:37:24,460
19 點

692
00:37:24,460 --> 00:37:26,320
地點是我們辦公室

693
00:37:26,320 --> 00:37:30,079
六本木東京 Midtown 11 樓

694
00:37:30,079 --> 00:37:32,360
connpass 頁面在這裡

695
00:37:32,360 --> 00:37:34,380
請務必來

696
00:37:34,380 --> 00:37:36,239
準備了美味的食物

697
00:37:36,239 --> 00:37:42,980
以上就是支撐 LINE 漫畫的日誌基礎架構設計開發的全部

698
00:37:42,980 --> 00:37:45,239
分享完畢

699
00:37:45,239 --> 00:37:47,900
感謝聆聽

700
00:37:47,900 --> 00:37:58,280
感謝發表
