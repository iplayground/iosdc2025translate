1
00:02:02,420 --> 00:02:07,460
iOSDC Japan 2025

2
00:02:07,880 --> 00:02:09,280
Track C

3
00:02:10,040 --> 00:02:11,175
NEXT

4
00:02:13,080 --> 00:02:17,440
支撐超過 5000 萬下載量漫畫服務的

5
00:02:17,640 --> 00:02:20,592
日誌(log)基礎架構設計開發完全解析

6
00:02:21,700 --> 00:02:25,820
dsxs（デスクス）

7
00:02:32,975 --> 00:02:33,660
大家早安！

8
00:02:34,520 --> 00:02:36,060
是的，今天我要分享的主題是

9
00:02:36,300 --> 00:02:39,640
支撐超過 5000 萬下載量的漫畫服務

10
00:02:39,639 --> 00:02:45,139
或者說電子漫畫服務的日誌基礎架構設計開發的完全解析

11
00:02:45,139 --> 00:02:46,479
我就以此為題

12
00:02:46,480 --> 00:02:49,080
來進行分享

13
00:02:50,180 --> 00:02:52,640
先簡單自我介紹一下

14
00:02:53,000 --> 00:02:54,700
我叫 dsxs

15
00:02:55,120 --> 00:02:57,975
這名字有點難念

16
00:02:58,180 --> 00:02:59,520
很容易咬到舌頭

17
00:02:59,700 --> 00:03:00,780
就是就這樣

18
00:03:00,897 --> 00:03:02,515
請多多指教

19
00:03:02,728 --> 00:03:03,822
我是台灣人

20
00:03:03,960 --> 00:03:06,391
來日本已經 9 年了

21
00:03:06,960 --> 00:03:08,860
日文沒問題

22
00:03:08,860 --> 00:03:10,800
歡迎用日文交流

23
00:03:10,977 --> 00:03:14,728
目前在LINE Digital Frontier公司工作

24
00:03:15,360 --> 00:03:16,759
我的興趣是

25
00:03:16,759 --> 00:03:20,300
漫畫、動畫、VTuber 等等

26
00:03:20,300 --> 00:03:23,360
基本上都是宅興趣啦

27
00:03:25,150 --> 00:03:32,260
不過天氣好的時候也會騎重機出去兜風

28
00:03:32,259 --> 00:03:35,199
就像照片裡這樣

29
00:03:35,199 --> 00:03:40,719
好，進入正題，今天要談的內容包括：

30
00:03:40,719 --> 00:03:43,860
首先，為什麼我們必須要

31
00:03:43,860 --> 00:03:47,022
進行日誌系統的移轉

32
00:03:47,160 --> 00:03:51,680
日誌基礎架構的建構設計與實作

33
00:03:51,840 --> 00:03:56,088
還有測試程式碼，我會針對重點部分來分享

34
00:03:56,177 --> 00:04:02,168
由於時間關係，無法全部介紹，所以只挑重點來講

35
00:04:02,524 --> 00:04:09,128
Swift 語言方面，使用 Swift 6.1.0，也就是用 Swift 6 來實作

36
00:04:09,422 --> 00:04:13,900
這次的移轉作業不是新導入

37
00:04:13,900 --> 00:04:19,564
而是從舊系統移轉到新系統，我也會談到具體的作業內容

38
00:04:20,195 --> 00:04:22,400
關於發布

39
00:04:22,400 --> 00:04:24,980
因為這次是大規模的更動

40
00:04:24,980 --> 00:04:29,600
所以我們採取了比較安全的階段性發布策略

41
00:04:30,364 --> 00:04:32,168
就這樣

42
00:04:32,551 --> 00:04:37,899
首先，範例程式碼我已經放在個人的 GitHub 上

43
00:04:38,260 --> 00:04:42,933
如果有興趣的話可以下載來玩玩看

44
00:04:43,084 --> 00:04:48,600
今天省略的內容全部都在這個範例程式碼裡

45
00:04:49,137 --> 00:04:51,128
請務必參考看看

46
00:04:51,730 --> 00:04:56,337
那麼，為什麼我們必須移轉系統呢？

47
00:04:56,808 --> 00:05:02,660
其實 LINE 漫畫 app 裡已經寫有各式各樣的日誌

48
00:05:02,660 --> 00:05:07,560
但這個日誌系統即將結束服務

49
00:05:07,560 --> 00:05:08,800
會消失

50
00:05:09,048 --> 00:05:10,808
連伺服器整個都會端掉

51
00:05:11,448 --> 00:05:13,320
就是如此

52
00:05:13,320 --> 00:05:20,199
就算系統沒了，日誌還是得收集的，所以必須導入新系統

53
00:05:20,817 --> 00:05:21,893
就這狀況

54
00:05:21,890 --> 00:05:24,213
換句話說　不做不行啊

55
00:05:26,426 --> 00:05:28,000
遇到這種情況

56
00:05:28,000 --> 00:05:34,480
首先你會去要看看有沒有新的基盤或 SDK 可以用對吧？

57
00:05:35,271 --> 00:05:41,019
基盤或函式庫都可以，什麼都行，總之我是去要了啦

58
00:05:41,404 --> 00:05:44,639
結果得到的答案是沒有

59
00:05:46,675 --> 00:05:48,657
那就只能自己做了

60
00:05:48,660 --> 00:05:53,560
我回答說「了解！」，然後就從基礎架構開始做啦

61
00:05:55,004 --> 00:06:00,160
在那之前，先說明一下「什麼是日誌」

62
00:06:00,160 --> 00:06:06,899
在 LINE 漫畫中，日誌指的是記錄使用者行為的資料

63
00:06:06,899 --> 00:06:11,180
例如：畫面轉換、曝光（Impression）等等

64
00:06:11,180 --> 00:06:15,279
當曝光，就是某個物件、視圖、按鈕、圖片等等

65
00:06:15,279 --> 00:06:20,819
進入畫面並能夠被使用者看見的狀態

66
00:06:20,819 --> 00:06:22,540
我們稱為曝光（Impression）

67
00:06:22,540 --> 00:06:24,459
我想大家應該都知道這個概念

68
00:06:24,459 --> 00:06:30,680
還有點擊、拖拽、滑動等各種手勢操作

69
00:06:30,680 --> 00:06:34,660
這些使用者行為都會被記錄下來

70
00:06:34,660 --> 00:06:39,079
製作成某種資料並發送出去

71
00:06:40,053 --> 00:06:44,960
這些日誌實際上有很多用途

72
00:06:44,959 --> 00:06:48,079
例如：作品推薦功能

73
00:06:48,079 --> 00:06:53,879
可以分析使用者大致上是透過什麼路徑閱讀了哪些作品

74
00:06:53,879 --> 00:06:57,480
這對調查統計很有幫助

75
00:06:57,480 --> 00:06:58,639
所以非常重要

76
00:06:58,639 --> 00:07:02,180
另一方面，對於故障調查也很有用

77
00:07:02,180 --> 00:07:07,439
例如，我們觀察到某個原因不明的閃退的話

78
00:07:07,439 --> 00:07:11,579
就可以查看該特定使用者的日誌

79
00:07:11,579 --> 00:07:14,620
追蹤閃退前做了什麼操作

80
00:07:14,620 --> 00:07:18,459
如此追蹤就變得可能

81
00:07:18,933 --> 00:07:23,020
所以雖然日誌不是主要功能，但確實很重要

82
00:07:24,408 --> 00:07:30,700
如同我剛才說的，LINE 漫畫已經埋入了各式各樣的日誌

83
00:07:31,300 --> 00:07:36,180
這次要談的不是如何收集日誌

84
00:07:36,180 --> 00:07:38,439
而是如何將日誌發送到伺服器

85
00:07:38,439 --> 00:07:42,000
關於這類基礎架構的實作

86
00:07:43,271 --> 00:07:45,600
移轉的需求方面

87
00:07:46,444 --> 00:07:48,880
不是新導入，而是移轉

88
00:07:48,879 --> 00:07:52,139
所以如我剛才寫的

89
00:07:52,139 --> 00:07:55,360
從收集日誌的立場（部門）來看的話

90
00:07:55,360 --> 00:07:57,620
他們當然希望盡量一切保持原樣

91
00:07:57,620 --> 00:08:00,860
日誌的結構、資料和名稱

92
00:08:00,860 --> 00:08:03,439
全部請保持原樣，這就是我所聽到的需求

93
00:08:03,439 --> 00:08:08,819
同時他們也希望能維持與舊系統同樣的功能

94
00:08:08,819 --> 00:08:12,180
在移轉期間，作為適應期

95
00:08:12,180 --> 00:08:13,040
需要做雙重發送（Dual Send）

96
00:08:13,040 --> 00:08:17,160
也就是在舊系統和新系統同時

97
00:08:17,160 --> 00:08:20,519
存在的狀態下，向兩邊都發送日誌

98
00:08:21,422 --> 00:08:24,580
這也是重要的需求之一

99
00:08:24,579 --> 00:08:27,279
另外，這次不進行強制更新

100
00:08:27,608 --> 00:08:28,800
我被告知說這次不做強更

101
00:08:29,404 --> 00:08:33,700
這對之後的發布計畫有很大影響

102
00:08:33,700 --> 00:08:35,840
這點請大家先記住

103
00:08:36,453 --> 00:08:38,740
關於日誌系統

104
00:08:38,740 --> 00:08:40,820
需求是理解了

105
00:08:40,820 --> 00:08:43,460
但日誌系統到底要做成什麼樣子呢？

106
00:08:43,460 --> 00:08:48,399
首先最基本的，不能阻塞主執行緒

107
00:08:48,399 --> 00:08:50,580
畢竟只是發送日誌而已

108
00:08:50,580 --> 00:08:53,399
我們不希望過度使用系統資源

109
00:08:53,786 --> 00:08:57,020
畢竟大家用這 app 就是要看漫畫

110
00:08:57,019 --> 00:08:58,980
如果畫面卡頓的話使用者會感到煩

111
00:08:59,475 --> 00:09:01,660
所以不能壓迫記憶體

112
00:09:01,659 --> 00:09:04,240
同時希望控制通訊量

113
00:09:04,240 --> 00:09:07,879
連帶著，也希望降低電力消耗

114
00:09:07,880 --> 00:09:10,568
規格要求的很嚴峻齁

115
00:09:11,500 --> 00:09:14,740
我這樣說可能大家還搞不太清楚

116
00:09:14,740 --> 00:09:19,759
所以讓我把它轉換成更技術性的規格

117
00:09:19,759 --> 00:09:23,539
首先，我考慮的是

118
00:09:23,539 --> 00:09:27,860
資料型別設為 Dictionary，鍵（Key）設為 String

119
00:09:27,860 --> 00:09:30,019
值（Value）設為 Sendable

120
00:09:32,773 --> 00:09:36,460
因為說不能妨礙主執行緒

121
00:09:36,460 --> 00:09:39,899
所以採用併發（Concurrent）的非同步處理策略

122
00:09:39,899 --> 00:09:41,860
切一條別的執行緒

123
00:09:41,860 --> 00:09:44,240
把優先級設為 Utility

124
00:09:44,240 --> 00:09:46,379
就這樣

125
00:09:46,379 --> 00:09:49,679
以並行方式送日誌

126
00:09:49,679 --> 00:09:51,720
緩衝區和資料的持久化也做

127
00:09:51,720 --> 00:09:55,179
不直接發送，不即時發送

128
00:09:55,179 --> 00:09:57,419
而是先暫存

129
00:09:58,186 --> 00:10:00,000
通訊方面

130
00:10:00,000 --> 00:10:01,580
為了節省資料量

131
00:10:01,580 --> 00:10:02,799
我們對資料進行壓縮

132
00:10:02,799 --> 00:10:06,899
gzip 或 deflate 都是可以考慮的方案

133
00:10:06,899 --> 00:10:09,000
為了保證 QoS（服務品質）

134
00:10:09,000 --> 00:10:13,840
我們做 Exponential Backoff 這樣的重試機制

135
00:10:13,840 --> 00:10:17,179
這個基礎架構想當然爾

136
00:10:17,179 --> 00:10:18,120
難得都做到這程度了

137
00:10:18,120 --> 00:10:19,840
乾脆做成 Swift Package

138
00:10:19,840 --> 00:10:23,879
指定版本 6.1.0，也就是 Swift 6

139
00:10:23,879 --> 00:10:27,399
這大致就是定好的規格

140
00:10:28,213 --> 00:10:30,940
在談實作之前

141
00:10:30,940 --> 00:10:33,820
讓我說明一下 Swift 6 的重點

142
00:10:33,820 --> 00:10:35,879
我想大家應該都知道的齁

143
00:10:35,879 --> 00:10:39,080
首先，升級到 Swift 6 之後

144
00:10:39,080 --> 00:10:41,820
會出現一大堆編譯錯誤對吧

145
00:10:41,820 --> 00:10:45,580
基本上把這些錯誤修掉就差不多了

146
00:10:45,580 --> 00:10:49,259
具體來說，大多是 Sendable 的錯誤

147
00:10:49,259 --> 00:10:51,320
所以基本上　總之加上 Sendable 就好了

148
00:10:51,320 --> 00:10:56,120
要加上 Sendable 的話，就不要寫 var

149
00:10:56,120 --> 00:11:00,840
如果無論如何都要寫變數的話

150
00:11:00,840 --> 00:11:03,059
那就寫成 actor

151
00:11:03,059 --> 00:11:07,220
這就是基本原則

152
00:11:07,220 --> 00:11:11,139
之後的原始碼也大致是這樣的感覺

153
00:11:11,139 --> 00:11:14,240
如果遇到實在無法套用 Sendable 的情況

154
00:11:14,240 --> 00:11:17,200
就針對性地加上 @unchecked Sendable

155
00:11:20,533 --> 00:11:25,420
另一方面，測試案例我之後會介紹

156
00:11:25,419 --> 00:11:28,519
我在測試裡就隨便寫 @unchecked Sendable 了

157
00:11:28,520 --> 00:11:34,826
畢竟測試碼不是正式產品程式碼，所以我認為不需要那麼嚴格要求

158
00:11:36,419 --> 00:11:42,700
接下來介紹一切的開始，Digest Loop

159
00:11:42,700 --> 00:11:45,360
首先，因為日誌的部分不是即時發送

160
00:11:45,360 --> 00:11:47,639
所以我們會暫存起來

161
00:11:47,639 --> 00:11:49,860
找機會發送處理

162
00:11:49,860 --> 00:11:51,580
大致是就這樣的邏輯：

163
00:11:51,580 --> 00:11:54,480
有一個類似資料儲存（Data Store）的東西

164
00:11:54,480 --> 00:11:58,580
只要還有資料就執行 while 迴圈

165
00:11:58,580 --> 00:12:00,960
在 while 迴圈中

166
00:12:00,960 --> 00:12:05,940
先從資料儲存取出一些資料 chunk（區塊）

167
00:12:05,940 --> 00:12:10,080
再以 chunk 為單位發送

168
00:12:10,080 --> 00:12:14,620
發送成功後刪除資料

169
00:12:14,620 --> 00:12:18,039
發生錯誤時就就從 while 迴圈離開並中斷

170
00:12:18,039 --> 00:12:20,659
資料儲存沒有資料時

171
00:12:20,659 --> 00:12:24,480
就從 while 迴圈離開

172
00:12:24,480 --> 00:12:29,480
如此 Digest Loop 就是我們的基本核心邏輯

173
00:12:29,480 --> 00:12:32,980
讓我們多看一下這段原始碼

174
00:12:32,980 --> 00:12:40,039
這裡有一個類似 Data Store 的組件

175
00:12:40,039 --> 00:12:41,460
還有 Network Client

176
00:12:41,460 --> 00:12:45,039
至於用來容納這個 while 迴圈的

177
00:12:45,039 --> 00:12:46,759
某個 class 也是必要的對吧

178
00:12:46,759 --> 00:12:48,759
我們稱它為 Dispatcher

179
00:12:50,817 --> 00:12:53,680
還有一個謎之結構體 DataToSend

180
00:12:53,679 --> 00:12:56,740
這也會是某種型別

181
00:12:56,740 --> 00:13:00,379
所以我們可以從這份程式碼展開說明

182
00:13:00,379 --> 00:13:03,019
會接到什麼話題呢

183
00:13:03,019 --> 00:13:06,500
就是架構（Architecture）的話題啦

184
00:13:06,500 --> 00:13:10,820
讓我們先對剛才看到的那些東西

185
00:13:10,820 --> 00:13:12,159
決定其具體的名字

186
00:13:12,159 --> 00:13:14,740
例如 entity 設為 TrackingData

187
00:13:14,740 --> 00:13:16,139
就這樣命名

188
00:13:16,139 --> 00:13:20,559
Dispatcher 就叫 TrackingDispatcher

189
00:13:20,559 --> 00:13:23,840
SQLDataStore、NetworkClient 等

190
00:13:23,840 --> 00:13:25,759
如此定好具體的名稱

191
00:13:25,759 --> 00:13:31,580
實際給外部使用的公開介面就叫 Tracker

192
00:13:31,580 --> 00:13:33,159
就這樣命名

193
00:13:33,159 --> 00:13:35,419
如剛才所見

194
00:13:35,419 --> 00:13:42,360
我們定好了組件，所以可以從組件分層（Layer）

195
00:13:42,360 --> 00:13:45,740
光看這些可能不太明白，所以我畫了張圖

196
00:13:45,740 --> 00:13:49,700
這張圖只表示相依關係（Dependency）和協定符合（Protocol Conformance）

197
00:13:49,700 --> 00:13:57,139
大致架構就長這樣，例如紅色部分是 entity 和 dispatcher

198
00:13:57,139 --> 00:14:02,419
中間夾著協定（Protocol）

199
00:14:02,419 --> 00:14:05,620
順便一提，各位看過這樣的圖嗎？

200
00:14:05,620 --> 00:14:10,659
Clean Architecture 之類的，有很多圓圈層層包圍的那個

201
00:14:10,659 --> 00:14:11,659
我們來比較看看

202
00:14:11,659 --> 00:14:14,519
變成這樣

203
00:14:14,519 --> 00:14:20,440
請仔細看相依性的箭頭，都是指向內部，中心的

204
00:14:20,440 --> 00:14:25,700
所以符合 Clean Architecture 中箭頭的原則

205
00:14:25,700 --> 00:14:28,799
因此我這可以算是某種 Clean Architecture

206
00:14:28,799 --> 00:14:31,919
挺自然的 Clean 架構

207
00:14:31,919 --> 00:14:39,679
也就是說，這是容易測試、低耦合、容易替換相依性的架構

208
00:14:39,680 --> 00:14:42,986
這就是整體架構

209
00:14:43,520 --> 00:14:47,111
實體（Entity）是就這樣簡單的資料

210
00:14:47,600 --> 00:14:59,779
裡面有個 ID，以及將日誌的原始資料直接序列化保存的 data，就這樣的 struct

211
00:14:59,780 --> 00:15:01,400
當然要加上 Sendable

212
00:15:02,975 --> 00:15:05,940
Use Case 部分長這樣

213
00:15:05,940 --> 00:15:09,351
Dispatcher 周圍環繞著 Protocols

214
00:15:09,493 --> 00:15:12,497
就這樣的相依關係

215
00:15:12,500 --> 00:15:20,104
程式碼寫出來長這樣，並且 Dispatcher 只有 sendLog 一個方法

216
00:15:20,100 --> 00:15:27,120
以日誌名和 Dictionary 陣列為參數

217
00:15:27,120 --> 00:15:32,400
資料儲存（Data Store）包含 save、get、delete 等常見的 CRUD 操作

218
00:15:32,400 --> 00:15:37,822
網路部分更簡單，只是發送而已，所以只要一支 async 函數

219
00:15:39,155 --> 00:15:44,453
這時候要注意的是，當然全部都要加上 Sendable

220
00:15:46,808 --> 00:15:51,902
外層部分沒什麼特別的，單純是具體實作（Concrete Implementation）

221
00:15:52,975 --> 00:15:56,450
按照協定實作就好了

222
00:15:56,450 --> 00:15:57,880
這個待會再說

223
00:15:58,920 --> 00:16:02,450
接下來是組件的實作，首先是 Data Store

224
00:16:03,408 --> 00:16:05,552
這是左下部分

225
00:16:07,400 --> 00:16:14,410
Data Store 直接使用 SQLite3

226
00:16:17,010 --> 00:16:21,406
大家可以看到，這是 CREATE TABLE 的查詢，就這樣定義

227
00:16:21,760 --> 00:16:26,913
欄位只有 2 個，primary key 的 integer 和 app log

228
00:16:26,910 --> 00:16:31,206
直接序列化保存的簡單構成

229
00:16:31,490 --> 00:16:35,200
可能會有人問，為什麼使用 SQLite？

230
00:16:35,530 --> 00:16:38,466
單純的 schema 是第一個原因

231
00:16:38,466 --> 00:16:41,470
而且將來從根本上來說

232
00:16:42,060 --> 00:16:46,753
日誌系統本身，今後應該不太會發生移轉（Migration）

233
00:16:47,286 --> 00:16:49,160
所以 SQLite 就足夠了

234
00:16:51,424 --> 00:16:56,550
而且 SQLite 是 iOS 標準搭載的，不需要拉額外的函式庫

235
00:16:57,808 --> 00:17:01,912
所以這次單純地用 SQLite 就好

236
00:17:04,400 --> 00:17:06,728
我想說趕快就來寫 Code 看看，結果馬上就碰壁了

237
00:17:06,880 --> 00:17:09,550
為什麼呢？因為這是 C 函式庫

238
00:17:09,893 --> 00:17:16,550
所以要處理指標（Pointer），在 Swift 中要用 opaque pointer 之類的指標來處理

239
00:17:16,551 --> 00:17:22,520
但很遺憾，在 Swift Evolution 0331 中，opaque pointer 之類的型別的 Sendable 被移除了

240
00:17:22,519 --> 00:17:26,160
所以無論如何編譯都過不了

241
00:17:26,500 --> 00:17:28,106
那怎麼辦呢？

242
00:17:28,110 --> 00:17:34,180
還記得嗎？針對性地加上@unchecked Sendable

243
00:17:34,180 --> 00:17:41,308
所以我準備了這樣的包裝器(Wrapper)，隱藏 opaque pointer

244
00:17:41,488 --> 00:17:46,100
當然不是隨便亂加 Sendable，而是適當地加上鎖（Lock）

245
00:17:46,100 --> 00:17:50,296
如此一來至少可以保證這個部分是安全的

246
00:17:50,800 --> 00:17:54,416
套用後就長這樣

247
00:17:54,420 --> 00:18:01,060
資料庫指標隱藏在內部，所以程式碼變得簡潔

248
00:18:01,059 --> 00:18:04,059
而且它確實是 Sendable

249
00:18:04,059 --> 00:18:07,740
CRUD 的實作這次省略

250
00:18:07,740 --> 00:18:17,019
就是對 SQLite 執行 query 來實作而已，大家應該都做得到吧？

251
00:18:17,019 --> 00:18:19,819
如此而已，就請各位加油吧

252
00:18:19,819 --> 00:18:26,680
開玩笑的，範例程式碼裡都寫好了，請去看看

253
00:18:26,680 --> 00:18:30,059
稍微談談測試

254
00:18:30,060 --> 00:18:38,200
這裏只有 CRUD 操作，所以只要測試 I/O 處理的正常情況就好

255
00:18:39,819 --> 00:18:46,660
這時候要注意的是，我加了 @Suite(.serialize) 這個巨集（Macro）

256
00:18:46,660 --> 00:18:50,220
為什麼呢？因為需要直接操作檔案系統

257
00:18:50,220 --> 00:18:53,680
Swift Testing 預設，跟 XCTest 不同

258
00:18:53,680 --> 00:18:59,619
是並行處理的，全部都是併發

259
00:18:59,619 --> 00:19:03,000
所以測試案例執行（File I/O）時會發生競爭

260
00:19:03,000 --> 00:19:04,779
因此這時候要設為序列化（Serialize）

261
00:19:04,779 --> 00:19:06,140
這是重點

262
00:19:06,140 --> 00:19:07,579
好

263
00:19:09,600 --> 00:19:11,120
資料庫就說到這裡

264
00:19:11,119 --> 00:19:13,240
接下來是網路客戶端

265
00:19:13,240 --> 00:19:16,779
這是圖的右下部分

266
00:19:16,779 --> 00:19:18,220
首先

267
00:19:18,220 --> 00:19:22,559
URLSession 等 HTTP 客戶端的處理

268
00:19:22,559 --> 00:19:24,579
我不直接寫死（Hard Code）

269
00:19:24,579 --> 00:19:27,240
而是用 Protocol 包起來

270
00:19:27,240 --> 00:19:30,519
而且我們要做壓縮嘛

271
00:19:30,519 --> 00:19:35,720
所以我先假設 5kB 為門檻

272
00:19:35,720 --> 00:19:41,220
並定義一個常數來壓縮 http body

273
00:19:41,570 --> 00:19:44,920
就這樣的網路處理

274
00:19:45,430 --> 00:19:51,232
順便一提，處理重試等待時間的 Task.sleep

275
00:19:51,400 --> 00:19:56,776
這個 suspend 函數也作為閉包（Closure）注入

276
00:20:00,352 --> 00:20:04,640
接下來是協定 conformance 實作(NetworkClient)的前半部分

277
00:20:04,640 --> 00:20:08,420
如果資料大小超過 deflate 的門檻

278
00:20:08,420 --> 00:20:12,779
我們加上關於壓縮的 encoding header 並壓縮資料

279
00:20:12,779 --> 00:20:15,380
否則就直接發送

280
00:20:15,380 --> 00:20:19,576
後半部分是重試的邏輯部分

281
00:20:19,580 --> 00:20:22,660
我們寫 repeat while

282
00:20:22,660 --> 00:20:29,039
裡面夾 suspend 來進行發送

283
00:20:32,142 --> 00:20:36,760
壓縮演算法我是用 zlib 做的

284
00:20:36,760 --> 00:20:38,784
那個

285
00:20:38,780 --> 00:20:39,920
看各位的伺服器而定啦

286
00:20:39,920 --> 00:20:42,759
老實說什麼壓縮演算法都可以

287
00:20:43,112 --> 00:20:44,880
只要你們伺服器能接受就好

288
00:20:44,880 --> 00:20:48,779
順帶一提，Apple 官方的 Compression Framework

289
00:20:48,779 --> 00:20:51,420
我有試過但沒用

290
00:20:51,420 --> 00:20:56,039
所以才使用經典可信的 zlib 來實作

291
00:20:57,552 --> 00:21:00,080
稍微談談測試

292
00:21:00,079 --> 00:21:02,099
就這樣的構成

293
00:21:02,099 --> 00:21:03,940
全部可以用 Mock 注入

294
00:21:03,940 --> 00:21:07,359
所以重試的等待秒數也全部拿得到

295
00:21:07,359 --> 00:21:12,299
例如，注入一個會返回 400 錯誤的 Networking Mock

296
00:21:12,299 --> 00:21:14,500
我們可以觀察到

297
00:21:14,500 --> 00:21:17,079
第一次發送加上 3 次重試

298
00:21:17,079 --> 00:21:20,420
總共發送了 4 次 request，如此的 assertion（斷言）寫得出來

299
00:21:20,420 --> 00:21:22,039
秒數是 2、4、8

300
00:21:22,039 --> 00:21:23,940
2 的 n 次方這樣

301
00:21:24,960 --> 00:21:26,340
對，秒數拿得到

302
00:21:26,339 --> 00:21:28,519
終於到 Dispatcher 了

303
00:21:32,424 --> 00:21:36,120
我們把 DataStore，NetworkClient 和 ErrorHandler

304
00:21:36,119 --> 00:21:39,519
這些製作好的組件注入進來

305
00:21:40,248 --> 00:21:41,260
然後我們看這個 Task

306
00:21:41,259 --> 00:21:44,299
只有這個 Task 是 var

307
00:21:44,299 --> 00:21:48,359
所以我們用 actor 來做 Dispatcher

308
00:21:50,020 --> 00:21:51,020
並且在這上面

309
00:21:51,019 --> 00:21:56,872
我們把 actor 的 executor 覆寫(override)掉

310
00:21:58,010 --> 00:22:02,280
為什麼必須這樣做？

311
00:22:03,208 --> 00:22:05,168
是為了簡化處理

312
00:22:06,560 --> 00:22:15,360
雖然 actor 本身可以幫我們排除內部 Data Race

313
00:22:15,360 --> 00:22:18,610
但 actor 內部處理的順序

314
00:22:18,608 --> 00:22:19,760
我們就不知道了

315
00:22:19,759 --> 00:22:23,880
所以我刻意把 executor 做成序列化

316
00:22:23,880 --> 00:22:30,140
畢竟日誌系統本來做的事情就很單純

317
00:22:30,140 --> 00:22:33,200
用不到那麼多併發處理

318
00:22:33,200 --> 00:22:34,920
所以總之把它序列化

319
00:22:34,920 --> 00:22:38,740
就做了這樣的調整

320
00:22:38,740 --> 00:22:40,779
Digest Loop

321
00:22:40,779 --> 00:22:43,500
剛才好像有看過齁？

322
00:22:43,500 --> 00:22:46,460
就是把 while 迴圈放入 Task 中執行

323
00:22:49,440 --> 00:22:51,160
啊！對了

324
00:22:51,160 --> 00:22:54,059
最後我們這裡加上 yield()

325
00:22:54,059 --> 00:22:56,119
這個函數怎麼說勒

326
00:22:59,016 --> 00:23:02,320
yield 可以想成是時間未定的 Task.sleep

327
00:23:02,319 --> 00:23:03,519
叫 yield 目的是

328
00:23:03,519 --> 00:23:08,740
把 CPU 讓位給其他優先級高的運算

329
00:23:08,740 --> 00:23:11,900
對這系統來說這很理想

330
00:23:11,900 --> 00:23:13,519
所以在這裡

331
00:23:13,519 --> 00:23:15,059
加入 Task.yield

332
00:23:16,512 --> 00:23:19,912
Digest 的主體

333
00:23:19,910 --> 00:23:23,240
就是單純取出資料發送

334
00:23:24,048 --> 00:23:27,664
發送成功後刪除

335
00:23:28,000 --> 00:23:29,824
好這是資料保存的部分

336
00:23:31,056 --> 00:23:35,475
再寫個 Digest 開始和結束的函數

337
00:23:35,480 --> 00:23:37,304
然後這是 Protocol Conformance 的部分

338
00:23:37,300 --> 00:23:39,904
序列化後發送，就這樣

339
00:23:42,960 --> 00:23:46,968
測試當然全部用 Mock

340
00:23:48,240 --> 00:23:51,376
例如就這樣 mock 一切　什麼都測得到

341
00:23:51,624 --> 00:23:55,208
總之先隨便塞 70 件日誌

342
00:23:56,504 --> 00:24:00,384
再打 1 件日誌進去，開始 Digest 後發送了 2 次

343
00:24:00,475 --> 00:24:05,168
我們就可以 assert 71 件發送成功

344
00:24:05,704 --> 00:24:08,536
接下來是平行處理

345
00:24:08,808 --> 00:24:11,920
用 Task Group 瘋狂開始 Digest

346
00:24:12,424 --> 00:24:18,504
結果沒有任何日誌被重複發送，很好！

347
00:24:19,184 --> 00:24:20,433
Tracker 主體的部分

348
00:24:20,512 --> 00:24:22,766
這個不需要做什麼

349
00:24:22,936 --> 00:24:24,550
只要將所有組件放入

350
00:24:24,550 --> 00:24:26,736
準備通用的介面就好

351
00:24:27,168 --> 00:24:29,224
使用方法就這樣

352
00:24:29,290 --> 00:24:31,560
放入真的實作

353
00:24:31,560 --> 00:24:34,080
在這注入真的 Task.sleep

354
00:24:34,152 --> 00:24:38,300
把真的包有 URLSession 的 Networking 也注入進來

355
00:24:39,440 --> 00:24:41,020
測試覆蓋率的部分

356
00:24:41,019 --> 00:24:43,359
字雖然很小，是 82.6%

357
00:24:43,359 --> 00:24:44,900
挺高的勒

358
00:24:46,488 --> 00:24:48,480
終於完成基礎架構了！

359
00:24:49,368 --> 00:24:51,680
這還沒完喔

360
00:24:51,680 --> 00:24:53,359
來談移轉作業

361
00:24:54,642 --> 00:24:57,480
舉個例子，現在的狀況是

362
00:24:57,480 --> 00:24:59,980
有這樣的舊的日誌系統

363
00:24:59,980 --> 00:25:05,119
想要同時發送到剛才做的 Tracker

364
00:25:05,119 --> 00:25:07,220
那麼如此的

365
00:25:07,220 --> 00:25:10,539
Adapter Pattern（配接器模式）是可以考慮的做法

366
00:25:10,539 --> 00:25:13,079
總之在這個 Adapter 中

367
00:25:13,079 --> 00:25:14,559
發送到兩個系統

368
00:25:14,992 --> 00:25:16,060
遺憾的是

369
00:25:16,059 --> 00:25:17,440
我沒法這麼做

370
00:25:17,440 --> 00:25:19,039
為什麼？

371
00:25:19,039 --> 00:25:21,180
因為日誌的部分啊

372
00:25:21,180 --> 00:25:24,180
現實沒那麼順利

373
00:25:25,104 --> 00:25:27,400
能不需調整直接發送的日誌

374
00:25:27,400 --> 00:25:29,460
本來就不多

375
00:25:29,460 --> 00:25:32,079
而且兩系統 API 的介面也不吻合

376
00:25:32,079 --> 00:25:37,460
硬做的話

377
00:25:37,460 --> 00:25:44,539
就會變成這樣，效能也不好

378
00:25:44,540 --> 00:25:46,280
所以我放棄了

379
00:25:46,280 --> 00:25:49,616
那怎麼辦呢？

380
00:25:49,620 --> 00:25:59,250
用毅力硬幹！對！硬幹！就是把所有的日誌呼叫

381
00:25:59,432 --> 00:26:05,360
一個一個修改，作業量龐大，真的很辛苦

382
00:26:05,360 --> 00:26:11,904
不過這也不全都是壞事啦，老實說，畢竟是針對性地修改

383
00:26:11,900 --> 00:26:15,200
所以效能相對 Adapter 較好

384
00:26:15,960 --> 00:26:21,960
而且難得把日誌全看一遍，就順便跟大家討論「這個日誌到底是什麼？」

385
00:26:22,680 --> 00:26:25,920
不需要日誌就刪掉別做

386
00:26:25,920 --> 00:26:28,192
可以說是在做重構啦

387
00:26:28,190 --> 00:26:32,256
重構就是要在這種時機做

388
00:26:32,776 --> 00:26:35,860
不然以後沒機會了

389
00:26:35,859 --> 00:26:38,640
就把它當作正面因素吧

390
00:26:39,160 --> 00:26:41,240
那實際做的事情

391
00:26:41,240 --> 00:26:45,180
例如以點擊（Tap）日誌為例

392
00:26:45,180 --> 00:26:47,740
我們有舊的 Tap 事件日誌

393
00:26:47,740 --> 00:26:51,059
Tracker 也提供新的 Tap 事件

394
00:26:51,059 --> 00:26:55,099
這些東西分別呼叫他們底層的 API

395
00:26:55,099 --> 00:26:56,480
然後

396
00:26:57,512 --> 00:27:01,020
我們在舊的那邊增加方法

397
00:27:01,696 --> 00:27:02,740
然後就這樣

398
00:27:02,740 --> 00:27:04,299
接到新的 Tracker

399
00:27:04,792 --> 00:27:05,060
是的

400
00:27:05,880 --> 00:27:08,319
就像這樣

401
00:27:09,776 --> 00:27:11,768
而且它會返回 self

402
00:27:12,400 --> 00:27:14,819
所以它變成 Fluent Interface（流暢介面）

403
00:27:14,819 --> 00:27:19,680
如此一來　怎麼說勒

404
00:27:19,680 --> 00:27:24,259
Fluent Interface 比較好寫啦

405
00:27:24,259 --> 00:27:28,140
而且這樣寫，一看就知道

406
00:27:28,140 --> 00:27:30,019
這個日誌已經做好 Dual Send 了（不用額外註解）

407
00:27:30,019 --> 00:27:34,779
所以不需要個別修改的日誌

408
00:27:34,779 --> 00:27:38,400
夾入就這樣的方法就好

409
00:27:38,400 --> 00:27:39,859
就這樣

410
00:27:40,752 --> 00:27:43,320
需要個別修改的地方

411
00:27:43,319 --> 00:27:47,720
就這樣並排，進行個別實作

412
00:27:47,720 --> 00:27:51,259
例如這個例子

413
00:27:51,259 --> 00:27:53,619
改了鍵值（Key）

414
00:27:53,619 --> 00:27:55,700
item id 改為 new item id

415
00:27:55,700 --> 00:27:57,880
實際上我做的事情

416
00:27:57,880 --> 00:28:00,319
不只這麼單純啦

417
00:28:00,319 --> 00:28:03,400
有很多各式各樣的情況

418
00:28:03,400 --> 00:28:04,460
總之我努力全做掉了

419
00:28:05,568 --> 00:28:07,220
結果勒

420
00:28:07,220 --> 00:28:09,519
真的很辛苦

421
00:28:09,519 --> 00:28:11,799
在途中

422
00:28:11,799 --> 00:28:13,400
改到精神混亂

423
00:28:13,400 --> 00:28:17,019
「我到底在做什麼？」

424
00:28:17,019 --> 00:28:19,180
「我為什麼在這裡？」

425
00:28:19,180 --> 00:28:21,220
整個懷疑人生

426
00:28:21,220 --> 00:28:26,700
工作量真的非常龐大

427
00:28:26,700 --> 00:28:32,000
就抱持著這種心情

428
00:28:32,000 --> 00:28:38,160
反覆跟其他人討論「這個日誌到底是什麼？」

429
00:28:38,160 --> 00:28:41,039
結果，成功減少了 payload size（負載大小）

430
00:28:41,039 --> 00:28:43,480
實際上有很多共通參數

431
00:28:43,480 --> 00:28:46,339
討論後發現不需要就刪了

432
00:28:46,339 --> 00:28:52,599
所以新系統是成功減少了資料量

433
00:28:52,599 --> 00:28:56,059
舊系統當然就維持原樣

434
00:28:56,059 --> 00:29:00,539
這就是移轉作業的內容

435
00:29:03,048 --> 00:29:04,568
接下來

436
00:29:04,664 --> 00:29:07,520
既然東西做好了，就必須發布

437
00:29:08,008 --> 00:29:09,660
也就是發布計畫

438
00:29:10,608 --> 00:29:16,840
剛才也提到了階段性移轉有很多優點

439
00:29:16,840 --> 00:29:18,880
我想大家應該都有經驗吧

440
00:29:18,880 --> 00:29:22,200
canary release 之類的

441
00:29:22,200 --> 00:29:23,839
這麼做有很多優點

442
00:29:23,839 --> 00:29:26,740
當發現問題的時候

443
00:29:26,740 --> 00:29:28,039
立即停掉

444
00:29:28,039 --> 00:29:29,680
可以即時止血

445
00:29:29,680 --> 00:29:32,119
有很多優點

446
00:29:32,119 --> 00:29:35,180
畢竟萬一發展成大事故

447
00:29:35,180 --> 00:29:36,819
我們必須發 hotfix（緊急修復）

448
00:29:36,819 --> 00:29:38,099
這樣的話

449
00:29:38,099 --> 00:29:40,539
會很累的

450
00:29:40,539 --> 00:29:42,559
會牽連很多人，都要動起來

451
00:29:42,559 --> 00:29:46,839
所以如此大規模的移轉

452
00:29:46,839 --> 00:29:49,839
總之我是建議採用階段性移轉

453
00:29:49,839 --> 00:29:51,000
讓它風險可控

454
00:29:53,184 --> 00:29:56,940
對伺服器負載分散也有好處

455
00:29:56,940 --> 00:29:58,799
因為是逐漸開放

456
00:29:58,799 --> 00:30:02,940
如果一口氣 release 掉一大堆日誌

457
00:30:02,940 --> 00:30:05,740
伺服器那邊的負責人

458
00:30:05,740 --> 00:30:08,839
也不知道能伺服器撐不撐得住

459
00:30:08,839 --> 00:30:11,619
所以這對我們來說真的有必要

460
00:30:11,619 --> 00:30:14,619
順便問一下，大家還記得嗎？

461
00:30:14,619 --> 00:30:17,200
我們這次「不進行」強制更新

462
00:30:17,200 --> 00:30:21,039
所以這方面也需要某種對策

463
00:30:21,039 --> 00:30:26,640
為什麼呢？因為不進行強制更新的話

464
00:30:26,640 --> 00:30:32,420
一直使用舊版 app 的使用者

465
00:30:32,420 --> 00:30:36,640
會一直向舊系統發送日誌

466
00:30:36,640 --> 00:30:39,440
所以如果不做強更

467
00:30:39,440 --> 00:30:42,019
就這樣的發送會一直持續不斷

468
00:30:42,019 --> 00:30:45,259
剛才說過，伺服器整個會不見

469
00:30:45,259 --> 00:30:50,079
所以就會變成一直向不存在的 404 伺服器發送資料

470
00:30:50,079 --> 00:30:54,299
那你會問，為什麼不進行強制更新呢？

471
00:30:54,299 --> 00:30:57,740
純粹是因為使用者流失等等

472
00:30:57,740 --> 00:31:00,599
UX（使用者體驗）方面相關的顧慮

473
00:31:00,599 --> 00:31:01,920
上頭的意思是盡量不要做強更

474
00:31:01,920 --> 00:31:06,680
那我們就必須想出個折衷方案嘛

475
00:31:06,680 --> 00:31:11,900
所以再重複一次，不肯更新的使用者

476
00:31:11,900 --> 00:31:14,599
會一直向舊系統發送日誌

477
00:31:14,599 --> 00:31:17,420
成本削減的部分

478
00:31:17,420 --> 00:31:19,440
我想剛才說過

479
00:31:19,440 --> 00:31:25,299
所以需要 2 種控制

480
00:31:25,299 --> 00:31:30,539
對舊系統，我們準備「阻斷」日誌的 flag

481
00:31:30,539 --> 00:31:34,059
對新系統，我們要分階段推出（rollout）

482
00:31:34,059 --> 00:31:36,980
所以也準備一個 flag

483
00:31:36,980 --> 00:31:39,400
然後對使用者的比例

484
00:31:39,400 --> 00:31:41,279
逐漸開放

485
00:31:41,279 --> 00:31:45,000
這裡要注意的是

486
00:31:45,000 --> 00:31:48,619
阻斷控制的預設值是 true

487
00:31:48,619 --> 00:31:49,599
並且 100% 全面開放

488
00:31:49,599 --> 00:31:51,380
對於 app 內寫死的值

489
00:31:51,380 --> 00:31:54,259
例如 flag 不存在的情況

490
00:31:54,259 --> 00:31:56,880
程式碼中寫死的值

491
00:31:56,880 --> 00:31:58,180
要寫成 false

492
00:31:58,180 --> 00:32:01,559
rollout 的部分則相反

493
00:32:01,559 --> 00:32:04,019
從 false 變為 true

494
00:32:04,019 --> 00:32:09,099
無論如何，預設值要設為控制的最終狀態

495
00:32:09,099 --> 00:32:14,519
所以 flag 最後可以從 Firebase 上刪掉

496
00:32:14,519 --> 00:32:22,400
刪掉 flag 之後系統仍會按照最終狀態運作

497
00:32:22,400 --> 00:32:24,720
就這樣的設定

498
00:32:24,720 --> 00:32:28,079
實際成果

499
00:32:28,079 --> 00:32:32,279
2024 年 10 月

500
00:32:32,279 --> 00:32:35,140
就已經預先發布了阻斷控制

501
00:32:35,140 --> 00:32:38,740
所以大約 1 年前

502
00:32:38,740 --> 00:32:44,259
這個 true 值

503
00:32:44,259 --> 00:32:47,259
我們就花時間

504
00:32:47,259 --> 00:32:50,960
讓幾乎所有使用者都有這個 flag

505
00:32:50,960 --> 00:32:55,160
然後隔了 1 個月

506
00:32:55,160 --> 00:32:57,039
發布控制實作

507
00:32:57,039 --> 00:33:03,380
所以對舊系統來說彷彿什麼事都沒發生

508
00:33:03,380 --> 00:33:06,180
而實際上當時已經埋好 flag 了

509
00:33:06,180 --> 00:33:11,460
之後改 flag，對舊系統的 Log 就會全部被截掉

510
00:33:11,460 --> 00:33:12,819
就這樣

511
00:33:12,819 --> 00:33:16,339
強制更新就不用做了

512
00:33:16,339 --> 00:33:20,740
至於新系統的實際成果

513
00:33:20,740 --> 00:33:26,119
今年 1 月，將 flag 設為 false，100%開放

514
00:33:26,119 --> 00:33:40,039
於 4 月 10 日左右將所有新日誌都發布掉

515
00:33:40,039 --> 00:33:43,640
因為我們用 Calendar Versioning（日曆版本控制）

516
00:33:43,640 --> 00:33:48,000
所以發布時期大概是這個時候很好懂

517
00:33:48,000 --> 00:33:52,880
分 5 個階段，這樣發布

518
00:33:52,880 --> 00:33:59,579
然而 4 月的上旬我們立即觀察到問題，所以暫時設回 0%

519
00:33:59,579 --> 00:34:06,000
設法修好後，沒問題了，就跳過中間直接到 50%

520
00:34:06,000 --> 00:34:09,460
之後就按照預定計畫進行

521
00:34:09,460 --> 00:34:15,119
結果是沒有發 hotfix，非常順利

522
00:34:15,760 --> 00:34:18,740
實務上的穩定性也好，人員心理上也很安心

523
00:34:18,739 --> 00:34:22,199
特別是能安心這件事非常重要

524
00:34:22,199 --> 00:34:24,679
出事的時候急來急去真的會很累

525
00:34:24,679 --> 00:34:30,780
真心推薦用穩健的方式發布比較好

526
00:34:30,780 --> 00:34:34,900
flag 的控制等等

527
00:34:34,900 --> 00:34:42,539
也是在計畫階段就決定好 true 和 false 的方針

528
00:34:42,539 --> 00:34:45,719
所以就沒有殘留問題

529
00:34:45,719 --> 00:34:49,320
就是不會造成 flag 永遠無法刪除的狀態

530
00:34:49,320 --> 00:34:54,292
強制更新當然沒有進行

531
00:34:54,290 --> 00:34:57,520
現在還在 Dual Send 的適應期

532
00:34:57,712 --> 00:35:03,720
所以還差一點點

533
00:35:03,719 --> 00:35:09,440
在發布完之後，做的事情就是監控，如果有 crash 就修正

534
00:35:09,440 --> 00:35:13,320
調查原因並修正

535
00:35:13,320 --> 00:35:18,480
還有還沒做的事情啦，控制 flag 的刪除，舊實作的刪除，這些工作還留著

536
00:35:18,480 --> 00:35:23,659
當然這是身為工程師最爽的階段

537
00:35:23,659 --> 00:35:30,000
刪除不需要的實作，一口氣生 2000 行的紅字

538
00:35:30,000 --> 00:35:37,260
的差異(git diff)，雖然還不能刪啦，但我很期待

539
00:35:37,260 --> 00:35:40,880
所以還沒做完，我們還差一些一切就結束了

540
00:35:40,880 --> 00:35:43,880
進入總結

541
00:35:44,240 --> 00:35:51,200
首先，談了日誌系統到底是什麼，什麼是行為日誌

542
00:35:51,199 --> 00:35:59,320
從一開始構思的核心邏輯 Digest Loop

543
00:35:59,320 --> 00:36:02,840
展開到介面設計、架構的話題

544
00:36:02,840 --> 00:36:05,820
當然採用 Clean SOLID 的架構

545
00:36:05,820 --> 00:36:11,840
基於 Swift 6 的實作進行介紹

546
00:36:11,840 --> 00:36:15,380
針對測試程式碼就挑重點部分介紹了

547
00:36:15,380 --> 00:36:20,480
完整的原始碼在範例 repository 裡，可以去看看

548
00:36:20,480 --> 00:36:23,860
而且這是自製的基礎建設

549
00:36:23,860 --> 00:36:26,139
基本上都是我寫的

550
00:36:26,140 --> 00:36:34,256
今後的功能擴展，或想加什麼功能，不需要依賴外部人員

551
00:36:34,872 --> 00:36:36,280
公司內部解決

552
00:36:36,800 --> 00:36:39,184
這是自製的優點

553
00:36:39,180 --> 00:36:43,952
代價是我會很累啦，開玩笑的

554
00:36:43,950 --> 00:36:49,576
做一套基礎架構其實滿有趣的，大家有機會一定要試試看

555
00:36:49,920 --> 00:36:51,496
一點都不可怕

556
00:36:52,768 --> 00:36:54,390
總結 2

557
00:36:54,392 --> 00:37:06,250
介紹了移轉作業的方法，雖然有優雅的 Adapter Pattern，但現實沒那麼理想

558
00:37:06,520 --> 00:37:08,376
通常都是這樣啦

559
00:37:08,380 --> 00:37:11,520
理想終究是理想

560
00:37:11,519 --> 00:37:13,780
所以基本上

561
00:37:13,780 --> 00:37:16,119
咬緊牙關，用毅力跟他拼了就對了

562
00:37:16,119 --> 00:37:18,639
大家也跟他拼了就對了！

563
00:37:18,639 --> 00:37:20,599
而且我撐過去了

564
00:37:20,599 --> 00:37:23,300
結果不錯啦

565
00:37:24,592 --> 00:37:26,500
重構也做了

566
00:37:26,500 --> 00:37:27,920
還行啦

567
00:37:28,342 --> 00:37:34,099
也透過原始碼介紹了 Helper 方法以及個別實作的具體手段

568
00:37:34,099 --> 00:37:35,920
總結 3

569
00:37:35,920 --> 00:37:37,360
這部分很簡單

570
00:37:38,680 --> 00:37:39,740
重點就是

571
00:37:39,739 --> 00:37:44,260
對舊系統設為 false 後再改成 true

572
00:37:44,260 --> 00:37:45,900
說反了

573
00:37:45,900 --> 00:37:49,199
是設為 true 後再改成 false

574
00:37:49,199 --> 00:37:51,699
對新系統的 rollout

575
00:37:51,699 --> 00:37:54,659
則從 false 變為 true

576
00:37:54,659 --> 00:37:59,480
如此安排 config（設定）就刪得掉

577
00:37:59,480 --> 00:38:02,280
我覺得這樣的安排才好

578
00:38:02,280 --> 00:38:05,679
不需要強制更新

579
00:38:05,679 --> 00:38:08,599
希望能夠給大家作為參考

580
00:38:08,599 --> 00:38:12,739
這次日誌 rollout 我們分了 5 階段

581
00:38:12,739 --> 00:38:16,519
分幾階段都可以，你高興就好

582
00:38:16,519 --> 00:38:19,119
再講些多餘的話題

583
00:38:19,119 --> 00:38:23,400
這次只是做了基本的日誌基礎架構

584
00:38:23,400 --> 00:38:25,739
其實還有很多事情可以做

585
00:38:25,739 --> 00:38:28,699
比如配合 CPU 使用率、記憶體

586
00:38:28,699 --> 00:38:30,559
調整發送頻率之類的

587
00:38:30,559 --> 00:38:32,420
就這樣的改進是可以考慮的

588
00:38:32,420 --> 00:38:34,880
比如遊戲 app 或高即時 app 等

589
00:38:34,880 --> 00:38:38,000
對效能要求嚴格的 app

590
00:38:38,000 --> 00:38:42,940
日誌系統可以考慮以上因素

591
00:38:42,940 --> 00:38:50,659
還有磁碟容量幾乎吃滿的使用者基本上連打開資料庫都做不到

592
00:38:50,659 --> 00:38:52,119
這時候

593
00:38:52,120 --> 00:38:55,872
可以做 fallback（回退）到記憶體資料儲存

594
00:38:56,352 --> 00:38:57,860
就這樣

595
00:38:57,860 --> 00:39:00,539
我們可以不改變架構的同時

596
00:39:00,539 --> 00:39:03,539
只要替換相依性

597
00:39:03,539 --> 00:39:04,619
就能變成記憶體資料儲存

598
00:39:04,619 --> 00:39:06,179
就這樣的手段

599
00:39:06,179 --> 00:39:08,460
至於離線環境

600
00:39:08,460 --> 00:39:11,199
例如在飛機上

601
00:39:11,199 --> 00:39:13,000
根本發送不了 Log

602
00:39:13,000 --> 00:39:15,719
所以我們可以監控 Reachability（網路可達性）

603
00:39:15,719 --> 00:39:17,800
離線就不送 Log

604
00:39:17,800 --> 00:39:19,280
等連上 Wi-Fi 後

605
00:39:19,280 --> 00:39:21,219
再狂送 Log

606
00:39:21,219 --> 00:39:23,480
就這樣的改進是可以考慮的

607
00:39:23,480 --> 00:39:26,460
以上就是全部內容

608
00:39:26,460 --> 00:39:28,239
重複一次

609
00:39:28,239 --> 00:39:29,699
參考資料在這裡

610
00:39:29,699 --> 00:39:31,599
還有原始碼 repository

611
00:39:31,599 --> 00:39:33,360
範例程式碼

612
00:39:33,360 --> 00:39:34,440
歡迎看看

613
00:39:34,440 --> 00:39:36,920
稍微宣傳一下

614
00:39:36,920 --> 00:39:38,340
我們會舉辦 After Event（後續活動）

615
00:39:38,340 --> 00:39:39,519
預計會談

616
00:39:39,519 --> 00:39:42,139
LINE 漫畫的幕後故事

617
00:39:42,139 --> 00:39:44,599
ebookjapan 等等的幕後故事

618
00:39:44,599 --> 00:39:46,659
預定會聊這些

619
00:39:46,659 --> 00:39:49,280
時間是下個月

620
00:39:49,280 --> 00:39:51,219
10 月 17 日

621
00:39:51,219 --> 00:39:52,699
距離現在還有點久齁

622
00:39:52,699 --> 00:39:53,460
晚上 7 點

623
00:39:53,460 --> 00:39:55,320
地點是我們辦公室

624
00:39:55,320 --> 00:39:59,079
六本木東京 Midtown 11 樓

625
00:39:59,528 --> 00:40:01,360
connpass 頁面在這裡

626
00:40:01,360 --> 00:40:03,380
歡迎來參加

627
00:40:03,380 --> 00:40:05,239
我們會準備好吃的等你

628
00:40:05,239 --> 00:40:14,239
以上，就是支撐 LINE 漫畫的日誌基礎架構設計開發的一切

629
00:40:15,192 --> 00:40:17,504
感謝大家聆聽！

630
00:40:25,984 --> 00:40:28,032
感謝您的發表！

631
00:40:28,458 --> 00:40:31,677
那我們進入 Q&A

632
00:40:31,677 --> 00:40:34,197
有意見或有問題的人請舉手

633
00:40:40,117 --> 00:40:41,157
我拿麥克風給您

634
00:40:42,065 --> 00:40:44,255
謝謝

635
00:40:44,255 --> 00:40:47,974
整體架構是 Clean Architecture

636
00:40:47,974 --> 00:40:49,974
結構很乾淨

637
00:40:49,974 --> 00:40:50,974
而且也做成了容易測試的結構

638
00:40:50,974 --> 00:40:52,940
我覺得真的很棒

639
00:40:52,940 --> 00:40:58,380
我自己也蠻常在產品裡用 Firebase

640
00:40:58,398 --> 00:41:01,537
把意見送出後，也能學到那塊的理解就更好了，這是我自己的想法

641
00:41:02,438 --> 00:41:04,938
這個在最終發佈之前

642
00:41:04,938 --> 00:41:06,537
關於開發期間之類的

643
00:41:06,537 --> 00:41:13,033
人數大概需要多少人來開發呢？

644
00:41:13,033 --> 00:41:14,833
這能說嗎？

645
00:41:15,577 --> 00:41:18,137
開發就我一個人

646
00:41:18,137 --> 00:41:19,338
所以

647
00:41:20,066 --> 00:41:22,778
人力資源不夠嘛

648
00:41:22,778 --> 00:41:24,677
就只有 Compression Framework 而已 (測試失敗的那個)

649
00:41:24,677 --> 00:41:26,557
全部都是我自己想的

650
00:41:27,966 --> 00:41:28,577
厲害

651
00:41:28,577 --> 00:41:33,233
有時候啊，還是需要一點沒有根據的自信

652
00:41:33,233 --> 00:41:35,466
不然什麼都開始不了

653
00:41:35,466 --> 00:41:36,858
結果嘛，最後也算是 OK

654
00:41:36,858 --> 00:41:38,278
就像這樣

655
00:41:38,278 --> 00:41:39,637
五千萬次下載

656
00:41:39,637 --> 00:41:41,378
這種規模的

657
00:41:41,378 --> 00:41:43,157
日誌架構就是這樣做到的

658
00:41:43,157 --> 00:41:44,918
請務必拿去參考

659
00:41:44,918 --> 00:41:46,137
開發期間呢

660
00:41:46,137 --> 00:41:48,097
花了超過一年

661
00:41:48,097 --> 00:41:50,577
因為本來工作量就非常多

662
00:41:50,577 --> 00:41:56,617
再加上作業以外的溝通、協調、運氣之類的也有不少。

663
00:41:56,617 --> 00:42:02,117
整體來說，大概是一年半左右吧？不太確定

664
00:42:02,117 --> 00:42:05,318
活用 AI 之類的做法

665
00:42:05,318 --> 00:42:07,633
能不能利用 AI 來處理一些範本化的部分

666
00:42:07,633 --> 00:42:10,117
再把基底部分修一修

667
00:42:10,117 --> 00:42:11,117
果然還是有點難嗎？

668
00:42:11,117 --> 00:42:16,366
從今年開始的專案，我們就已經比較多和 AI 一起使用了

669
00:42:16,366 --> 00:42:22,180
不過這個專案是去年做的

670
00:42:22,180 --> 00:42:27,414
那時候並沒有特別使用 AI 工具

671
00:42:27,414 --> 00:42:29,213
順帶一提，像這樣的架構呢

672
00:42:29,213 --> 00:42:33,514
也有和其他厲害的人討論過

673
00:42:33,514 --> 00:42:37,566
大家都覺得「這樣的構成應該可行」，就照這個方向前進了。

674
00:42:37,700 --> 00:42:40,700
原來那時候還沒有導入 AI 呢，謝謝

675
00:42:41,300 --> 00:42:42,700
謝謝

676
00:42:42,833 --> 00:42:46,933
還有問題的人請舉手

677
00:42:47,466 --> 00:42:49,494
我們會把麥克風遞過去，請稍候

678
00:42:58,233 --> 00:43:00,073
精彩的發表，謝謝您

679
00:43:00,333 --> 00:43:05,173
我自己其實也在公司內部開發使用者行為紀錄（user code log）的 framework

680
00:43:05,173 --> 00:43:10,434
關於會懷疑人生、或者靠毅力很重要那段，我非常有共鳴

681
00:43:11,333 --> 00:43:13,434
我有個小問題

682
00:43:13,434 --> 00:43:15,653
在需求檔案裡面有提到

683
00:43:15,653 --> 00:43:23,366
「送出日誌時的記憶體消耗」以及「電力消耗」這些項目。

684
00:43:23,366 --> 00:43:29,400
我很好奇，這些部分的驗證是怎麼進行的？

685
00:43:29,553 --> 00:43:38,894
你們是自己做測試 App 導入那個函式庫，然後對新舊版本做基準測試（benchmark）

686
00:43:38,894 --> 00:43:46,153
還是直接在實際的服務 App 裡面引入後進行測試？

687
00:43:46,153 --> 00:43:48,773
關於這部分呢，我們當時有考慮過

688
00:43:48,773 --> 00:43:54,273
老實說，沒有做基準測試

689
00:43:54,273 --> 00:43:59,273
一來是排程上的考量

690
00:43:59,273 --> 00:44:05,433
而且這個架構本身已經是相當精簡的設計了

691
00:44:05,433 --> 00:44:07,733
所以我們的策略是

692
00:44:07,733 --> 00:44:11,273
如果出問題，就先暫停，然後再重新檢視

693
00:44:11,273 --> 00:44:13,273
也就是說，採用

694
00:44:13,273 --> 00:44:15,273
先發佈，之後再來考慮

695
00:44:15,273 --> 00:44:17,273
採取這種做法

696
00:44:17,273 --> 00:44:21,400
結果來看呢，我自己也有看實際的 Xcode Instrument

697
00:44:21,400 --> 00:44:27,266
沒有特別出現問題，所以就先上線看看

698
00:44:27,266 --> 00:44:33,166
至於基準測試部分，因為我自己不太熟悉這一塊

699
00:44:33,166 --> 00:44:36,166
所以沒能深入處理，這部分真的很抱歉

700
00:44:36,494 --> 00:44:38,514
不會，沒問題

701
00:44:38,514 --> 00:44:39,900
非常感謝

702
00:44:40,466 --> 00:44:41,093
謝謝回答

703
00:44:41,093 --> 00:44:46,994
時間關係，下一位應該是最後一位。有評論或問題的請舉手

704
00:44:54,673 --> 00:44:58,100
沒有其他人了嗎？

705
00:45:00,814 --> 00:45:03,693
Q&A 到這邊先告一段落

706
00:45:03,693 --> 00:45:06,333
接下來是 1 分鐘的回饋時間

707
00:45:10,066 --> 00:45:13,633
現在是 1 分鐘回饋時間

708
00:45:13,633 --> 00:45:16,100
請掃描螢幕上的 QR Code

709
00:45:16,100 --> 00:45:17,980
送出你的 Feedback

710
00:46:05,033 --> 00:46:10,033
接下來在四樓展示區前有 Ask the Speaker

711
00:46:10,033 --> 00:46:13,800
有問題或想分享感想的朋友，請務必參加

712
00:46:17,034 --> 00:46:23,700
那麼，非常感謝 dsxs

