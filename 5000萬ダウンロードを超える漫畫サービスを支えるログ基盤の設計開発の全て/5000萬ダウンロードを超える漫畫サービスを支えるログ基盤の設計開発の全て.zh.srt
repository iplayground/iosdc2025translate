1
00:00:09,473 --> 00:00:10,157
大家早安！

2
00:00:11,018 --> 00:00:12,557
是的，今天我要分享的主題是

3
00:00:12,797 --> 00:00:16,140
支撐超過 5000 萬下載量的漫畫服務

4
00:00:16,140 --> 00:00:21,637
或者說電子漫畫服務的日誌基礎架構設計開發的完全解析

5
00:00:21,637 --> 00:00:22,978
我就以此為題

6
00:00:22,978 --> 00:00:25,579
來進行分享

7
00:00:26,678 --> 00:00:29,140
先簡單自我介紹一下

8
00:00:29,500 --> 00:00:31,199
我叫 dsxs

9
00:00:31,617 --> 00:00:34,472
這名字有點難念

10
00:00:34,679 --> 00:00:36,018
很容易咬到舌頭

11
00:00:36,200 --> 00:00:37,280
就是就這樣

12
00:00:37,396 --> 00:00:39,015
請多多指教

13
00:00:39,225 --> 00:00:40,322
我是台灣人

14
00:00:40,459 --> 00:00:42,890
來日本已經 9 年了

15
00:00:43,459 --> 00:00:45,359
日文沒問題

16
00:00:45,359 --> 00:00:47,298
歡迎用日文交流

17
00:00:47,475 --> 00:00:51,225
目前在 LINE Digital Frontier 公司工作

18
00:00:51,859 --> 00:00:53,256
我的興趣是

19
00:00:53,256 --> 00:00:56,798
漫畫、動畫、VTuber 等等

20
00:00:56,798 --> 00:00:59,859
基本上都是宅興趣啦

21
00:01:01,649 --> 00:01:08,759
不過天氣好的時候也會騎重機出去兜風

22
00:01:08,759 --> 00:01:11,697
就像照片裡這樣

23
00:01:11,697 --> 00:01:17,218
好，進入正題，今天要談的內容包括：

24
00:01:17,218 --> 00:01:20,358
首先，為什麼我們必須要

25
00:01:20,358 --> 00:01:23,521
進行日誌系統的移轉

26
00:01:23,659 --> 00:01:28,180
日誌基礎架構的建構設計與實作

27
00:01:28,340 --> 00:01:32,587
還有測試程式碼，我會針對重點部分來分享

28
00:01:32,676 --> 00:01:38,668
由於時間關係，無法全部介紹，所以只挑重點來講

29
00:01:39,024 --> 00:01:45,626
Swift 語言方面，使用 Swift 6.1.0，也就是用 Swift 6 來實作

30
00:01:45,920 --> 00:01:50,400
這次的移轉作業不是新導入

31
00:01:50,400 --> 00:01:56,061
而是從舊系統移轉到新系統，我也會談到具體的作業內容

32
00:01:56,691 --> 00:01:58,900
關於發布

33
00:01:58,900 --> 00:02:01,477
因為這次是大規模的更動

34
00:02:01,477 --> 00:02:06,096
所以我們採取了比較安全的階段性發布策略

35
00:02:06,864 --> 00:02:08,668
就這樣

36
00:02:09,050 --> 00:02:14,399
首先，範例程式碼我已經放在個人的 GitHub 上

37
00:02:14,758 --> 00:02:19,431
如果有興趣的話可以下載來玩玩看

38
00:02:19,584 --> 00:02:25,098
今天省略的內容全部都在這個範例程式碼裡

39
00:02:25,637 --> 00:02:27,627
請務必參考看看

40
00:02:28,229 --> 00:02:32,836
那麼，為什麼我們必須移轉系統呢？

41
00:02:33,306 --> 00:02:39,157
其實 LINE 漫畫 app 裡已經寫有各式各樣的日誌

42
00:02:39,157 --> 00:02:44,060
但這個日誌系統即將結束服務

43
00:02:44,060 --> 00:02:45,300
會消失

44
00:02:45,548 --> 00:02:47,306
連伺服器整個都會端掉

45
00:02:47,948 --> 00:02:49,818
就是如此

46
00:02:49,818 --> 00:02:56,699
就算系統沒了，日誌還是得收集的，所以必須導入新系統

47
00:02:57,317 --> 00:02:58,389
就這狀況

48
00:02:58,389 --> 00:03:00,711
換句話說　不做不行啊

49
00:03:02,925 --> 00:03:04,500
遇到這種情況

50
00:03:04,500 --> 00:03:10,979
首先你會去要看看有沒有新的基盤或 SDK 可以用對吧？

51
00:03:11,770 --> 00:03:17,519
基盤或函式庫都可以，什麼都行，總之我是去要了啦

52
00:03:17,901 --> 00:03:21,139
結果得到的答案是沒有

53
00:03:23,175 --> 00:03:25,156
那就只能自己做了

54
00:03:25,157 --> 00:03:30,060
我回答說「了解！」，然後就從基礎架構開始做啦

55
00:03:31,502 --> 00:03:36,657
在那之前，先說明一下「什麼是日誌」

56
00:03:36,657 --> 00:03:43,399
在 LINE 漫畫中，日誌指的是記錄使用者行為的資料

57
00:03:43,399 --> 00:03:47,680
例如：畫面轉換、曝光（Impression）等等

58
00:03:47,680 --> 00:03:51,776
當曝光，就是某個物件、視圖、按鈕、圖片等等

59
00:03:51,776 --> 00:03:57,318
進入畫面並能夠被使用者看見的狀態

60
00:03:57,318 --> 00:03:59,038
我們稱為曝光（Impression）

61
00:03:59,038 --> 00:04:00,959
我想大家應該都知道這個概念

62
00:04:00,959 --> 00:04:07,180
還有點擊、拖拽、滑動等各種手勢操作

63
00:04:07,180 --> 00:04:11,157
這些使用者行為都會被記錄下來

64
00:04:11,157 --> 00:04:15,579
製作成某種資料並發送出去

65
00:04:16,552 --> 00:04:21,459
這些日誌實際上有很多用途

66
00:04:21,459 --> 00:04:24,579
例如：作品推薦功能

67
00:04:24,579 --> 00:04:30,379
可以分析使用者大致上是透過什麼路徑閱讀了哪些作品

68
00:04:30,379 --> 00:04:33,980
這對調查統計很有幫助

69
00:04:33,980 --> 00:04:35,139
所以非常重要

70
00:04:35,139 --> 00:04:38,680
另一方面，對於故障調查也很有用

71
00:04:38,680 --> 00:04:43,939
例如，我們觀察到某個原因不明的閃退的話

72
00:04:43,939 --> 00:04:48,079
就可以查看該特定使用者的日誌

73
00:04:48,079 --> 00:04:51,120
追蹤閃退前做了什麼操作

74
00:04:51,120 --> 00:04:54,959
如此追蹤就變得可能

75
00:04:55,432 --> 00:04:59,519
所以雖然日誌不是主要功能，但確實很重要

76
00:05:00,908 --> 00:05:07,199
如同我剛才說的，LINE 漫畫已經埋入了各式各樣的日誌

77
00:05:07,800 --> 00:05:12,680
這次要談的不是如何收集日誌

78
00:05:12,680 --> 00:05:14,939
而是如何將日誌發送到伺服器

79
00:05:14,939 --> 00:05:18,500
關於這類基礎架構的實作

80
00:05:19,771 --> 00:05:22,100
移轉的需求方面

81
00:05:22,944 --> 00:05:25,379
不是新導入，而是移轉

82
00:05:25,379 --> 00:05:28,639
所以如我剛才寫的

83
00:05:28,639 --> 00:05:31,860
從收集日誌的立場（部門）來看的話

84
00:05:31,860 --> 00:05:34,120
他們當然希望盡量一切保持原樣

85
00:05:34,120 --> 00:05:37,360
日誌的結構、資料和名稱

86
00:05:37,360 --> 00:05:39,939
全部請保持原樣，這就是我所聽到的需求

87
00:05:39,939 --> 00:05:45,319
同時他們也希望能維持與舊系統同樣的功能

88
00:05:45,319 --> 00:05:48,680
在移轉期間，作為適應期

89
00:05:48,680 --> 00:05:49,540
需要做雙重發送（Dual Send）

90
00:05:49,540 --> 00:05:53,660
也就是在舊系統和新系統同時

91
00:05:53,660 --> 00:05:57,019
存在的狀態下，向兩邊都發送日誌

92
00:05:57,922 --> 00:06:01,079
這也是重要的需求之一

93
00:06:01,079 --> 00:06:03,778
另外，這次不進行強制更新

94
00:06:04,108 --> 00:06:05,300
我被告知說這次不做強更

95
00:06:05,903 --> 00:06:10,199
這對之後的發布計畫有很大影響

96
00:06:10,199 --> 00:06:12,338
這點請大家先記住

97
00:06:12,951 --> 00:06:15,240
關於日誌系統

98
00:06:15,240 --> 00:06:17,319
需求是理解了

99
00:06:17,319 --> 00:06:19,959
但日誌系統到底要做成什麼樣子呢？

100
00:06:19,959 --> 00:06:24,899
首先最基本的，不能阻塞主執行緒

101
00:06:24,899 --> 00:06:27,079
畢竟只是發送日誌而已

102
00:06:27,079 --> 00:06:29,899
我們不希望過度使用系統資源

103
00:06:30,286 --> 00:06:33,519
畢竟大家用這 app 就是要看漫畫

104
00:06:33,519 --> 00:06:35,480
如果畫面卡頓的話使用者會感到煩

105
00:06:35,975 --> 00:06:38,160
所以不能壓迫記憶體

106
00:06:38,160 --> 00:06:40,740
同時希望控制通訊量

107
00:06:40,740 --> 00:06:44,379
連帶著，也希望降低電力消耗

108
00:06:44,379 --> 00:06:47,067
規格要求的很嚴峻齁

109
00:06:48,000 --> 00:06:51,240
我這樣說可能大家還搞不太清楚

110
00:06:51,240 --> 00:06:56,259
所以讓我把它轉換成更技術性的規格

111
00:06:56,259 --> 00:07:00,038
首先，我考慮的是

112
00:07:00,038 --> 00:07:04,360
資料型別設為 Dictionary，鍵（Key）設為 String

113
00:07:04,360 --> 00:07:06,519
值（Value）設為 Sendable

114
00:07:09,273 --> 00:07:12,959
因為說不能妨礙主執行緒

115
00:07:12,959 --> 00:07:16,399
所以採用併發（Concurrent）的非同步處理策略

116
00:07:16,399 --> 00:07:18,360
切一條別的執行緒

117
00:07:18,360 --> 00:07:20,740
把優先級設為 Utility

118
00:07:20,740 --> 00:07:22,879
就這樣

119
00:07:22,879 --> 00:07:26,177
以並行方式送日誌

120
00:07:26,177 --> 00:07:28,220
緩衝區和資料的持久化也做

121
00:07:28,220 --> 00:07:31,677
不直接發送，不即時發送

122
00:07:31,677 --> 00:07:33,918
而是先暫存

123
00:07:34,685 --> 00:07:36,500
通訊方面

124
00:07:36,500 --> 00:07:38,079
為了節省資料量

125
00:07:38,079 --> 00:07:39,298
我們對資料進行壓縮

126
00:07:39,298 --> 00:07:43,399
gzip 或 deflate 都是可以考慮的方案

127
00:07:43,399 --> 00:07:45,500
為了保證 QoS（服務品質）

128
00:07:45,500 --> 00:07:50,338
我們做 Exponential Backoff 這樣的重試機制

129
00:07:50,338 --> 00:07:53,677
這個基礎架構想當然爾

130
00:07:53,677 --> 00:07:54,620
難得都做到這程度了

131
00:07:54,620 --> 00:07:56,338
乾脆做成 Swift Package

132
00:07:56,338 --> 00:08:00,379
指定版本 6.1.0，也就是 Swift 6

133
00:08:00,379 --> 00:08:03,899
這大致就是定好的規格

134
00:08:04,711 --> 00:08:07,439
在談實作之前

135
00:08:07,439 --> 00:08:10,319
讓我說明一下 Swift 6 的重點

136
00:08:10,319 --> 00:08:12,379
我想大家應該都知道的齁

137
00:08:12,379 --> 00:08:15,579
首先，升級到 Swift 6 之後

138
00:08:15,579 --> 00:08:18,319
會出現一大堆編譯錯誤對吧

139
00:08:18,319 --> 00:08:22,079
基本上把這些錯誤修掉就差不多了

140
00:08:22,079 --> 00:08:25,759
具體來說，大多是 Sendable 的錯誤

141
00:08:25,759 --> 00:08:27,819
所以基本上　總之加上 Sendable 就好了

142
00:08:27,819 --> 00:08:32,620
要加上 Sendable 的話，就不要寫 var

143
00:08:32,620 --> 00:08:37,340
如果無論如何都要寫變數的話

144
00:08:37,340 --> 00:08:39,557
那就寫成 actor

145
00:08:39,557 --> 00:08:43,720
這就是基本原則

146
00:08:43,720 --> 00:08:47,639
之後的原始碼也大致是這樣的感覺

147
00:08:47,639 --> 00:08:50,740
如果遇到實在無法套用 Sendable 的情況

148
00:08:50,740 --> 00:08:53,700
就針對性地加上 @unchecked Sendable

149
00:08:57,033 --> 00:09:01,918
另一方面，測試案例我之後會介紹

150
00:09:01,918 --> 00:09:05,019
我在測試裡就隨便寫 @unchecked Sendable 了

151
00:09:05,019 --> 00:09:11,326
畢竟測試碼不是正式產品程式碼，所以我認為不需要那麼嚴格要求

152
00:09:12,918 --> 00:09:19,200
接下來介紹一切的開始，Digest Loop

153
00:09:19,200 --> 00:09:21,860
首先，因為日誌的部分不是即時發送

154
00:09:21,860 --> 00:09:24,139
所以我們會暫存起來

155
00:09:24,139 --> 00:09:26,360
找機會發送處理

156
00:09:26,360 --> 00:09:28,080
大致是就這樣的邏輯：

157
00:09:28,080 --> 00:09:30,980
有一個類似資料儲存（Data Store）的東西

158
00:09:30,980 --> 00:09:35,080
只要還有資料就執行 while 迴圈

159
00:09:35,080 --> 00:09:37,460
在 while 迴圈中

160
00:09:37,460 --> 00:09:42,440
先從資料儲存取出一些資料 chunk（區塊）

161
00:09:42,440 --> 00:09:46,580
再以 chunk 為單位發送

162
00:09:46,580 --> 00:09:51,120
發送成功後刪除資料

163
00:09:51,120 --> 00:09:54,538
發生錯誤時就就從 while 迴圈離開並中斷

164
00:09:54,538 --> 00:09:57,158
資料儲存沒有資料時

165
00:09:57,158 --> 00:10:00,980
就從 while 迴圈離開

166
00:10:00,980 --> 00:10:05,980
如此 Digest Loop 就是我們的基本核心邏輯

167
00:10:05,980 --> 00:10:09,480
讓我們多看一下這段原始碼

168
00:10:09,480 --> 00:10:16,538
這裡有一個類似 Data Store 的組件

169
00:10:16,538 --> 00:10:17,960
還有 Network Client

170
00:10:17,960 --> 00:10:21,538
至於用來容納這個 while 迴圈的

171
00:10:21,538 --> 00:10:23,259
某個 class 也是必要的對吧

172
00:10:23,259 --> 00:10:25,259
我們稱它為 Dispatcher

173
00:10:27,317 --> 00:10:30,177
還有一個謎之結構體 DataToSend

174
00:10:30,177 --> 00:10:33,240
這也會是某種型別

175
00:10:33,240 --> 00:10:36,879
所以我們可以從這份程式碼展開說明

176
00:10:36,879 --> 00:10:39,519
會接到什麼話題呢

177
00:10:39,519 --> 00:10:43,000
就是架構（Architecture）的話題啦

178
00:10:43,000 --> 00:10:47,320
讓我們先對剛才看到的那些東西

179
00:10:47,320 --> 00:10:48,658
決定其具體的名字

180
00:10:48,658 --> 00:10:51,240
例如 entity 設為 TrackingData

181
00:10:51,240 --> 00:10:52,639
就這樣命名

182
00:10:52,639 --> 00:10:57,057
Dispatcher 就叫 TrackingDispatcher

183
00:10:57,057 --> 00:11:00,340
SQLDataStore、NetworkClient 等

184
00:11:00,340 --> 00:11:02,259
如此定好具體的名稱

185
00:11:02,259 --> 00:11:08,080
實際給外部使用的公開介面就叫 Tracker

186
00:11:08,080 --> 00:11:09,658
就這樣命名

187
00:11:09,658 --> 00:11:11,918
如剛才所見

188
00:11:11,918 --> 00:11:18,860
我們定好了組件，所以可以從組件分層（Layer）

189
00:11:18,860 --> 00:11:22,240
光看這些可能不太明白，所以我畫了張圖

190
00:11:22,240 --> 00:11:26,200
這張圖只表示相依關係（Dependency）和協定符合（Protocol Conformance）

191
00:11:26,200 --> 00:11:33,639
大致架構就長這樣，例如紅色部分是 entity 和 dispatcher

192
00:11:33,639 --> 00:11:38,918
中間夾著協定（Protocol）

193
00:11:38,918 --> 00:11:42,120
順便一提，各位看過這樣的圖嗎？

194
00:11:42,120 --> 00:11:47,158
Clean Architecture 之類的，有很多圓圈層層包圍的那個

195
00:11:47,158 --> 00:11:48,158
我們來比較看看

196
00:11:48,158 --> 00:11:51,019
變成這樣

197
00:11:51,019 --> 00:11:56,940
請仔細看相依性的箭頭，都是指向內部，中心的

198
00:11:56,940 --> 00:12:02,200
所以符合 Clean Architecture 中箭頭的原則

199
00:12:02,200 --> 00:12:05,298
因此我這可以算是某種 Clean Architecture

200
00:12:05,298 --> 00:12:08,418
挺自然的 Clean 架構

201
00:12:08,418 --> 00:12:16,177
也就是說，這是容易測試、低耦合、容易替換相依性的架構

202
00:12:16,177 --> 00:12:19,485
這就是整體架構

203
00:12:20,019 --> 00:12:23,610
實體（Entity）是就這樣簡單的資料

204
00:12:24,100 --> 00:12:36,278
裡面有個 ID，以及將日誌的原始資料直接序列化保存的 data，就這樣的 struct

205
00:12:36,278 --> 00:12:37,899
當然要加上 Sendable

206
00:12:39,475 --> 00:12:42,440
Use Case 部分長這樣

207
00:12:42,440 --> 00:12:45,850
Dispatcher 周圍環繞著 Protocols

208
00:12:45,993 --> 00:12:48,995
就這樣的相依關係

209
00:12:49,000 --> 00:12:56,600
程式碼寫出來長這樣，並且 Dispatcher 只有 sendLog 一個方法

210
00:12:56,600 --> 00:13:03,620
以日誌名和 Dictionary 陣列為參數

211
00:13:03,620 --> 00:13:08,899
資料儲存（Data Store）包含 save、get、delete 等常見的 CRUD 操作

212
00:13:08,899 --> 00:13:14,322
網路部分更簡單，只是發送而已，所以只要一支 async 函數

213
00:13:15,653 --> 00:13:20,951
這時候要注意的是，當然全部都要加上 Sendable

214
00:13:23,307 --> 00:13:28,402
外層部分沒什麼特別的，單純是具體實作（Concrete Implementation）

215
00:13:29,475 --> 00:13:32,950
按照協定實作就好了

216
00:13:32,950 --> 00:13:34,379
這個待會再說

217
00:13:35,418 --> 00:13:38,950
接下來是組件的實作，首先是 Data Store

218
00:13:39,908 --> 00:13:42,052
這是左下部分

219
00:13:43,899 --> 00:13:50,908
Data Store 直接使用 SQLite3

220
00:13:53,509 --> 00:13:57,903
大家可以看到，這是 CREATE TABLE 的查詢，就這樣定義

221
00:13:58,259 --> 00:14:03,408
欄位只有 2 個，primary key 的 integer 和 app log

222
00:14:03,408 --> 00:14:07,706
直接序列化保存的簡單構成

223
00:14:07,990 --> 00:14:11,700
可能會有人問，為什麼使用 SQLite？

224
00:14:12,028 --> 00:14:14,966
單純的 schema 是第一個原因

225
00:14:14,966 --> 00:14:17,970
而且將來從根本上來說

226
00:14:18,557 --> 00:14:23,253
日誌系統本身，今後應該不太會發生移轉（Migration）

227
00:14:23,783 --> 00:14:25,658
所以 SQLite 就足夠了

228
00:14:27,923 --> 00:14:33,048
而且 SQLite 是 iOS 標準搭載的，不需要拉額外的函式庫

229
00:14:34,307 --> 00:14:38,412
所以這次單純地用 SQLite 就好

230
00:14:40,899 --> 00:14:43,225
我想說趕快就來寫 Code 看看，結果馬上就碰壁了

231
00:14:43,379 --> 00:14:46,048
為什麼呢？因為這是 C 函式庫

232
00:14:46,393 --> 00:14:53,048
所以要處理指標（Pointer），在 Swift 中要用 opaque pointer 之類的指標來處理

233
00:14:53,051 --> 00:14:59,019
但很遺憾，在 Swift Evolution 0331 中，opaque pointer 之類的型別的 Sendable 被移除了

234
00:14:59,019 --> 00:15:02,658
所以無論如何編譯都過不了

235
00:15:03,000 --> 00:15:04,605
那怎麼辦呢？

236
00:15:04,610 --> 00:15:10,677
還記得嗎？針對性地加上@unchecked Sendable

237
00:15:10,677 --> 00:15:17,807
所以我準備了這樣的包裝器(Wrapper)，隱藏 opaque pointer

238
00:15:17,988 --> 00:15:22,600
當然不是隨便亂加 Sendable，而是適當地加上鎖（Lock）

239
00:15:22,600 --> 00:15:26,796
如此一來至少可以保證這個部分是安全的

240
00:15:27,298 --> 00:15:30,916
套用後就長這樣

241
00:15:30,918 --> 00:15:37,557
資料庫指標隱藏在內部，所以程式碼變得簡潔

242
00:15:37,557 --> 00:15:40,557
而且它確實是 Sendable

243
00:15:40,557 --> 00:15:44,240
CRUD 的實作這次省略

244
00:15:44,240 --> 00:15:53,519
就是對 SQLite 執行 query 來實作而已，大家應該都做得到吧？

245
00:15:53,519 --> 00:15:56,317
如此而已，就請各位加油吧

246
00:15:56,317 --> 00:16:03,177
開玩笑的，範例程式碼裡都寫好了，請去看看

247
00:16:03,177 --> 00:16:06,557
稍微談談測試

248
00:16:06,557 --> 00:16:14,700
這裏只有 CRUD 操作，所以只要測試 I/O 處理的正常情況就好

249
00:16:16,317 --> 00:16:23,158
這時候要注意的是，我加了 @Suite(.serialize) 這個巨集（Macro）

250
00:16:23,158 --> 00:16:26,720
為什麼呢？因為需要直接操作檔案系統

251
00:16:26,720 --> 00:16:30,177
Swift Testing 預設，跟 XCTest 不同

252
00:16:30,177 --> 00:16:36,118
是並行處理的，全部都是併發

253
00:16:36,118 --> 00:16:39,500
所以測試案例執行（File I/O）時會發生競爭

254
00:16:39,500 --> 00:16:41,278
因此這時候要設為序列化（Serialize）

255
00:16:41,278 --> 00:16:42,639
這是重點

256
00:16:42,639 --> 00:16:44,076
好

257
00:16:46,096 --> 00:16:47,618
資料庫就說到這裡

258
00:16:47,618 --> 00:16:49,740
接下來是網路客戶端

259
00:16:49,740 --> 00:16:53,278
這是圖的右下部分

260
00:16:53,278 --> 00:16:54,720
首先

261
00:16:54,720 --> 00:16:59,057
URLSession 等 HTTP 客戶端的處理

262
00:16:59,057 --> 00:17:01,076
我不直接寫死（Hard Code）

263
00:17:01,076 --> 00:17:03,740
而是用 Protocol 包起來

264
00:17:03,740 --> 00:17:07,019
而且我們要做壓縮嘛

265
00:17:07,019 --> 00:17:12,220
所以我先假設 5kB 為門檻

266
00:17:12,220 --> 00:17:17,720
並定義一個常數來壓縮 http body

267
00:17:18,067 --> 00:17:21,420
就這樣的網路處理

268
00:17:21,930 --> 00:17:27,730
順便一提，處理重試等待時間的 Task.sleep

269
00:17:27,900 --> 00:17:33,276
這個 suspend 函數也作為閉包（Closure）注入

270
00:17:36,852 --> 00:17:41,140
接下來是協定 conformance 實作(NetworkClient)的前半部分

271
00:17:41,140 --> 00:17:44,920
如果資料大小超過 deflate 的門檻

272
00:17:44,920 --> 00:17:49,278
我們加上關於壓縮的 encoding header 並壓縮資料

273
00:17:49,278 --> 00:17:51,880
否則就直接發送

274
00:17:51,880 --> 00:17:56,076
後半部分是重試的邏輯部分

275
00:17:56,076 --> 00:17:59,160
我們寫 repeat while

276
00:17:59,160 --> 00:18:05,538
裡面夾 suspend 來進行發送

277
00:18:08,642 --> 00:18:13,259
壓縮演算法我是用 zlib 做的

278
00:18:13,259 --> 00:18:15,278
那個

279
00:18:15,278 --> 00:18:16,420
看各位的伺服器而定啦

280
00:18:16,420 --> 00:18:19,259
老實說什麼壓縮演算法都可以

281
00:18:19,612 --> 00:18:21,380
只要你們伺服器能接受就好

282
00:18:21,380 --> 00:18:25,278
順帶一提，Apple 官方的 Compression Framework

283
00:18:25,278 --> 00:18:27,920
我有試過但沒用

284
00:18:27,920 --> 00:18:32,538
所以才使用經典可信的 zlib 來實作

285
00:18:34,048 --> 00:18:36,576
稍微談談測試

286
00:18:36,576 --> 00:18:38,596
就這樣的構成

287
00:18:38,596 --> 00:18:40,440
全部可以用 Mock 注入

288
00:18:40,440 --> 00:18:43,855
所以重試的等待秒數也全部拿得到

289
00:18:43,855 --> 00:18:48,798
例如，注入一個會返回 400 錯誤的 Networking Mock

290
00:18:48,798 --> 00:18:51,000
我們可以觀察到

291
00:18:51,000 --> 00:18:53,576
第一次發送加上 3 次重試

292
00:18:53,576 --> 00:18:56,920
總共發送了 4 次 request，如此的 assertion（斷言）寫得出來

293
00:18:56,920 --> 00:18:58,538
秒數是 2、4、8

294
00:18:58,538 --> 00:19:00,440
2 的 n 次方這樣

295
00:19:01,460 --> 00:19:02,836
對，秒數拿得到

296
00:19:02,836 --> 00:19:05,019
終於到 Dispatcher 了

297
00:19:08,923 --> 00:19:12,615
我們把 DataStore，NetworkClient 和 ErrorHandler

298
00:19:12,615 --> 00:19:16,019
這些製作好的組件注入進來

299
00:19:16,748 --> 00:19:17,759
然後我們看這個 Task

300
00:19:17,759 --> 00:19:20,798
只有這個 Task 是 var

301
00:19:20,798 --> 00:19:24,855
所以我們用 actor 來做 Dispatcher

302
00:19:26,519 --> 00:19:27,519
並且在這上面

303
00:19:27,519 --> 00:19:33,372
我們把 actor 的 executor 覆寫(override)掉

304
00:19:34,509 --> 00:19:38,778
為什麼必須這樣做？

305
00:19:39,708 --> 00:19:41,663
是為了簡化處理

306
00:19:43,057 --> 00:19:51,855
雖然 actor 本身可以幫我們排除內部 Data Race

307
00:19:51,855 --> 00:19:55,105
但 actor 內部處理的順序

308
00:19:55,105 --> 00:19:56,259
我們就不知道了

309
00:19:56,259 --> 00:20:00,380
所以我刻意把 executor 做成序列化

310
00:20:00,380 --> 00:20:06,640
畢竟日誌系統本來做的事情就很單純

311
00:20:06,640 --> 00:20:09,700
用不到那麼多併發處理

312
00:20:09,700 --> 00:20:11,420
所以總之把它序列化

313
00:20:11,420 --> 00:20:15,240
就做了這樣的調整

314
00:20:15,240 --> 00:20:17,278
Digest Loop

315
00:20:17,278 --> 00:20:20,000
剛才好像有看過齁？

316
00:20:20,000 --> 00:20:22,960
就是把 while 迴圈放入 Task 中執行

317
00:20:25,940 --> 00:20:27,660
啊！對了

318
00:20:27,660 --> 00:20:30,557
最後我們這裡加上 yield()

319
00:20:30,557 --> 00:20:32,615
這個函數怎麼說勒

320
00:20:35,516 --> 00:20:38,817
yield 可以想成是時間未定的 Task.sleep

321
00:20:38,817 --> 00:20:40,019
叫 yield 目的是

322
00:20:40,019 --> 00:20:45,240
把 CPU 讓位給其他優先級高的運算

323
00:20:45,240 --> 00:20:48,400
對這系統來說這很理想

324
00:20:48,400 --> 00:20:50,019
所以在這裡

325
00:20:50,019 --> 00:20:51,557
加入 Task.yield

326
00:20:53,009 --> 00:20:56,410
Digest 的主體

327
00:20:56,410 --> 00:20:59,740
就是單純取出資料發送

328
00:21:00,548 --> 00:21:04,163
發送成功後刪除

329
00:21:04,500 --> 00:21:06,324
好這是資料保存的部分

330
00:21:07,556 --> 00:21:11,971
再寫個 Digest 開始和結束的函數

331
00:21:11,980 --> 00:21:13,798
然後這是 Protocol Conformance 的部分

332
00:21:13,798 --> 00:21:16,403
序列化後發送，就這樣

333
00:21:19,460 --> 00:21:23,468
測試當然全部用 Mock

334
00:21:24,740 --> 00:21:27,875
例如就這樣 mock 一切　什麼都測得到

335
00:21:28,124 --> 00:21:31,708
總之先隨便塞 70 件日誌

336
00:21:33,000 --> 00:21:36,884
再打 1 件日誌進去，開始 Digest 後發送了 2 次

337
00:21:36,971 --> 00:21:41,663
我們就可以 assert 71 件發送成功

338
00:21:42,201 --> 00:21:45,036
接下來是平行處理

339
00:21:45,307 --> 00:21:48,420
用 Task Group 瘋狂開始 Digest

340
00:21:48,923 --> 00:21:55,000
結果沒有任何日誌被重複發送，很好！

341
00:21:55,682 --> 00:21:56,932
Tracker 主體的部分

342
00:21:57,009 --> 00:21:59,266
這個不需要做什麼

343
00:21:59,432 --> 00:22:01,048
只要將所有組件放入

344
00:22:01,048 --> 00:22:03,236
準備通用的介面就好

345
00:22:03,663 --> 00:22:05,721
使用方法就這樣

346
00:22:05,788 --> 00:22:08,057
放入真的實作

347
00:22:08,057 --> 00:22:10,576
在這注入真的 Task.sleep

348
00:22:10,652 --> 00:22:14,798
把真的包有 URLSession 的 Networking 也注入進來

349
00:22:15,940 --> 00:22:17,519
測試覆蓋率的部分

350
00:22:17,519 --> 00:22:19,855
字雖然很小，是 82.6%

351
00:22:19,855 --> 00:22:21,400
挺高的勒

352
00:22:22,988 --> 00:22:24,980
終於完成基礎架構了！

353
00:22:25,865 --> 00:22:28,180
這還沒完喔

354
00:22:28,180 --> 00:22:29,855
來談移轉作業

355
00:22:31,142 --> 00:22:33,980
舉個例子，現在的狀況是

356
00:22:33,980 --> 00:22:36,480
有這樣的舊的日誌系統

357
00:22:36,480 --> 00:22:41,615
想要同時發送到剛才做的 Tracker

358
00:22:41,615 --> 00:22:43,720
那麼如此的

359
00:22:43,720 --> 00:22:47,038
Adapter Pattern（配接器模式）是可以考慮的做法

360
00:22:47,038 --> 00:22:49,576
總之在這個 Adapter 中

361
00:22:49,576 --> 00:22:51,057
發送到兩個系統

362
00:22:51,490 --> 00:22:52,557
遺憾的是

363
00:22:52,557 --> 00:22:53,940
我沒法這麼做

364
00:22:53,940 --> 00:22:55,538
為什麼？

365
00:22:55,538 --> 00:22:57,680
因為日誌的部分啊

366
00:22:57,680 --> 00:23:00,680
現實沒那麼順利

367
00:23:01,604 --> 00:23:03,900
能不需調整直接發送的日誌

368
00:23:03,900 --> 00:23:05,960
本來就不多

369
00:23:05,960 --> 00:23:08,576
而且兩系統 API 的介面也不吻合

370
00:23:08,576 --> 00:23:13,960
硬做的話

371
00:23:13,960 --> 00:23:21,038
就會變成這樣，效能也不好

372
00:23:21,038 --> 00:23:22,778
所以我放棄了

373
00:23:22,778 --> 00:23:26,115
那怎麼辦呢？

374
00:23:26,115 --> 00:23:35,750
用毅力硬幹！對！硬幹！就是把所有的日誌呼叫

375
00:23:35,932 --> 00:23:41,855
一個一個修改，作業量龐大，真的很辛苦

376
00:23:41,855 --> 00:23:48,400
不過這也不全都是壞事啦，老實說，畢竟是針對性地修改

377
00:23:48,400 --> 00:23:51,700
所以效能相對 Adapter 較好

378
00:23:52,460 --> 00:23:58,460
而且難得把日誌全看一遍，就順便跟大家討論「這個日誌到底是什麼？」

379
00:23:59,180 --> 00:24:02,420
不需要日誌就刪掉別做

380
00:24:02,420 --> 00:24:04,690
可以說是在做重構啦

381
00:24:04,690 --> 00:24:08,756
重構就是要在這種時機做

382
00:24:09,276 --> 00:24:12,355
不然以後沒機會了

383
00:24:12,355 --> 00:24:15,140
就把它當作正面因素吧

384
00:24:15,660 --> 00:24:17,740
那實際做的事情

385
00:24:17,740 --> 00:24:21,680
例如以點擊（Tap）日誌為例

386
00:24:21,680 --> 00:24:24,240
我們有舊的 Tap 事件日誌

387
00:24:24,240 --> 00:24:27,557
Tracker 也提供新的 Tap 事件

388
00:24:27,557 --> 00:24:31,596
這些東西分別呼叫他們底層的 API

389
00:24:31,596 --> 00:24:32,980
然後

390
00:24:34,009 --> 00:24:37,519
我們在舊的那邊增加方法

391
00:24:38,192 --> 00:24:39,240
然後就這樣

392
00:24:39,240 --> 00:24:40,798
接到新的 Tracker

393
00:24:41,288 --> 00:24:41,557
是的

394
00:24:42,380 --> 00:24:44,817
就像這樣

395
00:24:46,276 --> 00:24:48,268
而且它會返回 self

396
00:24:48,900 --> 00:24:51,317
所以它變成 Fluent Interface（流暢介面）

397
00:24:51,317 --> 00:24:56,180
如此一來　怎麼說勒

398
00:24:56,180 --> 00:25:00,759
Fluent Interface 比較好寫啦

399
00:25:00,759 --> 00:25:04,640
而且這樣寫，一看就知道

400
00:25:04,640 --> 00:25:06,519
這個日誌已經做好 Dual Send 了（不用額外註解）

401
00:25:06,519 --> 00:25:11,278
所以不需要個別修改的日誌

402
00:25:11,278 --> 00:25:14,900
夾入就這樣的方法就好

403
00:25:14,900 --> 00:25:16,355
就這樣

404
00:25:17,250 --> 00:25:19,817
需要個別修改的地方

405
00:25:19,817 --> 00:25:24,220
就這樣並排，進行個別實作

406
00:25:24,220 --> 00:25:27,759
例如這個例子

407
00:25:27,759 --> 00:25:30,115
改了鍵值（Key）

408
00:25:30,115 --> 00:25:32,200
item id 改為 new item id

409
00:25:32,200 --> 00:25:34,380
實際上我做的事情

410
00:25:34,380 --> 00:25:36,817
不只這麼單純啦

411
00:25:36,817 --> 00:25:39,900
有很多各式各樣的情況

412
00:25:39,900 --> 00:25:40,960
總之我努力全做掉了

413
00:25:42,067 --> 00:25:43,720
結果勒

414
00:25:43,720 --> 00:25:46,019
真的很辛苦

415
00:25:46,019 --> 00:25:48,298
在途中

416
00:25:48,298 --> 00:25:49,900
改到精神混亂

417
00:25:49,900 --> 00:25:53,519
「我到底在做什麼？」

418
00:25:53,519 --> 00:25:55,680
「我為什麼在這裡？」

419
00:25:55,680 --> 00:25:57,720
整個懷疑人生

420
00:25:57,720 --> 00:26:03,200
工作量真的非常龐大

421
00:26:03,200 --> 00:26:08,500
就抱持著這種心情

422
00:26:08,500 --> 00:26:14,660
反覆跟其他人討論「這個日誌到底是什麼？」

423
00:26:14,660 --> 00:26:17,538
結果，成功減少了 payload size（負載大小）

424
00:26:17,538 --> 00:26:19,980
實際上有很多共通參數

425
00:26:19,980 --> 00:26:22,836
討論後發現不需要就刪了

426
00:26:22,836 --> 00:26:29,096
所以新系統是成功減少了資料量

427
00:26:29,096 --> 00:26:32,557
舊系統當然就維持原樣

428
00:26:32,557 --> 00:26:37,038
這就是移轉作業的內容

429
00:26:39,548 --> 00:26:41,067
接下來

430
00:26:41,163 --> 00:26:44,019
既然東西做好了，就必須發布

431
00:26:44,508 --> 00:26:46,160
也就是發布計畫

432
00:26:47,105 --> 00:26:53,336
剛才也提到了階段性移轉有很多優點

433
00:26:53,336 --> 00:26:55,380
我想大家應該都有經驗吧

434
00:26:55,380 --> 00:26:58,700
canary release 之類的

435
00:26:58,700 --> 00:27:00,336
這麼做有很多優點

436
00:27:00,336 --> 00:27:03,240
當發現問題的時候

437
00:27:03,240 --> 00:27:04,538
立即停掉

438
00:27:04,538 --> 00:27:06,180
可以即時止血

439
00:27:06,180 --> 00:27:08,615
有很多優點

440
00:27:08,615 --> 00:27:11,680
畢竟萬一發展成大事故

441
00:27:11,680 --> 00:27:13,317
我們必須發 hotfix（緊急修復）

442
00:27:13,317 --> 00:27:14,596
這樣的話

443
00:27:14,596 --> 00:27:17,038
會很累的

444
00:27:17,038 --> 00:27:19,057
會牽連很多人，都要動起來

445
00:27:19,057 --> 00:27:23,336
所以如此大規模的移轉

446
00:27:23,336 --> 00:27:26,336
總之我是建議採用階段性移轉

447
00:27:26,336 --> 00:27:27,500
讓它風險可控

448
00:27:29,682 --> 00:27:33,440
對伺服器負載分散也有好處

449
00:27:33,440 --> 00:27:35,298
因為是逐漸開放

450
00:27:35,298 --> 00:27:39,440
如果一口氣 release 掉一大堆日誌

451
00:27:39,440 --> 00:27:42,240
伺服器那邊的負責人

452
00:27:42,240 --> 00:27:45,336
也不知道能伺服器撐不撐得住

453
00:27:45,336 --> 00:27:48,115
所以這對我們來說真的有必要

454
00:27:48,115 --> 00:27:51,115
順便問一下，大家還記得嗎？

455
00:27:51,115 --> 00:27:53,700
我們這次「不進行」強制更新

456
00:27:53,700 --> 00:27:57,538
所以這方面也需要某種對策

457
00:27:57,538 --> 00:28:03,140
為什麼呢？因為不進行強制更新的話

458
00:28:03,140 --> 00:28:08,920
一直使用舊版 app 的使用者

459
00:28:08,920 --> 00:28:13,140
會一直向舊系統發送日誌

460
00:28:13,140 --> 00:28:15,940
所以如果不做強更

461
00:28:15,940 --> 00:28:18,519
就這樣的發送會一直持續不斷

462
00:28:18,519 --> 00:28:21,759
剛才說過，伺服器整個會不見

463
00:28:21,759 --> 00:28:26,576
所以就會變成一直向不存在的 404 伺服器發送資料

464
00:28:26,576 --> 00:28:30,798
那你會問，為什麼不進行強制更新呢？

465
00:28:30,798 --> 00:28:34,240
純粹是因為使用者流失等等

466
00:28:34,240 --> 00:28:37,096
UX（使用者體驗）方面相關的顧慮

467
00:28:37,096 --> 00:28:38,420
上頭的意思是盡量不要做強更

468
00:28:38,420 --> 00:28:43,180
那我們就必須想出個折衷方案嘛

469
00:28:43,180 --> 00:28:48,400
所以再重複一次，不肯更新的使用者

470
00:28:48,400 --> 00:28:51,096
會一直向舊系統發送日誌

471
00:28:51,096 --> 00:28:53,920
成本削減的部分

472
00:28:53,920 --> 00:28:55,940
我想剛才說過

473
00:28:55,940 --> 00:29:01,798
所以需要 2 種控制

474
00:29:01,798 --> 00:29:07,038
對舊系統，我們準備「阻斷」日誌的 flag

475
00:29:07,038 --> 00:29:10,557
對新系統，我們要分階段推出（rollout）

476
00:29:10,557 --> 00:29:13,480
所以也準備一個 flag

477
00:29:13,480 --> 00:29:15,900
然後對使用者的比例

478
00:29:15,900 --> 00:29:17,778
逐漸開放

479
00:29:17,778 --> 00:29:21,500
這裡要注意的是

480
00:29:21,500 --> 00:29:25,115
阻斷控制的預設值是 true

481
00:29:25,115 --> 00:29:26,096
並且 100% 全面開放

482
00:29:26,096 --> 00:29:27,880
對於 app 內寫死的值

483
00:29:27,880 --> 00:29:30,759
例如 flag 不存在的情況

484
00:29:30,759 --> 00:29:33,380
程式碼中寫死的值

485
00:29:33,380 --> 00:29:34,680
要寫成 false

486
00:29:34,680 --> 00:29:38,057
rollout 的部分則相反

487
00:29:38,057 --> 00:29:40,519
從 false 變為 true

488
00:29:40,519 --> 00:29:45,596
無論如何，預設值要設為控制的最終狀態

489
00:29:45,596 --> 00:29:51,019
所以 flag 最後可以從 Firebase 上刪掉

490
00:29:51,019 --> 00:29:58,900
刪掉 flag 之後系統仍會按照最終狀態運作

491
00:29:58,900 --> 00:30:01,220
就這樣的設定

492
00:30:01,220 --> 00:30:04,576
實際成果

493
00:30:04,576 --> 00:30:08,778
2024 年 10 月

494
00:30:08,778 --> 00:30:11,640
就已經預先發布了阻斷控制

495
00:30:11,640 --> 00:30:15,240
所以大約 1 年前

496
00:30:15,240 --> 00:30:20,759
這個 true 值

497
00:30:20,759 --> 00:30:23,759
我們就花時間

498
00:30:23,759 --> 00:30:27,460
讓幾乎所有使用者都有這個 flag

499
00:30:27,460 --> 00:30:31,660
然後隔了 1 個月

500
00:30:31,660 --> 00:30:33,538
發布控制實作

501
00:30:33,538 --> 00:30:39,880
所以對舊系統來說彷彿什麼事都沒發生

502
00:30:39,880 --> 00:30:42,680
而實際上當時已經埋好 flag 了

503
00:30:42,680 --> 00:30:47,960
之後改 flag，對舊系統的 Log 就會全部被截掉

504
00:30:47,960 --> 00:30:49,317
就這樣

505
00:30:49,317 --> 00:30:52,836
強制更新就不用做了

506
00:30:52,836 --> 00:30:57,240
至於新系統的實際成果

507
00:30:57,240 --> 00:31:02,615
今年 1 月，將 flag 設為 false，100%開放

508
00:31:02,615 --> 00:31:16,538
於 4 月 10 日左右將所有新日誌都發布掉

509
00:31:16,538 --> 00:31:20,140
因為我們用 Calendar Versioning（日曆版本控制）

510
00:31:20,140 --> 00:31:24,500
所以發布時期大概是這個時候很好懂

511
00:31:24,500 --> 00:31:29,380
分 5 個階段，這樣發布

512
00:31:29,380 --> 00:31:36,076
然而 4 月的上旬我們立即觀察到問題，所以暫時設回 0%

513
00:31:36,076 --> 00:31:42,500
設法修好後，沒問題了，就跳過中間直接到 50%

514
00:31:42,500 --> 00:31:45,960
之後就按照預定計畫進行

515
00:31:45,960 --> 00:31:51,615
結果是沒有發 hotfix，非常順利

516
00:31:52,259 --> 00:31:55,240
實務上的穩定性也好，人員心理上也很安心

517
00:31:55,240 --> 00:31:58,699
特別是能安心這件事非常重要

518
00:31:58,699 --> 00:32:01,179
出事的時候急來急去真的會很累

519
00:32:01,179 --> 00:32:07,278
真心推薦用穩健的方式發布比較好

520
00:32:07,278 --> 00:32:11,400
flag 的控制等等

521
00:32:11,400 --> 00:32:19,038
也是在計畫階段就決定好 true 和 false 的方針

522
00:32:19,038 --> 00:32:22,219
所以就沒有殘留問題

523
00:32:22,219 --> 00:32:25,817
就是不會造成 flag 永遠無法刪除的狀態

524
00:32:25,817 --> 00:32:30,788
強制更新當然沒有進行

525
00:32:30,788 --> 00:32:34,019
現在還在 Dual Send 的適應期

526
00:32:34,211 --> 00:32:40,220
所以還差一點點

527
00:32:40,220 --> 00:32:45,940
在發布完之後，做的事情就是監控，如果有 crash 就修正

528
00:32:45,940 --> 00:32:49,817
調查原因並修正

529
00:32:49,817 --> 00:32:54,980
還有還沒做的事情啦，控制 flag 的刪除，舊實作的刪除，這些工作還留著

530
00:32:54,980 --> 00:33:00,159
當然這是身為工程師最爽的階段

531
00:33:00,159 --> 00:33:06,500
刪除不需要的實作，一口氣生 2000 行的紅字

532
00:33:06,500 --> 00:33:13,759
的差異(git diff)，雖然還不能刪啦，但我很期待

533
00:33:13,759 --> 00:33:17,380
所以還沒做完，我們還差一些一切就結束了

534
00:33:17,380 --> 00:33:20,380
進入總結

535
00:33:20,739 --> 00:33:27,699
首先，談了日誌系統到底是什麼，什麼是行為日誌

536
00:33:27,699 --> 00:33:35,817
從一開始構思的核心邏輯 Digest Loop

537
00:33:35,817 --> 00:33:39,336
展開到介面設計、架構的話題

538
00:33:39,336 --> 00:33:42,317
當然採用 Clean SOLID 的架構

539
00:33:42,317 --> 00:33:48,337
基於 Swift 6 的實作進行介紹

540
00:33:48,337 --> 00:33:51,880
針對測試程式碼就挑重點部分介紹了

541
00:33:51,880 --> 00:33:56,980
完整的原始碼在範例 repository 裡，可以去看看

542
00:33:56,980 --> 00:34:00,357
而且這是自製的基礎建設

543
00:34:00,357 --> 00:34:02,636
基本上都是我寫的

544
00:34:02,636 --> 00:34:10,755
今後的功能擴展，或想加什麼功能，不需要依賴外部人員

545
00:34:11,371 --> 00:34:12,780
公司內部解決

546
00:34:13,300 --> 00:34:15,679
這是自製的優點

547
00:34:15,679 --> 00:34:20,449
代價是我會很累啦，開玩笑的

548
00:34:20,449 --> 00:34:26,076
做一套基礎架構其實滿有趣的，大家有機會一定要試試看

549
00:34:26,420 --> 00:34:27,996
一點都不可怕

550
00:34:29,268 --> 00:34:30,889
總結 2

551
00:34:30,891 --> 00:34:42,750
介紹了移轉作業的方法，雖然有優雅的 Adapter Pattern，但現實沒那麼理想

552
00:34:43,018 --> 00:34:44,876
通常都是這樣啦

553
00:34:44,880 --> 00:34:48,018
理想終究是理想

554
00:34:48,018 --> 00:34:50,280
所以基本上

555
00:34:50,280 --> 00:34:52,619
咬緊牙關，用毅力跟他拼了就對了

556
00:34:52,619 --> 00:34:55,139
大家也跟他拼了就對了！

557
00:34:55,139 --> 00:34:57,099
而且我撐過去了

558
00:34:57,099 --> 00:34:59,800
結果不錯啦

559
00:35:01,092 --> 00:35:03,000
重構也做了

560
00:35:03,000 --> 00:35:04,420
還行啦

561
00:35:04,842 --> 00:35:10,599
也透過原始碼介紹了 Helper 方法以及個別實作的具體手段

562
00:35:10,599 --> 00:35:12,420
總結 3

563
00:35:12,420 --> 00:35:13,860
這部分很簡單

564
00:35:15,179 --> 00:35:16,239
重點就是

565
00:35:16,239 --> 00:35:20,760
對舊系統設為 false 後再改成 true

566
00:35:20,760 --> 00:35:22,400
說反了

567
00:35:22,400 --> 00:35:25,699
是設為 true 後再改成 false

568
00:35:25,699 --> 00:35:28,199
對新系統的 rollout

569
00:35:28,199 --> 00:35:31,159
則從 false 變為 true

570
00:35:31,159 --> 00:35:35,980
如此安排 config（設定）就刪得掉

571
00:35:35,980 --> 00:35:38,780
我覺得這樣的安排才好

572
00:35:38,780 --> 00:35:42,179
不需要強制更新

573
00:35:42,179 --> 00:35:45,099
希望能夠給大家作為參考

574
00:35:45,099 --> 00:35:49,239
這次日誌 rollout 我們分了 5 階段

575
00:35:49,239 --> 00:35:53,018
分幾階段都可以，你高興就好

576
00:35:53,018 --> 00:35:55,619
再講些多餘的話題

577
00:35:55,619 --> 00:35:59,900
這次只是做了基本的日誌基礎架構

578
00:35:59,900 --> 00:36:02,239
其實還有很多事情可以做

579
00:36:02,239 --> 00:36:05,199
比如配合 CPU 使用率、記憶體

580
00:36:05,199 --> 00:36:07,059
調整發送頻率之類的

581
00:36:07,059 --> 00:36:08,920
就這樣的改進是可以考慮的

582
00:36:08,920 --> 00:36:11,380
比如遊戲 app 或高即時 app 等

583
00:36:11,380 --> 00:36:14,500
對效能要求嚴格的 app

584
00:36:14,500 --> 00:36:19,440
日誌系統可以考慮以上因素

585
00:36:19,440 --> 00:36:27,159
還有磁碟容量幾乎吃滿的使用者基本上連打開資料庫都做不到

586
00:36:27,159 --> 00:36:28,619
這時候

587
00:36:28,619 --> 00:36:32,371
可以做 fallback（回退）到記憶體資料儲存

588
00:36:32,851 --> 00:36:34,360
就這樣

589
00:36:34,360 --> 00:36:37,039
我們可以不改變架構的同時

590
00:36:37,039 --> 00:36:40,039
只要替換相依性

591
00:36:40,039 --> 00:36:41,119
就能變成記憶體資料儲存

592
00:36:41,119 --> 00:36:42,679
就這樣的手段

593
00:36:42,679 --> 00:36:44,960
至於離線環境

594
00:36:44,960 --> 00:36:47,699
例如在飛機上

595
00:36:47,699 --> 00:36:49,500
根本發送不了 Log

596
00:36:49,500 --> 00:36:52,219
所以我們可以監控 Reachability（網路可達性）

597
00:36:52,219 --> 00:36:54,300
離線就不送 Log

598
00:36:54,300 --> 00:36:55,780
等連上 Wi-Fi 後

599
00:36:55,780 --> 00:36:57,719
再狂送 Log

600
00:36:57,719 --> 00:36:59,980
就這樣的改進是可以考慮的

601
00:36:59,980 --> 00:37:02,960
以上就是全部內容

602
00:37:02,960 --> 00:37:04,739
重複一次

603
00:37:04,739 --> 00:37:06,199
參考資料在這裡

604
00:37:06,199 --> 00:37:08,099
還有原始碼 repository

605
00:37:08,099 --> 00:37:09,860
範例程式碼

606
00:37:09,860 --> 00:37:10,940
歡迎看看

607
00:37:10,940 --> 00:37:13,420
稍微宣傳一下

608
00:37:13,420 --> 00:37:14,840
我們會舉辦 After Event（後續活動）

609
00:37:14,840 --> 00:37:16,018
預計會談

610
00:37:16,018 --> 00:37:18,639
LINE 漫畫的幕後故事

611
00:37:18,639 --> 00:37:21,099
ebookjapan 等等的幕後故事

612
00:37:21,099 --> 00:37:23,159
預定會聊這些

613
00:37:23,159 --> 00:37:25,780
時間是下個月

614
00:37:25,780 --> 00:37:27,719
10 月 17 日

615
00:37:27,719 --> 00:37:29,199
距離現在還有點久齁

616
00:37:29,199 --> 00:37:29,960
晚上 7 點

617
00:37:29,960 --> 00:37:31,820
地點是我們辦公室

618
00:37:31,820 --> 00:37:35,579
六本木東京 Midtown 11 樓

619
00:37:36,027 --> 00:37:37,860
connpass 頁面在這裡

620
00:37:37,860 --> 00:37:39,880
歡迎來參加

621
00:37:39,880 --> 00:37:41,739
我們會準備好吃的等你

622
00:37:41,739 --> 00:37:50,739
以上，就是支撐 LINE 漫畫的日誌基礎架構設計開發的一切

623
00:37:51,692 --> 00:37:54,003
感謝大家聆聽！

624
00:38:02,483 --> 00:38:04,532
感謝您的發表！

625
00:38:04,958 --> 00:38:08,177
那我們進入 Q&A

626
00:38:08,177 --> 00:38:10,697
有意見或有問題的人請舉手

627
00:38:16,617 --> 00:38:17,657
我拿麥克風給您

628
00:38:18,565 --> 00:38:20,755
謝謝

629
00:38:20,755 --> 00:38:24,474
整體架構是 Clean Architecture

630
00:38:24,474 --> 00:38:26,474
結構很乾淨

631
00:38:26,474 --> 00:38:27,474
而且也做成了容易測試的結構

632
00:38:27,474 --> 00:38:29,440
我覺得真的很棒

633
00:38:29,440 --> 00:38:34,880
我自己也蠻常在產品裡用 Firebase

634
00:38:34,898 --> 00:38:38,036
把意見送出後，也能學到那塊的理解就更好了，這是我自己的想法

635
00:38:38,938 --> 00:38:41,438
這個在最終發佈之前

636
00:38:41,438 --> 00:38:43,036
關於開發期間之類的

637
00:38:43,036 --> 00:38:49,532
人數大概需要多少人來開發呢？

638
00:38:49,532 --> 00:38:51,333
這能說嗎？

639
00:38:52,077 --> 00:38:54,637
開發就我一個人

640
00:38:54,637 --> 00:38:55,838
所以

641
00:38:56,565 --> 00:38:59,277
人力資源不夠嘛

642
00:38:59,277 --> 00:39:01,177
就只有 Compression Framework 而已 (測試失敗的那個)

643
00:39:01,177 --> 00:39:03,056
全部都是我自己想的

644
00:39:04,465 --> 00:39:05,077
厲害

645
00:39:05,077 --> 00:39:09,733
有時候啊，還是需要一點沒有根據的自信

646
00:39:09,733 --> 00:39:11,965
不然什麼都開始不了

647
00:39:11,965 --> 00:39:13,358
結果嘛，最後也算是 OK

648
00:39:13,358 --> 00:39:14,777
就像這樣

649
00:39:14,777 --> 00:39:16,137
五千萬次下載

650
00:39:16,137 --> 00:39:17,878
這種規模的

651
00:39:17,878 --> 00:39:19,657
日誌架構就是這樣做到的

652
00:39:19,657 --> 00:39:21,418
請務必拿去參考

653
00:39:21,418 --> 00:39:22,637
開發期間呢

654
00:39:22,637 --> 00:39:24,597
花了超過一年

655
00:39:24,597 --> 00:39:27,077
因為本來工作量就非常多

656
00:39:27,077 --> 00:39:33,117
再加上作業以外的溝通、協調、運氣之類的也有不少。

657
00:39:33,117 --> 00:39:38,617
整體來說，大概是一年半左右吧？不太確定

658
00:39:38,617 --> 00:39:41,818
活用 AI 之類的做法

659
00:39:41,818 --> 00:39:44,132
能不能利用 AI 來處理一些範本化的部分

660
00:39:44,132 --> 00:39:46,617
再把基底部分修一修

661
00:39:46,617 --> 00:39:47,617
果然還是有點難嗎？

662
00:39:47,617 --> 00:39:52,864
從今年開始的專案，我們就已經比較多和 AI 一起使用了

663
00:39:52,864 --> 00:39:58,679
不過這個專案是去年做的

664
00:39:58,679 --> 00:40:03,914
那時候並沒有特別使用 AI 工具

665
00:40:03,914 --> 00:40:05,713
順帶一提，像這樣的架構呢

666
00:40:05,713 --> 00:40:10,014
也有和其他厲害的人討論過

667
00:40:10,014 --> 00:40:14,065
大家都覺得「這樣的構成應該可行」，就照這個方向前進了。

668
00:40:14,199 --> 00:40:17,199
原來那時候還沒有導入 AI 呢，謝謝

669
00:40:17,800 --> 00:40:19,199
謝謝

670
00:40:19,333 --> 00:40:23,431
還有問題的人請舉手

671
00:40:23,965 --> 00:40:25,994
我們會把麥克風遞過去，請稍候

672
00:40:34,733 --> 00:40:36,572
精彩的發表，謝謝您

673
00:40:36,833 --> 00:40:41,672
我自己其實也在公司內部開發使用者行為紀錄（user code log）的 framework

674
00:40:41,672 --> 00:40:46,934
關於會懷疑人生、或者靠毅力很重要那段，我非常有共鳴

675
00:40:47,833 --> 00:40:49,934
我有個小問題

676
00:40:49,934 --> 00:40:52,152
在需求檔案裡面有提到

677
00:40:52,152 --> 00:40:59,864
「送出日誌時的記憶體消耗」以及「電力消耗」這些項目。

678
00:40:59,864 --> 00:41:05,900
我很好奇，這些部分的驗證是怎麼進行的？

679
00:41:06,052 --> 00:41:15,393
你們是自己做測試 App 導入那個函式庫，然後對新舊版本做基準測試（benchmark）

680
00:41:15,393 --> 00:41:22,652
還是直接在實際的服務 App 裡面引入後進行測試？

681
00:41:22,652 --> 00:41:25,273
關於這部分呢，我們當時有考慮過

682
00:41:25,273 --> 00:41:30,773
老實說，沒有做基準測試

683
00:41:30,773 --> 00:41:35,773
一來是排程上的考量

684
00:41:35,773 --> 00:41:41,931
而且這個架構本身已經是相當精簡的設計了

685
00:41:41,931 --> 00:41:44,233
所以我們的策略是

686
00:41:44,233 --> 00:41:47,773
如果出問題，就先暫停，然後再重新檢視

687
00:41:47,773 --> 00:41:49,773
也就是說，採用

688
00:41:49,773 --> 00:41:51,773
先發佈，之後再來考慮

689
00:41:51,773 --> 00:41:53,773
採取這種做法

690
00:41:53,773 --> 00:41:57,900
結果來看呢，我自己也有看實際的 Xcode Instrument

691
00:41:57,900 --> 00:42:03,766
沒有特別出現問題，所以就先上線看看

692
00:42:03,766 --> 00:42:09,666
至於基準測試部分，因為我自己不太熟悉這一塊

693
00:42:09,666 --> 00:42:12,666
所以沒能深入處理，這部分真的很抱歉

694
00:42:12,994 --> 00:42:15,014
不會，沒問題

695
00:42:15,014 --> 00:42:16,400
非常感謝

696
00:42:16,965 --> 00:42:17,592
謝謝回答

697
00:42:17,592 --> 00:42:23,494
時間關係，下一位應該是最後一位。有評論或問題的請舉手

698
00:42:31,172 --> 00:42:34,599
沒有其他人了嗎？

699
00:42:37,313 --> 00:42:40,193
Q&A 到這邊先告一段落

700
00:42:40,193 --> 00:42:42,833
接下來是 1 分鐘的回饋時間

701
00:42:46,565 --> 00:42:52,132
翻譯：dsxsxsxs
校對：Hokila